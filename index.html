<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probly</title>

    <link rel="manifest" href="/manifest.json">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
    <link rel="stylesheet" href="/assets/katex.min.css">
    <script defer src="/assets/katex.min.js"></script>
    <script defer src="/assets/auto-render.min.js"></script>
    <script src="/assets/numeric.min.js"></script>
    <script src="/assets/d3.v7.min.js"></script>
    <script src="/assets/jstat.min.js"></script>
    <script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                .then((registration) => {
                        console.log('Service Worker registered with scope:', registration.scope);
                        })
                .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                        });
                });
    }
    </script>

    <style>
        /* General and Layout Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 16px;
            line-height: 1.6;
            background-color: #fdfdfd;
            color: #333;
            margin: 0 0 2rem 0;
        }
        header { display: flex; align-items: center; background-color: #f8f9fa; padding: 10px 20px; border-bottom: 1px solid #dee2e6; position: sticky; top: 0; z-index: 1001; }
        header h1 { margin: 0; font-size: 1.5rem; }
        #menu-btn { font-size: 1.5rem; background: none; border: none; cursor: pointer; margin-right: 15px; }
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 250px;
            background-color: white;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1002;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            box-sizing: border-box;
        }
        #menu.visible {
            transform: translateX(0);
        }
        .menu-header {
            height: 60px;
            display: flex;
            align-items: center;
            padding-left: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            border-bottom: 1px solid #dee2e6;
            box-sizing: border-box;
        }
        #menu ul { list-style: none; margin: 0; padding: 0; }
        #menu a { display: block; padding: 10px 20px; text-decoration: none; color: #333; }
        #menu a:hover { background-color: #f0f0f0; }
        .app-container { display: none; }
        .app-container.active { display: block; }
        #distributions-app.active, #order-statistics-app.active, #gaussian-copula-app.active, #wiener-process-app.active { display: grid; }

        .slider-group { display: flex; align-items: center; gap: 10px; }
        .slider-group input[type="range"] { flex-grow: 1; margin: 0; }

        /* Scoped styles for Correlated Bernoulli App */
        #bernoulli-app { max-width: 800px; }
        #bernoulli-app table { border-collapse: collapse; width: 100%; margin-bottom: 1.5rem; text-align: center; }
        #bernoulli-app th, #bernoulli-app td { border: 1px solid #ccc; padding: 0; }
        #bernoulli-app th { background-color: #f7f7f7; font-weight: normal; }
        #bernoulli-app td.label { background-color: #f7f7f7; font-weight: bold; }
        #bernoulli-app input[type="number"] { width: 100%; height: 100%; border: 2px solid transparent; padding: 10px; box-sizing: border-box; text-align: center; font-size: 1em; background-color: #fff; color: #888; }
        #bernoulli-app input.user-input { color: black; font-weight: bold; }
        #bernoulli-app input:focus { outline: none; border-color: #007bff; }
        #bernoulli-app .error { color: #d9534f !important; border-color: #d9534f !important; }
        #bernoulli-app .correlation-container { display: flex; align-items: center; gap: 10px; margin-bottom: 1.5rem; }
        #bernoulli-app .correlation-container label { font-weight: bold; }
        #bernoulli-app .correlation-container input { flex-grow: 1; }
        #bernoulli-app button { padding: 10px 15px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; border-radius: 4px; }
        #bernoulli-app button:hover { background-color: #e0e0e0; }
        #bernoulli-app #plots-container { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 20px; margin-top: 2rem; }
        #bernoulli-app .plot { border: 1px solid #ddd; padding: 10px; border-radius: 4px; }
        #bernoulli-app .plot-title { text-align: center; font-weight: bold; margin-bottom: 5px; font-size: 0.9em; }
        #bernoulli-app .variable-names-container { margin-top: .5rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        #bernoulli-app .variable-names-container input { padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; }
        #bernoulli-app .variable-names-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        #bernoulli-app details { margin-top: 1rem; }

        /* Shared App Styles */
        .app-container {
            --panel-bg: #f9f9f9; --border-color: #ccc; --accent-color: steelblue;
            grid-template-columns: 320px 1fr;
            gap: 15px; padding: 15px; max-width: 1400px; margin: auto;
        }
        .panel { padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--panel-bg); }

        h3, h4 {
            margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px;
        }
        #gaussian-copula-app h4 { margin-top: 0; } /* Has no border */

        .param-group, .control-group {
            margin-bottom: 10px;
        }
        label {
            display: block; font-weight: bold; margin-bottom: 5px;
        }

        .plot-svg-wrapper { position: relative; resize: both; overflow: auto; display: flex; min-height: 300px; }
        .axis path, .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
        .line-path { fill: none; stroke-width: 2px; }
        .area-path, .cone-area { opacity: 0.3; }
        .drag-selection { fill: rgba(255, 165, 0, 0.4); stroke: rgba(255, 165, 0, 1); stroke-width: 1px; }
        .drag-text { font-size: 12px; font-weight: bold; fill: #d9534f; text-anchor: middle; }

        details.panel { grid-column: 1 / -1; }
        details > summary { font-weight: bold; cursor: pointer; }
        details .formulas { padding-top: 1rem; }

        .quick-controls-container { display: flex; gap: 5px; align-items: center; padding: 0; }
        .quick-controls-container button { font-size: 0.9em; cursor: pointer; }
        .quick-slider-container { flex-grow: 1; }
        .quick-param-buttons { display: flex; justify-content: center; gap: 5px; flex-wrap: wrap; max-width: 50%; }

        /* Scoped styles for Distributions App */
        #distributions-app {
            grid-template-rows: auto auto 1fr;
            grid-template-areas: "controls plot" "stats plot" "sampling plot";
        }
        #distributions-app #controls-panel { grid-area: controls; }
        #distributions-app #stats-panel { grid-area: stats; }
        #distributions-app #sampling-panel { grid-area: sampling; }
        #distributions-app #plot-container { grid-area: plot; display: flex; flex-direction: column; position: relative; }
        #distributions-app input, #distributions-app select, #distributions-app button { padding: 10px 15px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #distributions-app button { background-color: #007bff; color: white; border: none; cursor: pointer; }
        #distributions-app button:hover { background-color: #0056b3; }
        #distributions-app button:disabled { background-color: #ccc; cursor: not-allowed; }
        #distributions-app #stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em; }
        #distributions-app #stats-grid span { font-weight: bold; color: #333; }
        #distributions-app #conditional-expectations-grid { display: flex; flex-wrap: wrap; gap: 5px 2em; align-items: center; margin-top: 1em; }
        #distributions-app #formula-display { margin-top: 20px; padding: 10px; background: #eee; border-radius: 3px; text-align: center; min-height: 50px; display: flex; align-items: center; justify-content: center; overflow-x: auto;}
        #distributions-app .plot-svg-wrapper { height: 50%; }
        #distributions-app #plot-svg { user-select: none; width: 100%; height: 100%; }
        #distributions-app .line-path { stroke: var(--accent-color); }
        #distributions-app .area-path { fill: var(--accent-color); }
        #distributions-app .bar { fill: var(--accent-color); }
        #distributions-app #tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #distributions-app .sample-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        #distributions-app #sample-clear-btn { grid-column: 1 / -1; background-color: #6c757d; }
        #distributions-app #sample-clear-btn:hover { background-color: #5a6268; }
        #distributions-app #samples-output { background: #e9ecef; padding: 10px; border-radius: 3px; height: 150px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; word-break: break-all; }
        #distributions-app #shading-controls { display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px; }

        /* Scoped styles for Order Statistics App */
        #order-statistics-app {
            grid-template-rows: auto 1fr;
            grid-template-areas: "controls plot" "stats plot";
        }
        #order-statistics-app #os-controls-panel { grid-area: controls; }
        #order-statistics-app #os-stats-panel { grid-area: stats; }
        #order-statistics-app #os-plot-container { grid-area: plot; display: flex; flex-direction: column; position: relative; }
        #order-statistics-app input, #order-statistics-app select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #order-statistics-app button { background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 3px; padding: 10px 15px; }
        #order-statistics-app button:hover { background-color: #0056b3; }
        #order-statistics-app #os-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em; }
        #order-statistics-app #os-stats-grid span { font-weight: bold; color: #333; }
        #order-statistics-app .plot-svg-wrapper { height: 70%; }
        #order-statistics-app #os-plot-svg { user-select: none; width: 100%; height: 100%; }
        #order-statistics-app .line-path { stroke: var(--accent-color); }
        #order-statistics-app .area-path { fill: var(--accent-color); }
        #order-statistics-app #os-tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }

        /* Scoped styles for Gaussian Copula App */
        #gaussian-copula-app {
            grid-template-rows: auto;
            grid-template-areas: "controls plots";
        }
        #gaussian-copula-app #gc-controls-panel { grid-area: controls; }
        #gaussian-copula-app #gc-formulas-panel { grid-column: 1 / -1; }
        #gaussian-copula-app #gc-plots-panel { grid-area: plots; display: flex; flex-direction: column; gap: 20px; padding: 0; border: none; background: transparent; }
        #gaussian-copula-app .gc-plot-container { padding: 0; display: flex; flex-direction: column; position: relative; }
        #gaussian-copula-app #gc-scatter-plot-container { min-height: 530px; }
        #gaussian-copula-app #gc-joint-plot-grid { flex-grow: 1; display: grid; grid-template-areas: "marg-x corner" "scatter marg-y"; grid-template-columns: 1fr 80px; grid-template-rows: 80px 1fr; gap: 5px; position: relative; resize: both; overflow: auto; }
        #gaussian-copula-app #gc-marginal-x-svg { grid-area: marg-x; }
        #gaussian-copula-app #gc-joint-plot-svg { grid-area: scatter; }
        #gaussian-copula-app #gc-marginal-y-svg { grid-area: marg-y; }
        #gaussian-copula-app #gc-joint-plot-grid svg { width: 100%; height: 100%; }
        #gaussian-copula-app .histogram-bar { fill: steelblue; opacity: 0.5; }
        #gaussian-copula-app input, #gaussian-copula-app select, #gaussian-copula-app button:not(.move-btn) { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #gaussian-copula-app button:not(.move-btn) { background-color: #007bff; color: white; border: none; cursor: pointer; }
        #gaussian-copula-app button:not(.move-btn):hover { background-color: #0056b3; }
        #gaussian-copula-app .sample-buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; margin-bottom: 10px; justify-content: center; }
        #gaussian-copula-app .sample-buttons button { width: auto; }
        #gaussian-copula-app .quick-controls-container button { width: auto; }
        #gaussian-copula-app #gc-sample-clear-btn { background-color: #6c757d; }
        #gaussian-copula-app #gc-sample-clear-btn:hover { background-color: #5a6268; }
        #gaussian-copula-app .plot-svg-wrapper { flex-grow: 1; }
        #gaussian-copula-app #gc-scatter-plot-svg { flex-grow: 1; user-select: none; }
        #gaussian-copula-app #gc-density-plot-svg { user-select: none; width: 100%; height: 100%; }
        #gaussian-copula-app .scatter-dot { fill: lightblue; stroke: steelblue; opacity: 0.6; }
        #gaussian-copula-app .line-path { stroke: #d9534f; }
        #gaussian-copula-app .area-path { fill: steelblue; }
        #gaussian-copula-app #gc-density-tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #gaussian-copula-app .gc-conditional-controls-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: center; justify-content: center; padding: 10px 0; }
        #gaussian-copula-app .gc-conditional-controls-row .control-group { flex: 1 1 150px; margin: 10px; }

        /* Scoped styles for Wiener Process App */
        #wiener-process-app {
            grid-template-areas: "params plots";
        }
        #wp-params-panel { grid-area: params; }
        #wp-plots-wrapper { grid-area: plots; display: flex; flex-direction: column; gap: 20px; min-width: 0; }
        #wiener-process-app .panel { position: relative; display: flex; flex-direction: column; }
        #wiener-process-app input, #wiener-process-app select, #wiener-process-app button:not(.move-btn) { width: 8em; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #wiener-process-app .control-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        #wiener-process-app .button-flex { justify-content: center; display: flex; gap: 20px; margin-top: 10px; }
        #wiener-process-app button:not(.move-btn) { background-color: #007bff; color: white; border: none; cursor: pointer; }
        #wiener-process-app button:not(.move-btn):hover { background-color: #0056b3; }
        #wiener-process-app #wp-clear-paths-btn { background-color: #6c757d; }
        #wiener-process-app #wp-clear-paths-btn:hover { background-color: #5a6268; }
        #wiener-process-app .wp-plot-container { min-height: 300px; position: relative; flex-grow: 1; resize: both; overflow: auto; display: flex; }
        #wiener-process-app #wp-paths-plot-grid { display: grid; grid-template-columns: 1fr 10%; grid-template-rows: 1fr; gap: 5px; }
        #wiener-process-app svg { width: 100%; height: 100%; }
        #wiener-process-app .line-path { stroke-width: 1.5px; }
        #wiener-process-app .cone-area { fill: var(--accent-color); }
        #wiener-process-app .sample-path { fill: none; stroke: #555; stroke-width: 1px; opacity: 0.6; }
        #wiener-process-app .wp-tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #wiener-process-app .histogram-bar { fill: steelblue; opacity: 0.5; }

        /* Scoped styles for Expected Value App */
        #expected-value-app { grid-template-columns: 1fr; max-width: 800px; margin: 2rem auto; }
        #expected-value-app .panel { grid-column: 1 / -1; }
        #expected-value-app .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 10px;
            margin-bottom: 1rem;
            align-items: center;
        }
        #expected-value-app .input-row {
            display: contents;
        }
        #expected-value-app input[type="number"] {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            border-radius: 3px;
        }
        #expected-value-app .prob-input.error {
            border-color: #d9534f;
            border-width: 3px;
        }
        #expected-value-app .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 1rem;
        }
        #expected-value-app .controls button {
             padding: 10px 15px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px;
             background-color: #f0f0f0; cursor: pointer;
        }
        #expected-value-app .controls button:hover { background-color: #e0e0e0; }
        #expected-value-app .controls button:disabled { background-color: #ccc; cursor: not-allowed; }
        #expected-value-app .plot-container {
            min-height: 300px;
            border: 1px solid var(--border-color);
        }
        #ev-plot-svg {
            width:100%;
        }
        #expected-value-app .remove-row-btn {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 1.2em;
            color: #888;
            padding: 0;
        }
        #expected-value-app .remove-row-btn:hover {
            color: #333;
        }
        #expected-value-app .expected-value-line {
            stroke: black;
            stroke-width: 3px;
        }
        #expected-value-app .expected-value-text {
            fill: black;
            font-weight: bold;
            font-size: 0.9em;
        }
        #expected-value-app .bar { opacity: .7; fill: var(--accent-color); }

        /* Scoped styles for Information Value App */
        #information-value-app { grid-template-columns: 1fr; max-width: 900px; margin: 2rem auto; }
        #information-value-app .panel { grid-column: 1 / -1; margin-top: 1rem; }
        #information-value-app .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 1rem; }
        #information-value-app .controls button { padding: 10px 15px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; background-color: #f0f0f0; cursor: pointer; }
        #information-value-app .controls button:hover { background-color: #e0e0e0; }
        #information-value-app table { border-collapse: collapse; width: 100%; margin-bottom: 1rem; }
        #information-value-app th, #information-value-app td { border: 1px solid #ccc; padding: 0; }
        #information-value-app th input, #information-value-app td input { width: 100%; height: 100%; border: none; padding: 8px; box-sizing: border-box; text-align: center; }
        #information-value-app input[type="number"].prob-input.error { border-color: #d9534f; border-width: 2px; }
        #information-value-app th { background-color: #f7f7f7; }
        #information-value-app .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem; }
        #information-value-app .result-item { padding: 10px; border: 1px solid var(--border-color); border-radius: 3px; background-color: var(--panel-bg); }
        #information-value-app .result-item h4 { margin: 0 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid var(--border-color); }
        #information-value-app .plot-container { min-height: 300px; border: 1px solid var(--border-color); }
        #information-value-app #iv-plot-svg { width: 100%; }
        #information-value-app .tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-50%, -110%); }
        #information-value-app .line-path { stroke: var(--accent-color); }


        .move-controls { position: absolute; top: 5px; right: 5px; z-index: 5; display: flex; flex-direction: row; }
        .move-btn { background: none; border: none; cursor: pointer; font-size: 0.8rem; padding: 0; line-height: 1; color: #888; }
        .move-btn:hover { color: #333; }

        #menu .nav-divider {
            height: 1px;
            background-color: #dee2e6;
            margin: 10px 0;
        }
        #menu .nav-secondary-item a {
            font-size: 0.9em;
            color: #555;
        }
        #install-app {
            max-width: 600px;
            margin: 2rem auto;
            padding: 2rem;
            text-align: center;
        }
        #install-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        #install-button:hover {
            background-color: #0056b3;
        }
        #install-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #install-button .icon {
            width: 24px;
            height: 24px;
        }
        #about-app {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        @media (max-width: 1000px) {
            body { font-size: 12px; line-height: 1.2; }
            #distributions-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "stats" "sampling" "plot"; }
            #order-statistics-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "stats" "plot"; }
            #gaussian-copula-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "plots" "formulas"; }
            #wiener-process-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "params" "plots"; }
            .panel { padding: 5px; border: 0; }
            .param-group, .control-group { margin-bottom: 3px; }
            label { margin-bottom: 1px; }
            .app-container { gap: 5px; padding: 0; }
        }
    </style>
</head>
<body>
    <header>
        <button id="menu-btn">☰</button>
        <h1 id="app-title-bar">Probly</h1>
    </header>
    <nav id="menu">
        <div class="menu-header">Probly</div>
        <ul>
            <li><a href="#distributions">Distributions</a></li>
            <li><a href="#order-statistics">Order Statistics</a></li>
            <li><a href="#gaussian-copula">Gaussian Copula</a></li>
            <li><a href="#wiener-process">Wiener Process</a></li>
            <li><a href="#bernoulli">Correlated Bernoulli</a></li>
            <li><a href="#expected-value">Expected Value</a></li>
            <li><a href="#information-value">Information Value</a></li>
            <div class="nav-divider"></div>
            <li class="nav-secondary-item"><a href="#about">About</a></li>
            <li class="nav-secondary-item"><a href="#install">Install on device</a></li>
        </ul>
    </nav>
    <main>
        <div id="bernoulli-app" class="app-container">
            <div class="panel">
                <h2>Correlated Bernoulli Variables Calculator</h2>
                <p>Enter exactly three values to compute the rest. User-entered values are <strong>black</strong>, calculated values are <span style="color:#888">grey</span>. Invalid states are shown in <span style="color:#d9534f">red</span>.</p>

                <p><button id="reset-button">Reset</button></p>

                <div class="variable-names-container">
                    <div class="variable-names-row">
                        <label for="x-name">Name for variable X:</label><input type="text" id="x-name" value="X">
                    </div>
                    <div class="variable-names-row">
                        <label for="y-name">Name for variable Y:</label><input type="text" id="y-name" value="Y">
                    </div>
                </div>

                <h3 class="katex-dynamic" data-katex-template="Joint & Marginal Probabilities: \( \mathbb{P}(\X=i, \Y=j) \)"></h3>
                <table>
                    <tr>
                        <th style="border:none; background:transparent;"></th>
                        <th class="katex-dynamic" data-katex-template="\( \Y = 0 \)"></th>
                        <th class="katex-dynamic" data-katex-template="\( \Y = 1 \)"></th>
                        <th class="katex-dynamic" data-katex-template="Marginal (\( \X \))"></th>
                    </tr>
                    <tr>
                        <td class="label katex-dynamic" data-katex-template="\( \X = 0 \)"></td>
                        <td><input type="number" id="p00" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="p01" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pX0" step="0.01" min="0" max="1"></td>
                    </tr>
                    <tr>
                        <td class="label katex-dynamic" data-katex-template="\( \X = 1 \)"></td>
                        <td><input type="number" id="p10" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="p11" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pX" step="0.01" min="0" max="1"></td>
                    </tr>
                    <tr>
                        <td class="katex-dynamic" data-katex-template="Marginal (\( \Y \))"></td>
                        <td><input type="number" id="pY0" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pY" step="0.01" min="0" max="1"></td>
                        <td style="background:#eee;">1</td>
                    </tr>
                </table>

                <h3>Conditional Probabilities</h3>
                <table>
                    <caption class="katex-dynamic" data-katex-template="Conditional Probabilities \( \mathbb{P}(\Y=j \mid \X=i) \)"></caption>
                    <tr>
                        <th style="border:none; background:transparent;"></th>
                        <th class="katex-dynamic" data-katex-template="\( \Y = 0 \)"></th>
                        <th class="katex-dynamic" data-katex-template="\( \Y = 1 \)"></th>
                    </tr>
                    <tr>
                        <td class="label katex-dynamic" data-katex-template="Given \( \X = 0 \)"></td>
                        <td><input type="number" id="pY0_X0" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pY1_X0" step="0.01" min="0" max="1"></td>
                    </tr>
                    <tr>
                        <td class="label katex-dynamic" data-katex-template="Given \( \X = 1 \)"></td>
                        <td><input type="number" id="pY0_X1" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pY1_X1" step="0.01" min="0" max="1"></td>
                    </tr>
                </table>
                <table>
                    <caption class="katex-dynamic" data-katex-template="Conditional Probabilities \( \mathbb{P}(\X=i \mid \Y=j) \)"></caption>
                    <tr>
                        <th style="border:none; background:transparent;"></th>
                        <th class="katex-dynamic" data-katex-template="\( \X = 0 \)"></th>
                        <th class="katex-dynamic" data-katex-template="\( \X = 1 \)"></th>
                    </tr>
                    <tr>
                        <td class="label katex-dynamic" data-katex-template="Given \( \Y = 0 \)"></td>
                        <td><input type="number" id="pX0_Y0" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pX1_Y0" step="0.01" min="0" max="1"></td>
                    </tr>
                    <tr>
                        <td class="label katex-dynamic" data-katex-template="Given \( \Y = 1 \)"></td>
                        <td><input type="number" id="pX0_Y1" step="0.01" min="0" max="1"></td>
                        <td><input type="number" id="pX1_Y1" step="0.01" min="0" max="1"></td>
                    </tr>
                </table>

                <h3>Correlation</h3>
                <div class="correlation-container">
                    <label for="rho">Correlation Coefficient (\( ρ \))</label>
                    <input type="number" id="rho" step="0.01" min="-1" max="1" style='border:1px solid #ccc;'>
                </div>

                <h3>Visualizations</h3>
                <div id="plots-container"></div>
            </div>

            <details class="panel">
                <summary>Formulas</summary>
                <div class="formulas" id="formula-container" data-katex-template='
                <p>In these formulas, \( p_{\X} = \mathbb{P}(\X=1) \) and \( p_{\Y} = \mathbb{P}(\Y=1) \).</p>
                <h4>Joint Distribution from Marginals and Correlation</h4>
                $$
                \begin{aligned}
                p_{11} &= p_{\X} p_{\Y} + \rho \sqrt{p_{\X}(1-p_{\X}) p_{\Y}(1-p_{\Y})} \\
                p_{10} &= p_{\X} - p_{11} \\
                p_{01} &= p_{\Y} - p_{11} \\
                p_{00} &= 1 - p_{\X} - p_{\Y} + p_{11}
                \end{aligned}
                $$

                <h4>Correlation from Joint and Marginals</h4>
                $$
                \rho = \frac{p_{11} - p_{\X} p_{\Y}}{\sqrt{p_{\X}(1-p_{\X})p_{\Y}(1-p_{\Y})}}
                $$

                <h4>Conditional Distributions</h4>
                $$
                \begin{aligned}
                \mathbb{P}(\Y=1\mid \X=1) &= \frac{p_{11}}{p_{\X}} \\
                \mathbb{P}(\Y=1\mid \X=0) &= \frac{p_{01}}{1-p_{\X}}
                \end{aligned}
                $$'>
                </div>
            </details>
        </div>
        <div id="distributions-app" class="app-container">
            <div id="controls-panel" class="panel">
                <h3>Controls</h3>
                <div class="control-group">
                    <label for="dist-select">Distribution</label>
                    <select id="dist-select"></select>
                </div>
                <div id="param-inputs"></div>
                <div id="formula-display"></div>
            </div>

            <div id="stats-panel" class="panel">
                <h3>Summary Statistics</h3>
                <div id="stats-grid">
                    <div>Mean: <span id="stat-mean"></span></div>
                    <div>Variance: <span id="stat-variance"></span></div>
                    <div>Std. Dev: <span id="stat-stddev"></span></div>
                    <div>25th %ile: <span id="stat-q1"></span></div>
                    <div>Median: <span id="stat-median"></span></div>
                    <div>75th %ile: <span id="stat-q3"></span></div>
                    <div>50% Interval: <span id="stat-int50"></span></div>
                    <div>90% Interval: <span id="stat-int90"></span></div>
                    <div>95% Interval: <span id="stat-int95"></span></div>
                    <div>99% Interval: <span id="stat-int99"></span></div>
                </div>
            </div>

            <div id="sampling-panel" class="panel">
                <h3>Sampling</h3>
                <div class="sample-buttons">
                    <button id="sample-btn-1">Generate 1 Sample</button>
                    <button id="sample-btn-10">Generate 10 Samples</button>
                    <button id="sample-clear-btn">Clear</button>
                </div>
                <div id="samples-output"></div>
            </div>

            <div id="plot-container" class="panel">
                <h3>Density plot</h3>
                <div id="shading-controls">
                    <div class="control-group">
                        <label for="interval-select">Shade Interval</label>
                        <select id="interval-select">
                            <option value="0">None</option>
                            <option value="p50">50%</option>
                            <option value="p90">90%</option>
                            <option value="p95" selected>95%</option>
                            <option value="p99">99%</option>
                            <option value="s1">+/- 1σ</option>
                            <option value="s2">+/- 2σ</option>
                            <option value="s3">+/- 3σ</option>
                        </select>
                    </div>
                </div>
                <div class="plot-svg-wrapper">
                    <svg id="plot-svg"></svg>
                </div>
                <div id="quick-controls-container" class="quick-controls-container">
                    <span>Adjust: </span>
                    <span id="quick-param-buttons" class="quick-param-buttons"></span>
                    <span id="quick-slider-container" class="quick-slider-container"></span>
                </div>
                <div id="conditional-expectations-grid"></div>
                <div id="tooltip"></div>
            </div>
        </div>
        <div id="order-statistics-app" class="app-container">
            <div id="os-controls-panel" class="panel">
                <h3>Controls</h3>
                <div class="control-group">
                    <label for="os-dist-select">Distribution</label>
                    <select id="os-dist-select"></select>
                </div>
                <div id="os-param-inputs"></div>
                <div class="control-group">
                    <label for="os-n">Sample size n</label>
                    <div class="slider-group">
                        <input type="range" id="os-n-slider" value="10" min="1" step="1">
                        <input type="number" id="os-n" value="10" min="1" step="1" style="width: 80px;">
                    </div>
                </div>
                <div class="control-group">
                    <label for="os-k">k-th order statistic</label>
                    <div class="slider-group">
                        <input type="range" id="os-k-slider" value="5" min="1" step="1">
                        <input type="number" id="os-k" value="5" min="1" step="1" style="width: 80px;">
                    </div>
                </div>
            </div>

            <div id="os-stats-panel" class="panel">
                <h3>Summary Statistics</h3>
                <div id="os-stats-grid">
                    <div>Mean: <span id="os-stat-mean"></span></div>
                    <div>Variance: <span id="os-stat-variance"></span></div>
                    <div>Std. Dev: <span id="os-stat-stddev"></span></div>
                    <div>25th %ile: <span id="os-stat-q1"></span></div>
                    <div>Median: <span id="os-stat-median"></span></div>
                    <div>75th %ile: <span id="os-stat-q3"></span></div>
                    <div>50% Interval: <span id="os-stat-int50"></span></div>
                    <div>90% Interval: <span id="os-stat-int90"></span></div>
                    <div>95% Interval: <span id="os-stat-int95"></span></div>
                    <div>99% Interval: <span id="os-stat-int99"></span></div>
                </div>
            </div>

            <div id="os-plot-container" class="panel">
                <h3>Density plot</h3>
                <div id="os-shading-controls" style="display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px;">
                    <div class="control-group">
                        <label for="os-interval-select">Shade Interval</label>
                        <select id="os-interval-select">
                            <option value="0">None</option>
                            <option value="p50">50%</option>
                            <option value="p90">90%</option>
                            <option value="p95" selected>95%</option>
                            <option value="p99">99%</option>
                            <option value="s1">+/- 1σ</option>
                            <option value="s2">+/- 2σ</option>
                            <option value="s3">+/- 3σ</option>
                        </select>
                    </div>
                </div>
                <div class="plot-svg-wrapper">
                    <svg id="os-plot-svg"></svg>
                </div>
                <div id="os-quick-controls-container" class="quick-controls-container">
                    <span>Adjust: </span>
                    <span id="os-quick-param-buttons" class="quick-param-buttons"></span>
                    <span id="os-quick-slider-container" class="quick-slider-container"></span>
                </div>
                <div id="os-tooltip"></div>
            </div>
            <details class="panel">
                <summary>Formulas</summary>
                <div class="formulas">
                    <h4>The marginal density of the k-th order statistic</h4>
                    <p>In an i.i.d. sample of size \(n\), the CDF and PDF of the \(k\)-th order statistic, \(X_{(k)}\), are:</p>
                    $$
                    \begin{aligned}
                    \mathbb{P}(X_{(k)} \le x) &= \sum_{i=k}^n {n \choose i} F(x)^i(1-F(x))^{n-i} \\
                    f_{X_{(k)}}(x) &= k{n\choose k}f(x)F(x)^{k-1}(1-F(x))^{n-k}
                    \end{aligned}
                    $$
                    <p>Note that the case \(k=n\) is usually called maximum, and \(k=1\) is called minimum.</p>
                </div>
            </details>
        </div>
        <div id="gaussian-copula-app" class="app-container">
            <div id="gc-controls-panel" class="panel">
                <h3>Marginal Distributions</h3>
                <h4>Marginal for X</h4>
                <div class="control-group">
                    <label for="gc-dist-select-x">Distribution</label>
                    <select id="gc-dist-select-x"></select>
                </div>
                <div id="gc-param-inputs-x"></div>

                <h4>Marginal for Y</h4>
                <div class="control-group">
                    <label for="gc-dist-select-y">Distribution</label>
                    <select id="gc-dist-select-y"></select>
                </div>
                <div id="gc-param-inputs-y"></div>

                <h3>Dependence Structure</h3>
                <div class="control-group">
                    <label for="gc-rho-input">Correlation ρ</label>
                    <div class="slider-group">
                        <input type="range" id="gc-rho-slider" min="-0.99" max="0.99" step="0.01" value="0.5">
                        <input type="number" id="gc-rho-input" min="-0.99" max="0.99" step="0.01" value="0.5" style="width: 80px;">
                    </div>
                </div>
            </div>

            <div id="gc-plots-panel">
                <div id="gc-scatter-plot-container" class="panel gc-plot-container">
                    <h4 style="text-align: center; margin-top: 0;">Samples from Joint Distribution</h4>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <div id="gc-joint-plot-grid">
                        <svg id="gc-marginal-x-svg"></svg>
                        <svg id="gc-joint-plot-svg"></svg>
                        <svg id="gc-marginal-y-svg"></svg>
                    </div>
                    <div class="sample-buttons">
                        <button id="gc-sample-clear-btn">Clear Samples</button>
                        <button id="gc-sample-btn-1">Sample 1</button>
                        <button id="gc-sample-btn-10">Sample 10</button>
                        <button id="gc-sample-btn-100">Sample 100</button>
                        <button id="gc-sample-btn-1000">Sample 1000</button>
                    </div>
                </div>
                <div id="gc-density-plot-container" class="panel gc-plot-container">
                    <h4 id="gc-density-plot-title" style="text-align: center; margin-top: 0;">Conditional Density</h4>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                     <div id="gc-density-controls" style="display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px;">
                        <div class="control-group" style="margin-bottom: 0;">
                            <label for="gc-interval-select">Shade Interval</label>
                            <select id="gc-interval-select">
                                <option value="0">None</option>
                                <option value="p50">50%</option>
                                <option value="p90">90%</option>
                                <option value="p95" selected>95%</option>
                                <option value="p99">99%</option>
                            </select>
                        </div>
                    </div>
                    <div class="gc-conditional-controls-row">
                        <div class="control-group">
                            <label for="gc-cond-var">Condition on variable:</label>
                            <select id="gc-cond-var">
                                <option value="X">X</option>
                                <option value="Y">Y</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="gc-cond-type">Condition type:</label>
                            <select id="gc-cond-type">
                                <option value="eq">equal to</option>
                                <option value="ge">&ge; to</option>
                                <option value="le">&le; to</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="gc-cond-value">Value:</label>
                            <input type="number" id="gc-cond-value" value="0" step="0.1">
                        </div>
                    </div>
                    <div class="plot-svg-wrapper">
                        <svg id="gc-density-plot-svg"></svg>
                    </div>
                    <div id="gc-conditional-mean-display" style="text-align: center; padding: 5px;"></div>
                    <div id="gc-quick-controls-container" class="quick-controls-container">
                        <span>Adjust: </span>
                        <span id="gc-quick-param-buttons" class="quick-param-buttons"></span>
                        <span id="gc-quick-slider-container" class="quick-slider-container"></span>
                    </div>
                    <div id="gc-density-tooltip"></div>
                </div>
            </div>
             <details id="gc-formulas-panel" class="panel">
                <summary>Formulas</summary>
                <div style="padding-top: 1rem;">
                    <p>Let \(u = F_X(x)\), \(v = F_Y(y)\), \(x' = \Phi^{-1}(u)\), and \(y' = \Phi^{-1}(v)\).</p>
                    <h4>Conditional on \(X=x\)</h4>
                    $$ f_{Y|X}(y|x) = \frac{f_Y(y)}{\phi(y')} \frac{1}{\sqrt{1-\rho^2}} \phi\left(\frac{y' - \rho x'}{\sqrt{1-\rho^2}}\right) $$
                    <h4>Conditional on \(X \ge x\)</h4>
                    $$ f_{Y|X \ge x}(y) = \frac{f_Y(y)}{1-u} \left[ 1 - \Phi\left(\frac{x' - \rho y'}{\sqrt{1-\rho^2}}\right) \right] $$
                    <h4>Conditional on \(X \le x\)</h4>
                    $$ f_{Y|X \le x}(y) = \frac{f_Y(y)}{u} \Phi\left(\frac{x' - \rho y'}{\sqrt{1-\rho^2}}\right) $$
                </div>
            </details>
        </div>
        <div id="wiener-process-app" class="app-container">
            <div id="wp-params-panel" class="panel">
                <h3>Process Parameters</h3>
                <p>\( dX_t = m\,dt + \sigma\,dW_t \)</p>
                <div class="control-grid">
                    <div class="control-group">
                        <label for="wp-x0">Start Value \( X_0 \)</label>
                        <div class="slider-group">
                            <input type="range" id="wp-x0-slider" value="0" step="0.1">
                            <input type="number" id="wp-x0" value="0" step="0.1" style="width: 80px;">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="wp-drift">Drift \( m \)</label>
                        <div class="slider-group">
                            <input type="range" id="wp-drift-slider" value="0" step="0.1">
                            <input type="number" id="wp-drift" value="0" step="0.1" style="width: 80px;">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="wp-volatility">Volatility \( \sigma \)</label>
                        <div class="slider-group">
                            <input type="range" id="wp-volatility-slider" value="1" min="0.01" step="0.01">
                            <input type="number" id="wp-volatility" value="1" min="0.01" step="0.01" style="width: 80px;">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="wp-terminal-time">Terminal Time \( T \)</label>
                        <div class="slider-group">
                            <input type="range" id="wp-terminal-time-slider" value="1" min="0.1" step="0.1">
                            <input type="number" id="wp-terminal-time" value="1" min="0.1" step="0.1" style="width: 80px;">
                        </div>
                    </div>
                </div>
            </div>
            <div id="wp-plots-wrapper">
                <div id="wp-paths-panel" class="panel">
                    <h3>Sample Paths of \( X_t \)</h3>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <div class="control-group">
                        <label for="wp-cone-select">Percentile Cone:</label>
                        <select id="wp-cone-select">
                            <option value="0">None</option>
                            <option value="p50">50%</option>
                            <option value="p90">90%</option>
                            <option value="p95" selected>95%</option>
                            <option value="p99">99%</option>
                        </select>
                    </div>
                    <div class="button-flex">
                        <button id="wp-clear-paths-btn">Clear</button>
                        <button id="wp-draw1-btn">Draw 1</button>
                        <button id="wp-draw10-btn">Draw 10</button>
                        <button id="wp-draw100-btn">Draw 100</button>
                    </div>
                    <div class="wp-plot-container" id="wp-paths-plot-grid">
                        <svg id="wp-paths-svg"></svg>
                        <svg id="wp-marginal-svg"></svg>
                    </div>
                    <div id="wp-paths-quick-controls-container" class="quick-controls-container">
                        <span>Adjust: </span>
                        <span id="wp-paths-quick-param-buttons" class="quick-param-buttons"></span>
                        <span id="wp-paths-quick-slider-container" class="quick-slider-container"></span>
                    </div>
                </div>
                <div id="wp-hitting-time-panel" class="panel">
                    <h3>First Hitting Time \( T_b \)</h3>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <div class="control-group">
                        <label for="wp-barrier">Barrier \( b \)</label>
                        <div class="slider-group">
                            <input type="range" id="wp-barrier-slider" value="0.5" step="0.01">
                            <input type="number" id="wp-barrier" value="0.5" step="0.01" style="width: 80px;">
                        </div>
                    </div>
                    <p style="text-align: center;">Density of \( T_b = \inf\{t \ge 0 \mid X_t = b\} \)</p>
                    <div class="wp-plot-container">
                        <svg id="wp-ht-density-svg"></svg>
                        <div id="wp-ht-density-tooltip" class="wp-tooltip"></div>
                    </div>
                    <p style="text-align: center;">Hitting Probability \( \mathbb{P}(T_b \le t) \)</p>
                    <div class="wp-plot-container">
                        <svg id="wp-ht-prob-svg"></svg>
                        <div id="wp-ht-prob-tooltip" class="wp-tooltip"></div>
                    </div>
                    <div id="wp-ht-quick-controls-container" class="quick-controls-container">
                        <span>Adjust: </span>
                        <span id="wp-ht-quick-param-buttons" class="quick-param-buttons"></span>
                        <span id="wp-ht-quick-slider-container" class="quick-slider-container"></span>
                    </div>
                </div>
                <div id="wp-hitting-prob-by-barrier-panel" class="panel">
                    <h3>Hitting Probability by Barrier distance</h3>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <p style="text-align: center;">\( \mathbb{P}(\{X_t = b \text{ for any } 0\le t\le T\}) \) as a function of barrier \(b\)</p>
                    <div class="wp-plot-container">
                        <svg id="wp-hp-by-barrier-svg"></svg>
                        <div id="wp-hp-by-barrier-tooltip" class="wp-tooltip"></div>
                    </div>
                    <div id="wp-hpbb-quick-controls-container" class="quick-controls-container">
                        <span>Adjust: </span>
                        <span id="wp-hpbb-quick-param-buttons" class="quick-param-buttons"></span>
                        <span id="wp-hpbb-quick-slider-container" class="quick-slider-container"></span>
                    </div>
                </div>
            </div>
            <details class="panel">
                <summary>Formulas</summary>
                <div class="formulas" style="padding-top: 1rem;">
                    <h4>Distribution of the process at time \(t\)</h4>
                    <p>The value of the process \(X_t\) at time \(t\) is normally distributed:</p>
                    $$ X_t \sim \mathcal{N}(X_0 + mt, \sigma^2 t) $$

                    <h4>First Hitting Time</h4>
                    <p>Let \(a = b - X_0\) be the distance to the barrier. The first time the process hits the barrier, \(T_b = \inf\{t \ge 0 \mid X_t = b\}\), follows an Inverse-Gaussian distribution with PDF:</p>
                    $$ f_{T_b}(t) = \frac{|a|}{\sigma\sqrt{2\pi t^3}} e^{-\frac{(a-mt)^2}{2\sigma^2 t}} $$

                    <h4>Hitting Probability by time \(T\)</h4>
                    <p>The probability of hitting the barrier \(b\) at or before time \(T\) is:</p>
                    $$ \mathbb{P}(T_b \le T) = \Phi\left(\frac{mT-a}{\sigma\sqrt{T}}\right) + e^{\frac{2ma}{\sigma^2}} \Phi\left(\frac{-mT-a}{\sigma\sqrt{T}}\right) $$
                    <p>where \(a=b-X_0\) and \(\Phi\) is the standard normal CDF. This applies when \(a > 0\). If \(a < 0\), the signs of both \(a\) and \(m\) are flipped.</p>
                </div>
            </details>
        </div>
        <div id="expected-value-app" class="app-container">
            <div class="panel">
                <h3>Expected Value Calculator</h3>
                <p>Enter the probability mass function (PMF) of a discrete random variable.</p>
                <div id="ev-input-grid" class="input-grid">
                    <label>\(\mathbb{P}(X=x)\)</label>
                    <label>\(x\)</label>
                    <span></span> <!-- for alignment -->
                </div>
                <div class="controls">
                    <button id="ev-add-row-btn">+</button>
                    <button id="ev-normalize-btn">Normalize Probabilities</button>
                    <button id="ev-round-btn">Round Probabilities</button>
                    <button id="ev-uniform-btn">Uniform Probabilities</button>
                    <button id="ev-order-btn">Order rows by x</button>
                </div>
                <h4>PMF Plot</h4>
                <div id="ev-plot-container" class="plot-container plot-svg-wrapper">
                    <svg id="ev-plot-svg"></svg>
                </div>
                <div class="control-group" style="margin-top: 1rem; display: flex; align-items: center; gap: 10px;">
                    <label for="ev-overlay-select">Fit Distribution (MLE)</label>
                    <select id="ev-overlay-select">
                        <option value="none">(no overlay)</option>
                        <option value="normal">Normal</option>
                        <option value="exponential">Exponential</option>
                        <option value="lognormal">Lognormal</option>
                        <option value="gamma">Gamma</option>
                        <option value="pareto">Pareto</option>
                    </select>
                    <span id="ev-mle-params"></span>
                </div>
            </div>
        </div>
        <div id="information-value-app" class="app-container">
            <div class="panel">
                <h3>Inputs</h3>
                <p>Define states, actions, prior probabilities, and payoffs to calculate the value of information.</p>
                <div class="controls">
                    <button id="iv-add-state-btn">Add State</button>
                    <button id="iv-add-action-btn">Add Action</button>
                </div>
                <div id="iv-table-container"></div>
            </div>
            <div class="panel">
                <h3>Value of Information</h3>
                <div id="iv-results-grid" class="results-grid"></div>
                <h4>Expected Value of Sample Information (EVSI)</h4>
                <div id="iv-plot-container" class="plot-container plot-svg-wrapper">
                    <svg id="iv-plot-svg"></svg>
                    <div id="iv-tooltip" class="tooltip"></div>
                </div>
            </div>
            <details class="panel">
                <summary>Formulas & Assumptions</summary>
                <div class="formulas" style="padding-top: 1rem;">
                    <h4>Decision Making with (unreliable) information</h4>
                    <p>Assume there are multiple possible states of the world, and multiple actions you can take.</p>
                    <p>For example:
                        <ul>
                            <li>Demand is low/high (unknown, but we have some prior idea), and</li>
                            <li>Actions are invest/not invest (or build/not build).</li>
                            <li>What is the value of reducing the uncertainty about the state of the world?</li>
                            <li>We could fully know the state of the world (“expected value of perfect information”) or have a somewhat unreliable report on the state of the world (“expected value of sample information”).</li>
                        </ul>
                    </p>
                    <h4>Model Definition</h4>
                    <p>This model calculates the value of imperfect information (EVSI) under specific assumptions of uniform accuracy and symmetric error.</p>
                    <p><b>Inputs:</b>
                        <ul>
                            <li><b>States (\(S_i\)):</b> A set of \(n\) mutually exclusive states of nature, \(\{S_1, ..., S_n\}\).</li>
                            <li><b>Actions (\(A_j\)):</b> A set of \(m\) possible actions, \(\{A_1, ..., A_m\}\).</li>
                            <li><b>Priors (\(\pi\)):</b> An \(n \times 1\) vector of prior probabilities, where \(\pi_i = P(S_i)\) and \(\sum \pi_i = 1\).</li>
                            <li><b>Payoffs (\(V\)):</b> An \(m \times n\) matrix where \(V_{ji}\) is the payoff of taking action \(A_j\) if state \(S_i\) occurs.</li>
                            <li><b>Accuracy (\(a\)):</b> A scalar \(a \in (0, 1)\) representing the probability that the information source correctly identifies the true state.</li>
                        </ul>
                    </p>
                    <h4>The Update Steps</h4>
                    <p>The update from prior beliefs (\(\pi_i\)) to posterior beliefs (\(P(S_k|R_j)\)) requires defining the information's reliability and then applying Bayes' theorem.</p>
                    <p><b>1. Construct the Likelihood Matrix (\(L\))</b></p>
                    <p>The \(n \times n\) likelihood matrix \(L\), where \(L_{ij} = P(R_j|S_i)\), formalizes the "uniform accuracy, symmetric error" assumption.
                        <ul>
                            <li>The probability of a correct report is \(P(R_i|S_i) = a\).</li>
                            <li>The probability of an incorrect report is \(1-a\), distributed evenly among the \(n-1\) other possibilities. Thus, \(P(R_j|S_i) = \frac{1-a}{n-1}\) for \(i \neq j\).</li>
                        </ul>
                    </p>
                    <p>Using the Kronecker delta \(\delta_{ij}\), the matrix elements are given by:
                    $$L_{ij} = a \cdot \delta_{ij} + \frac{1-a}{n-1} \cdot (1-\delta_{ij})$$</p>
                    <p><b>2. Calculate the Probability of Each Report (\(P(R_j)\))</b></p>
                    <p>For each possible report \(R_j\) (where \(j=1, ..., n\)), its marginal probability is calculated using the law of total probability, summing over all possible true states:
                    $$P(R_j) = \sum_{i=1}^{n} P(R_j|S_i)P(S_i) = \sum_{i=1}^{n} L_{ij} \pi_i$$</p>
                    <p><b>3. Calculate the Posterior Probabilities (\(P(S_k|R_j)\))</b></p>
                    <p>This is the core update step. Given that the survey has returned report \(R_j\), the updated (posterior) probability of the true state being \(S_k\) is found using Bayes' theorem:
                    $$P(S_k|R_j) = \frac{P(R_j|S_k)P(S_k)}{P(R_j)}$$</p>
                    <p>Substituting the notation from the previous steps, the explicit update formula is:
                    $$P(S_k|R_j) = \frac{L_{kj} \cdot \pi_k}{\sum_{i=1}^{n} L_{ij} \pi_i}$$
                    This calculation is performed for each possible combination of true state \(S_k\) and report \(R_j\).</p>
                    <h4>Using the Updated Probabilities</h4>
                    <p>These posterior probabilities are then used to find the expected value with the information.</p>
                    <ol>
                        <li><b>Expected Value without Information:</b> $$EV_{\text{without}} = \max_{j=1..m} \left( \sum_{i=1}^{n} V_{ji} \pi_i \right)$$</li>
                        <li><b>Expected Value with Information:</b> $$EV_{\text{with}} = \sum_{j=1}^{n} \left[ \max_{l=1..m} \left( \sum_{k=1}^{n} V_{lk} P(S_k|R_j) \right) \right] P(R_j)$$</li>
                        <li><b>EVSI:</b> $$EVSI = EV_{\text{with}} - EV_{\text{without}}$$</li>
                    </ol>
                </div>
            </details>
        </div>
        <div id="about-app" class="app-container">
            <div class="panel">
                <h3>About</h3>
                <p>This is a web app that helps you do quick probability calculations on your phone or computer.</p>
                <h4>What the app can do:</h4>
                <ul>
                    <li>Plot densities of widely used continuous and discrete probability distributions, and compute summary statistics.</li>
                    <li>For any probability density graph, compute the area under the curve as well as conditional expectations (click and move over the density graphs). Useful for e.g. estimating tail probabilities of conditional variables, or for estimating a value given a lower/upper bound.</li>
                    <li>Compute the density of order statistics of i.i.d. variables (for example if you want to know what the 2nd largest of 10 samples is).</li>
                    <li>Plot, generate samples, and compute summary statistics of dependent variables (either continuous, or Bernoulli variables).</li>
                    <li>Compute Brownian Motion sample paths, first hitting time distributions, and hitting probabilities.</li>
                    <li>Given a list of probability/outcome pairs, compute the expected value, and optionally fit a continuous distribution to the data.</li>
                </ul>
                <h4>How it works</h4>
                <p>For all calculations there are either closed form solutions available, or some simple numeric calculations. The app uses <a href="https://ccc-js.github.io/numeric2/">numeric.js</a> and <a href="https://jstat.github.io/">jStat</a> for most calculations. The values you input never leave your device, all computation is done locally.</p>
                <p>The graphs and visualizations are created using <a href="https://d3js.org/">d3.js</a>.</p>
                <p>If you make consequential decisions, don’t solely rely on the answers given here, you should perhaps double check the results with some Python code.</p>
                <h4>Bugs/Contributions</h4>
                <p>The code is available <a href="https://github.com/Feh/probly">on GitHub</a>. You are welcome to open issues there, or better yet, send a pull request. The purpose of the app is to enable quick and easy probability calculations – so I won’t be accepting contributions of the form “enter 20 data points and compute statistic X”, you’d want a proper data science environment for that.</p>
                <h4>Author & License</h4>
                <p>Copyright 2025 Julius Plenz. Published under the <a href="https://opensource.org/license/mit">MIT license</a>.</p>
            </div>
        </div>
        <div id="install-app" class="app-container">
             <h3>Install <em>Probly</em></h3>
             <p>For a better experience, you can install this application on your device. It will work offline and feel like a native app. Click the button below to install.</p>
             <img src="/assets/icon-192x192.png" alt="Probly Logo" style="width: 128px; height: 128px; margin: 1rem auto; display: block;">
             <button id="install-button" style="display: none;">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM12 17l-5-5h3V9h4v3h3l-5 5z"/></svg>
                Install
            </button>
        </div>
    </main>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const bernoulliApp = (() => {
        let state = {};
        const ALL_IDS = [
            'p00', 'p01', 'p10', 'p11', 'pX', 'pX0', 'pY', 'pY0',
            'pY0_X0', 'pY1_X0', 'pY0_X1', 'pY1_X1', 'pX0_Y0', 'pX1_Y0', 'pX0_Y1', 'pX1_Y1', 'rho'
        ];
        const INPUT_IDS = ALL_IDS.filter(id => document.getElementById(id));
        const TOLERANCE = 1e-4;

        const calcFuncs = {
            p01: vars => vars[0], p10: vars => vars[1], p11: vars => vars[2], p00: vars => 1 - vars[0] - vars[1] - vars[2],
            pX:  vars => vars[1] + vars[2], pY:  vars => vars[0] + vars[2], pX0: vars => 1 - (vars[1] + vars[2]), pY0: vars => 1 - (vars[0] + vars[2]),
            rho: vars => {
                const pX = vars[1] + vars[2]; const pY = vars[0] + vars[2]; const p11 = vars[2]; const pX_var = pX * (1 - pX); const pY_var = pY * (1 - pY);
                if (pX_var < TOLERANCE || pY_var < TOLERANCE) return 0;
                return (p11 - pX * pY) / Math.sqrt(pX_var * pY_var);
            },
            pX1_Y1: vars => { const pY = vars[0] + vars[2]; return pY < TOLERANCE ? null : vars[2] / pY; },
            pX0_Y1: vars => { const pY = vars[0] + vars[2]; return pY < TOLERANCE ? null : vars[0] / pY; },
            pX1_Y0: vars => { const pY = vars[0] + vars[2]; return (1 - pY) < TOLERANCE ? null : vars[1] / (1 - pY); },
            pX0_Y0: vars => { const pY = vars[0] + vars[2]; const p00 = 1 - vars[0] - vars[1] - vars[2]; return (1 - pY) < TOLERANCE ? null : p00 / (1 - pY); },
            pY1_X1: vars => { const pX = vars[1] + vars[2]; return pX < TOLERANCE ? null : vars[2] / pX; },
            pY0_X1: vars => { const pX = vars[1] + vars[2]; return pX < TOLERANCE ? null : vars[1] / pX; },
            pY1_X0: vars => { const pX = vars[1] + vars[2]; return (1 - pX) < TOLERANCE ? null : vars[0] / (1 - pX); },
            pY0_X0: vars => { const pX = vars[1] + vars[2]; const p00 = 1 - vars[0] - vars[1] - vars[2]; return (1 - pX) < TOLERANCE ? null : p00 / (1 - pX); }
        };

        function updateURL() {
            const params = new URLSearchParams();
            for (const id in state) {
                if (state[id].isUserInput && state[id].value !== null) {
                    params.set(id, state[id].value);
                }
            }
            params.set('x-name', document.getElementById('x-name').value);
            params.set('y-name', document.getElementById('y-name').value);
            history.replaceState(null, '', '#bernoulli?' + params.toString());
        }

        function updateAndRenderMath() {
            const xName = document.getElementById('x-name').value || 'X';
            const yName = document.getElementById('y-name').value || 'Y';
            document.querySelectorAll('#bernoulli-app [data-katex-template]').forEach(el => {
                el.innerHTML = el.dataset.katexTemplate;
            });
            xmacro = xName.length > 1 ? `\\text{${xName}}` : xName;
            ymacro = yName.length > 1 ? `\\text{${yName}}` : yName;
            renderMathInElement(document.getElementById('bernoulli-app'), {
                delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                macros: { "\\X": xmacro, "\\Y": ymacro }
            });
        }

        function createState() {
            const newState = {};
            INPUT_IDS.forEach(id => { newState[id] = { value: null, isUserInput: false }; });
            return newState;
        }

        function resetState() {
            state = createState();
            document.getElementById('x-name').value = 'X';
            document.getElementById('y-name').value = 'Y';
            updateAndRenderMath();
            render();
            updateURL();
        }

        function handleInput(e) {
            const id = e.target.id;
            const value = e.target.value === '' ? null : parseFloat(e.target.value);
            const userInputs = Object.values(state).filter(s => s.isUserInput);
            if (userInputs.length === 0 && value !== null) {
                state = createState();
            }
            state[id].value = value;
            state[id].isUserInput = (value !== null);
            const complementary = { pX: 'pX0', pX0: 'pX', pY: 'pY0', pY0: 'pY', pY0_X0: 'pY1_X0', pY1_X0: 'pY0_X0', pY0_X1: 'pY1_X1', pY1_X1: 'pY0_X1', pX0_Y0: 'pX1_Y0', pX1_Y0: 'pX0_Y0', pX0_Y1: 'pX1_Y1', pX1_Y1: 'pX0_Y1' };
            if (complementary[id] && value !== null && value >= 0 && value <= 1) {
                const complementId = complementary[id];
                state[complementId].value = 1 - value;
                state[complementId].isUserInput = false;
            }
            calculateAll(id);
            updateURL();
        }

        function calculateAll(activeElementId = null) {
            for (const id in state) { if (!state[id].isUserInput) state[id].value = null; }
            const solution = solve();
            if (solution.success) propagate(solution.vars);
            const validationResult = validate();
            const userInputsCount = Object.values(state).filter(s => s.isUserInput && s.value !== null).length;
            const isError = (!solution.success && userInputsCount >= 3) || (solution.success && validationResult);
            render(isError, activeElementId);
        }

        function solve() {
            const userInputs = Object.entries(state).filter(([, s]) => s.isUserInput && s.value !== null);
            if (userInputs.length !== 3) return { success: false };
            const objectiveFunction = (vars) => {
                let totalError = 0;
                const [p01, p10, p11] = vars;
                const p00 = 1 - p01 - p10 - p11;
                if (p00 < 0) totalError += 1e6 * p00 * p00;
                if (p01 < 0) totalError += 1e6 * p01 * p01;
                if (p10 < 0) totalError += 1e6 * p10 * p10;
                if (p11 < 0) totalError += 1e6 * p11 * p11;
                for (const [id, s] of userInputs) {
                    if (calcFuncs[id]) {
                        const calculatedValue = calcFuncs[id](vars);
                        if (calculatedValue !== null && isFinite(calculatedValue)) totalError += (calculatedValue - s.value)**2;
                    }
                }
                return totalError;
            };
            let result, success = false;
            for (let i = 0; i < 10; i++) {
                result = numeric.uncmin(objectiveFunction, [Math.random(), Math.random(), Math.random()]);
                if (result.f < 1e-6 && Array.isArray(result.solution)) { success = true; break; }
            }
            return { success, vars: result.solution };
        }

        function propagate(vars) {
            const [p01, p10, p11] = vars;
            state.p00.value = 1 - p01 - p10 - p11; state.p01.value = p01; state.p10.value = p10; state.p11.value = p11;
            for (const id in state) {
                if (state[id].value === null && calcFuncs[id]) state[id].value = calcFuncs[id](vars);
            }
        }

        function validate() {
            let hasError = false;
            for (const id in state) {
                const val = state[id].value;
                if (val === null) continue;
                let isFieldInvalid = (id === 'rho') ? (val < -1 - TOLERANCE || val > 1 + TOLERANCE) : (val < 0 - TOLERANCE || val > 1 + TOLERANCE);
                if (isNaN(val)) isFieldInvalid = true;
                if (isFieldInvalid) hasError = true;
            }
            return hasError;
        }

        function render(isError = false, activeElementId = null) {
            const userInputsCount = Object.values(state).filter(s => s.isUserInput && s.value !== null).length;
            const showError = isError && userInputsCount >= 3;
            INPUT_IDS.forEach(id => {
                const el = document.getElementById(id);
                if (id === activeElementId) { el.classList.toggle('error', showError); return; }
                const s = state[id];
                el.value = (s.value !== null && !isNaN(s.value)) ? parseFloat(s.value).toFixed(3) : '';
                el.classList.toggle('user-input', s.isUserInput);
                el.classList.toggle('error', showError);
            });
            renderPlots(state);
        }

        function renderPlots(state) {
            const xName = document.getElementById('x-name').value || 'X'; const yName = document.getElementById('y-name').value || 'Y';
            const container = d3.select("#plots-container"); container.html("");
            const plotData = [
                { id: 'joint', title: 'Joint Probabilities', data: ['p00', 'p01', 'p10', 'p11'] }, { id: 'marginal-x', title: `Marginal P(${xName})`, data: ['pX0', 'pX'] },
                { id: 'marginal-y', title: `Marginal P(${yName})`, data: ['pY0', 'pY'] }, { id: 'cond-y-x0', title: `P(${yName}|${xName}=0)`, data: ['pY0_X0', 'pY1_X0'] },
                { id: 'cond-y-x1', title: `P(${yName}|${xName}=1)`, data: ['pY0_X1', 'pY1_X1'] }, { id: 'cond-x-y0', title: `P(${xName}|${yName}=0)`, data: ['pX0_Y0', 'pX1_Y0'] },
                { id: 'cond-x-y1', title: `P(${xName}|${yName}=1)`, data: ['pX0_Y1', 'pX1_Y1'] }
            ];
            const labelMap = { 'p00': `${xName}=0,${yName}=0`, 'p01': `${xName}=0,${yName}=1`, 'p10': `${xName}=1,${yName}=0`, 'p11': `${xName}=1,${yName}=1`, 'pX0': `${xName}=0`, 'pX': `${xName}=1`, 'pY0': `${yName}=0`, 'pY': `${yName}=1`, 'pY0_X0': `${yName}=0`, 'pY1_X0': `${yName}=1`, 'pY0_X1': `${yName}=0`, 'pY1_X1': `${yName}=1`, 'pX0_Y0': `${xName}=0`, 'pX1_Y0': `${xName}=1`, 'pX0_Y1': `${xName}=0`, 'pX1_Y1': `${xName}=1` };
            if (!Object.values(state).some(s => s.value !== null)) { container.html("(none)"); return; }
            plotData.forEach(plot => {
                const data = plot.data.map(id => ({ id: id, label: labelMap[id] || id, value: state[id].value, isUserInput: state[id].isUserInput })).filter(d => d.value !== null && !isNaN(d.value));
                if (data.length > 0) createBarChart(plot.id, plot.title, data);
            });
            createCorrelationPlot(state);
            function createBarChart(id, title, data) {
                const plotContainer = container.append("div").attr("class", "plot").attr("id", `plot-${id}`);
                plotContainer.append("div").attr("class", "plot-title").text(title);
                const margin = {top: 20, right: 10, bottom: 40, left: 40}, width = 200 - margin.left - margin.right, height = 150 - margin.top - margin.bottom;
                const svg = plotContainer.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleBand().range([0, width]).domain(data.map(d => d.label)).padding(0.2);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x)).selectAll("text").attr("transform", "translate(-10,0)rotate(-45)").style("text-anchor", "end");
                const y = d3.scaleLinear().domain([0, 1]).range([height, 0]);
                svg.append("g").call(d3.axisLeft(y));
                svg.selectAll("rect").data(data).enter().append("rect").attr("x", d => x(d.label)).attr("y", d => y(d.value)).attr("width", x.bandwidth()).attr("height", d => height - y(d.value)).attr("fill", d => d.isUserInput ? "#a1d99b" : "#9ecae1");
                svg.selectAll(".bar-label").data(data).enter().append("text").attr("x", d => x(d.label) + x.bandwidth() / 2).attr("y", d => y(d.value) - 5).attr("text-anchor", "middle").style("font-size", "10px").text(d => d.value.toFixed(3));
            }
            function createCorrelationPlot(state) {
                const jointProbs = [ { x: 0, y: 0, p: state.p00.value, isUserInput: state.p00.isUserInput }, { x: 1, y: 0, p: state.p10.value, isUserInput: state.p10.isUserInput }, { x: 0, y: 1, p: state.p01.value, isUserInput: state.p01.isUserInput }, { x: 1, y: 1, p: state.p11.value, isUserInput: state.p11.isUserInput } ].filter(d => d.p !== null && !isNaN(d.p) && d.p >= 0);
                if (jointProbs.length !== 4) return;
                const plotContainer = d3.select("#plots-container").append("div").attr("class", "plot").attr("id", "plot-correlation");
                plotContainer.append("div").attr("class", "plot-title").text("Joint Distribution & Correlation");
                const margin = { top: 20, right: 20, bottom: 40, left: 40 }, width = 200 - margin.left - margin.right, height = 200 - margin.top - margin.bottom;
                const svg = plotContainer.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleLinear().domain([-0.2, 1.2]).range([0, width]); const y = d3.scaleLinear().domain([-0.2, 1.2]).range([height, 0]);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(1).tickFormat(d3.format("d")));
                svg.append("g").call(d3.axisLeft(y).ticks(1).tickFormat(d3.format("d")));
                const xName = document.getElementById('x-name').value || 'X'; const yName = document.getElementById('y-name').value || 'Y';
                svg.append("text").attr("x", width / 2).attr("y", height + margin.bottom - 5).style("text-anchor", "middle").text(xName);
                svg.append("text").attr("transform", "rotate(-90)").attr("y", 0 - margin.left).attr("x", 0 - (height / 2)).attr("dy", "1em").style("text-anchor", "middle").text(yName);
                const r = d3.scaleSqrt().domain([0, 1]).range([0, 30]);
                svg.selectAll("circle").data(jointProbs).enter().append("circle").attr("cx", d => x(d.x)).attr("cy", d => y(d.y)).attr("r", d => r(d.p)).attr("fill", d => d.isUserInput ? "#a1d99b" : "#9ecae1").attr("opacity", 0.8);
                const pX = state.pX.value, pY = state.pY.value, p11 = state.p11.value; if (pX === null || pY === null || p11 === null) return;
                const pX_var = pX * (1 - pX);
                if (Math.abs(pX_var) > 1e-9) {
                    const cov = p11 - pX * pY, slope = cov / pX_var, intercept = pY - slope * pX;
                    svg.append("line").attr("x1", x(x.domain()[0])).attr("y1", y(intercept + slope * x.domain()[0])).attr("x2", x(x.domain()[1])).attr("y2", y(intercept + slope * x.domain()[1])).attr("stroke", "#d9534f").attr("stroke-width", 2);
                }
            }
        }

        function setupListeners() {
            INPUT_IDS.forEach(id => {
                const el = document.getElementById(id);
                el.addEventListener('input', handleInput);
                el.addEventListener('blur', () => calculateAll());
            });
            document.getElementById('reset-button').addEventListener('click', resetState);
            const nameChangeHandler = () => { updateAndRenderMath(); render(); updateURL(); };
            document.getElementById('x-name').addEventListener('input', nameChangeHandler);
            document.getElementById('y-name').addEventListener('input', nameChangeHandler);
        }

        return {
            init: () => {
                state = createState();
                setupListeners();
                updateAndRenderMath();
                render();
            },
            updateFromURL: (params) => {
                state = createState();
                let inputCount = 0;
                for (const [key, value] of params.entries()) {
                    if (key === 'x-name') { document.getElementById('x-name').value = value; continue; }
                    if (key === 'y-name') { document.getElementById('y-name').value = value; continue; }
                    if (state[key]) {
                        const parsedValue = parseFloat(value);
                        if (!isNaN(parsedValue)) {
                            state[key].value = parsedValue;
                            state[key].isUserInput = true;
                            inputCount++;
                        }
                    }
                }
                updateAndRenderMath();
                if (inputCount > 0) calculateAll(); else render();
            }
        };
    })();

    const discreteInv = (prob, cdf, params) => {
        if (prob <= 0) return params.min !== undefined ? params.min : 0;
        const maxK = params.n !== undefined ? params.n : (params.max !== undefined ? params.max : Math.max(40, params.lambda * 4));
        if (prob >= 1) return maxK;
        let k = params.min !== undefined ? params.min : 0;
        while (cdf(k) < prob) { k++; if (k > maxK * 2) return Infinity; }
        return k;
    };

    const DISTRIBUTIONS = {
        normal: { name: 'Normal', type: 'continuous', params: [{ id: 'mu', name: 'μ (Mean)', default: 0, step: 0.1 }, { id: 'sigma', name: 'σ (Std. Dev)', default: 1, min: 0.1, step: 0.01 }], jStat: p => jStat.normal(p.mu, p.sigma), domain: p => [p.mu - 4 * p.sigma, p.mu + 4 * p.sigma], formula: 'f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}', mean: p => p.mu, variance: p => p.sigma**2, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.normal.sample(p.mu, p.sigma) },
        lognormal: { name: 'Lognormal', type: 'continuous', params: [{ id: 'mu', name: 'μ (log-scale)', default: 0, step: 0.1 }, { id: 'sigma', name: 'σ (shape)', default: 1, min: 0.01, step: 0.01 }], jStat: p => jStat.lognormal(p.mu, p.sigma), domain: (p, j) => [0.001, j.inv(0.995)], formula: 'f(x) = \\frac{1}{x\\sigma\\sqrt{2\\pi}} e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}', mean: p => Math.exp(p.mu + p.sigma**2 / 2), variance: p => (Math.exp(p.sigma**2) - 1) * Math.exp(2 * p.mu + p.sigma**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.lognormal.sample(p.mu, p.sigma) },
        exponential: { name: 'Exponential', type: 'continuous', params: [ { id: 'lambda', name: 'λ (Rate)', default: 1, min: 0.0001, step: 0.0001 } ], jStat: p => jStat.exponential(p.lambda), domain: (p, j) => [0, j.inv(0.999)], formula: 'f(x; \\lambda) = \\lambda e^{-\\lambda x}', mean: p => 1 / p.lambda, variance: p => 1 / (p.lambda**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.exponential.sample(p.lambda) },
        gamma: { name: 'Gamma', type: 'continuous', params: [{ id: 'alpha', name: 'α (Shape)', default: 2, min: 0.001, step: 0.001 }, { id: 'lambda', name: 'λ (Rate)', default: 1, min: 0.001, step: 0.001 }], jStat: p => jStat.gamma(p.alpha, 1/p.lambda), domain: (p, j) => [0.001, j.inv(0.999)], formula: 'f(x; \\alpha,\\lambda) = \\frac{\\lambda^{\\alpha}}{\\Gamma(\\alpha)} x^{\\alpha-1}e^{-\\lambda x}', mean: p => p.alpha / p.lambda, variance: p => p.alpha / (p.lambda**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.gamma.sample(p.alpha, 1/p.lambda) },
        beta: { name: 'Beta', type: 'continuous', params: [{ id: 'alpha', name: 'α (Shape)', default: 2, min: 0.01, step: 0.01 }, { id: 'beta', name: 'β (Shape)', default: 3, min: 0.01, step: 0.01 }], jStat: p => jStat.beta(p.alpha, p.beta), domain: p => [0, 1], formula: 'f(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{\\mathrm{B}(\\alpha, \\beta)}', mean: p => p.alpha / (p.alpha + p.beta), variance: p => (p.alpha * p.beta) / ((p.alpha + p.beta)**2 * (p.alpha + p.beta + 1)), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.beta.sample(p.alpha, p.beta) },
        pareto: { name: 'Pareto', type: 'continuous', params: [{ id: 'xm', name: 'xₘ (scale)', default: 1, min: 0.01, step: 0.01 }, { id: 'alpha', name: 'α (shape)', default: 2, min: 0.01, step: 0.01 }], jStat: p => jStat.pareto(p.xm, p.alpha), domain: (p, j) => [p.xm, j.inv(0.98)], formula: 'f(x) = \\frac{\\alpha x_m^\\alpha}{x^{\\alpha+1}}', mean: p => p.alpha > 1 ? (p.alpha * p.xm) / (p.alpha - 1) : Infinity, variance: p => p.alpha > 2 ? ((p.xm**2 * p.alpha) / ((p.alpha - 1)**2 * (p.alpha - 2))) : Infinity, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: null },
        weibull: { name: 'Weibull', type: 'continuous', params: [{ id: 'scale', name: 'λ (Scale)', default: 1, min: 0.001, step: 0.001 }, { id: 'shape', name: 'k (Shape)', default: 2, min: 0.001, step: 0.001 }], jStat: p => jStat.weibull(p.scale, p.shape), domain: (p, j) => [0.001, j.inv(0.999)], formula: 'f(x; k, \\lambda) = \\frac{k}{\\lambda}\\left(\\frac{x}{\\lambda}\\right)^{k-1}e^{-(x/\\lambda)^k}', mean: p => p.scale * jStat.gammafn(1 + 1 / p.shape), variance: p => p.scale**2 * (jStat.gammafn(1 + 2 / p.shape) - (jStat.gammafn(1 + 1 / p.shape))**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.weibull.sample(p.scale, p.shape) },
        uniform: { name: 'Uniform (continuous)', type: 'continuous', params: [{ id: 'a', name: 'a (Min)', default: 0, step: 0.1 }, { id: 'b', name: 'b (Max)', default: 1, step: 0.1 }], jStat: p => jStat.uniform(p.a, p.b), domain: p => [p.a - (p.b-p.a)*0.1, p.b + (p.b-p.a)*0.1], formula: 'f(x) = \\frac{1}{b-a}', mean: p => (p.a + p.b) / 2, variance: p => (p.b - p.a)**2 / 12, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.uniform.sample(p.a, p.b) },
        discreteUniform: { name: 'Uniform (discrete)', type: 'discrete', params: [{ id: 'min', name: 'Min', default: 0, step: 1 }, { id: 'max', name: 'Max', default: 9, step: 1 }], jStat: p => ({}), domain: p => [p.min - 1, p.max + 1], formula: 'P(X=k) = \\frac{1}{n}', mean: p => (p.min + p.max) / 2, variance: p => ((p.max - p.min + 1)**2 - 1) / 12, pdfpmf: (x, j, p) => { const k = Math.round(x); return k >= p.min && k <= p.max ? 1 / (p.max - p.min + 1) : 0; }, cdf: (x, j, p) => { const k = Math.floor(x); if (k < p.min) return 0; if (k >= p.max) return 1; return (k - p.min + 1) / (p.max - p.min + 1); }, inv: (prob, j, p) => discreteInv(prob, (k) => DISTRIBUTIONS.discreteUniform.cdf(k, j, p), p), sampler: p => Math.floor(jStat.uniform.sample(p.min, p.max + 1)) },
        binomial: { name: 'Binomial', type: 'discrete', params: [{ id: 'n', name: 'n (Trials)', default: 20, min: 1, step: 1 }, { id: 'p', name: 'p (Probability)', default: 0.5, min: 0, max: 1, step: 0.01 }], jStat: p => ({}), domain: p => [-0.5, p.n + 0.5], formula: 'P(k; n,p) = \\binom{n}{k} p^k(1-p)^{n-k}', mean: p => p.n * p.p, variance: p => p.n * p.p * (1 - p.p), pdfpmf: (x, j, p) => jStat.binomial.pdf(Math.round(x), p.n, p.p), cdf: (x, j, p) => jStat.binomial.cdf(Math.round(x), p.n, p.p), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.binomial.cdf(k, p.n, p.p), p), sampler: null },
        negativeBinomial: { name: 'Negative Binomial', type: 'discrete', params: [{ id: 'r', name: 'r (Successes)', default: 10, min: 1, step: 1 }, { id: 'p', name: 'p (Probability)', default: 0.5, min: 0.01, max: 1, step: 0.01 }], jStat: p => ({}), domain: (p, j) => [-0.5, discreteInv(0.9999, (k) => jStat.negbin.cdf(k, p.r, p.p), { ...p, min: 0 })], formula: 'P(k; r,p) = \\binom{k+r-1}{k} p^r(1-p)^{k}', mean: p => p.r * (1 - p.p) / p.p, variance: p => p.r * (1 - p.p) / (p.p**2), pdfpmf: (x, j, p) => jStat.negbin.pdf(Math.round(x), p.r, p.p), cdf: (x, j, p) => jStat.negbin.cdf(Math.round(x), p.r, p.p), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.negbin.cdf(k, p.r, p.p), { ...p, min: 0 }), sampler: null },
        hypergeometric: { name: 'Hypergeometric', type: 'discrete', params: [{ id: 'N', name: 'N (Population)', default: 50, min: 1, step: 1 }, { id: 'K', name: 'K (Successes in Pop.)', default: 10, min: 0, step: 1 }, { id: 'n', name: 'n (Sample Size)', default: 20, min: 1, step: 1 }], jStat: p => ({}), domain: p => [Math.max(0, p.n - p.N + p.K) - 1, Math.min(p.n, p.K) + 1], formula: 'P(X=k) = \\frac{\\binom{K}{k}\\binom{N-K}{n-k}}{\\binom{N}{n}}', mean: p => p.n * p.K / p.N, variance: p => p.n * (p.K / p.N) * (1 - p.K / p.N) * ((p.N - p.n) / (p.N - 1)), pdfpmf: (x, j, p) => jStat.hypgeom.pdf(Math.round(x), p.N, p.K, p.n), cdf: (x, j, p) => jStat.hypgeom.cdf(Math.round(x), p.N, p.K, p.n), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.hypgeom.cdf(k, p.N, p.K, p.n), { ...p, min: Math.max(0, p.n - (p.N - p.K)) }), sampler: null },
        poisson: { name: 'Poisson', type: 'discrete', params: [ { id: 'lambda', name: 'λ (Mean)', default: 5, min: 0.01, step: 0.01 } ], jStat: p => jStat.poisson(p.lambda), domain: (p, j) => [-0.5, Math.max(20, discreteInv(0.9999, (k) => jStat.poisson.cdf(k, p.lambda), p))], formula: 'P(k; \\lambda) = \\frac{\\lambda^k e^{-\\lambda}}{k!}', mean: p => p.lambda, variance: p => p.lambda, pdfpmf: (x, j, p) => jStat.poisson.pdf(Math.round(x), p.lambda), cdf: (x, j, p) => jStat.poisson.cdf(Math.round(x), p.lambda), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.poisson.cdf(k, p.lambda), p), sampler: p => jStat.poisson.sample(p.lambda) }
    };

    const distributionsApp = (() => {

        const integrate = (f, a, b, n_steps = 1000) => {
            if (a >= b) return 0;
            if (!isFinite(a) || !isFinite(b)) return NaN;
            n_steps = n_steps % 2 === 0 ? n_steps : n_steps + 1;
            let h = (b - a) / n_steps;
            if (h === 0) return 0;
            let sum = f(a) + f(b);
            for (let i = 1; i < n_steps; i += 2) {
                sum += 4 * f(a + i * h);
            }
            for (let i = 2; i < n_steps - 1; i += 2) {
                sum += 2 * f(a + i * h);
            }
            return sum * h / 3;
        };

        const distSelect = document.getElementById('dist-select');
        const paramInputs = document.getElementById('param-inputs');
        const paramSliders = document.getElementById('param-sliders');
        const formulaDisplay = document.getElementById('formula-display');
        const intervalSelect = document.getElementById('interval-select');
        const samplesOutput = document.getElementById('samples-output');
        const tooltip = document.getElementById('tooltip');
        const sampleBtn1 = document.getElementById('sample-btn-1');
        const sampleBtn10 = document.getElementById('sample-btn-10');
        let currentState = { distKey: 'normal', params: {}, jstat: null, samples: [] };
        const svg = d3.select("#plot-svg");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        const xScale = d3.scaleLinear(), yScale = d3.scaleLinear();
        const xAxis = svg.append("g").attr("class", "x-axis axis");
        const yAxis = svg.append("g").attr("class", "y-axis axis");
        const plotArea = svg.append("g").attr("class", "plot-area");
        const dragLayer = svg.append("g").attr("class", "drag-layer");

        function showQuickSlider(paramId) {
            const quickSliderContainer = document.getElementById('quick-slider-container');
            quickSliderContainer.innerHTML = '';

            const config = DISTRIBUTIONS[currentState.distKey];
            const p = config.params.find(param => param.id === paramId);
            if (!p) return;

            const mainNumberInput = document.getElementById(`param-${p.id}`);
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.style.width = '100%';

            const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

            const updateSliderBounds = () => {
                const value = parseFloat(mainNumberInput.value);
                if (isNaN(value) || !mainNumberInput.checkValidity()) return;
                let sliderMin, sliderMax;
                if (value === 0) { sliderMin = -1; sliderMax = 1; } else {
                    const logVal = Math.log10(Math.abs(value));
                    sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1);
                    sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1);
                    if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin];
                }
                const finalMin = Math.max(p.min ?? -Infinity, sliderMin);
                const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                slider.min = finalMin;
                slider.max = finalMax;
                if (p.step % 1 === 0) {
                    slider.step = 1;
                    slider.min = Math.ceil(finalMin);
                    slider.max = Math.floor(finalMax);
                } else {
                    slider.step = (finalMax - finalMin) / 200;
                }
            };

            updateSliderBounds();
            slider.value = mainNumberInput.value;

            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                mainNumberInput.value = val.toFixed(precision);
                const mainSliderInput = document.getElementById(`slider-${p.id}`);
                if(mainSliderInput) mainSliderInput.value = val;
                update();
            });

            slider.addEventListener('change', updateSliderBounds);
            quickSliderContainer.appendChild(slider);
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('dist', currentState.distKey);
            for(const p of DISTRIBUTIONS[currentState.distKey].params) {
                params.set(p.id, currentState.params[p.id]);
            }
            history.replaceState(null, '', '#distributions?' + params.toString());
        }

        function handleDistChange(options = {}) {
            currentState.distKey = distSelect.value;
            const config = DISTRIBUTIONS[currentState.distKey];
            paramInputs.innerHTML = '';

            const quickParamButtons = document.getElementById('quick-param-buttons');
            quickParamButtons.innerHTML = '';
            document.getElementById('quick-slider-container').innerHTML = '';

            config.params.forEach(p => {
                const btn = document.createElement('button');
                btn.id = `quick-btn-${p.id}`;
                btn.innerHTML = p.name.split(' ')[0];
                btn.dataset.param = p.id;
                quickParamButtons.appendChild(btn);

                const group = document.createElement('div');
                group.className = 'param-group';
                group.innerHTML = `<label for="param-${p.id}">${p.name}</label>
                    <div class="slider-group">
                        <input type="range" id="slider-${p.id}" value="${p.default}">
                        <input type="number" id="param-${p.id}" data-param="${p.id}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}" style="width: 80px;">
                    </div>`;
                paramInputs.appendChild(group);

                const numberInput = document.getElementById(`param-${p.id}`);
                const sliderInput = document.getElementById(`slider-${p.id}`);
                const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();
                const updateSliderBounds = () => {
                    const value = parseFloat(numberInput.value); if (isNaN(value) || !numberInput.checkValidity()) return;
                    let sliderMin, sliderMax;
                    if (value === 0) { sliderMin = -1; sliderMax = 1; } else { const logVal = Math.log10(Math.abs(value)); sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1); sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1); if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin]; }
                    const finalMin = Math.max(p.min ?? -Infinity, sliderMin); const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                    sliderInput.min = finalMin; sliderInput.max = finalMax;
                    if (p.step % 1 === 0) { sliderInput.step = 1; sliderInput.min = Math.ceil(finalMin); sliderInput.max = Math.floor(finalMax); } else { sliderInput.step = (finalMax - finalMin) / 200; }
                };
                numberInput.addEventListener('input', () => { const val = parseFloat(numberInput.value); if (!isNaN(val)) { sliderInput.value = val; } });
                numberInput.addEventListener('change', updateSliderBounds);
                sliderInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); numberInput.value = val.toFixed(precision); update(); });
                sliderInput.addEventListener('change', updateSliderBounds);
                updateSliderBounds(); sliderInput.value = numberInput.value;
            });
            katex.render(config.formula, formulaDisplay, { throwOnError: false, displayMode: true });
            update(options);
        }

        function generateSamples(count) {
            const sampler = DISTRIBUTIONS[currentState.distKey].sampler;
            if (!sampler) { samplesOutput.innerHTML = 'Sampling not supported.'; return; }
            const newSamples = Array.from({ length: count }, () => sampler(currentState.params));
            currentState.samples.push(...newSamples);
            const formattedSamples = newSamples.map(s => Number.isInteger(s) ? s : s.toFixed(4)).join('\n');
            if (samplesOutput.innerHTML.includes('not supported')) samplesOutput.innerHTML = '';
            samplesOutput.innerHTML += (samplesOutput.innerHTML ? '\n' : '') + formattedSamples;
            samplesOutput.scrollTop = samplesOutput.scrollHeight;
            updatePlot();
        }

        function update(options = {}) {
            const config = DISTRIBUTIONS[currentState.distKey]; const params = {}; let allValid = true;
            config.params.forEach(p => {
                const input = document.getElementById(`param-${p.id}`);
                if (input.checkValidity()){
                    const val = parseFloat(input.value);
                    params[p.id] = val;
                    const btn = document.getElementById(`quick-btn-${p.id}`);
                    if (btn) {
                        const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();
                        btn.innerHTML = `${p.name.split(' ')[0]} = ${val.toFixed(precision)}`;
                    }
                } else {
                    allValid = false;
                }
            });
            if (!allValid) return;
            currentState.params = params; currentState.jstat = config.jStat(params);
            const sampler = config.sampler; sampleBtn1.disabled = !sampler; sampleBtn10.disabled = !sampler;
            updateStats(); updatePlot();
            if (!options.fromURL) updateURL();
        }

        function updateStats() {
            const config = DISTRIBUTIONS[currentState.distKey]; if (!currentState.jstat) return;
            const quantile = (prob) => config.inv(prob, currentState.jstat, currentState.params);
            const mean = config.mean(currentState.params); const variance = config.variance(currentState.params);
            document.getElementById('stat-mean').textContent = isFinite(mean) ? mean.toFixed(4) : '∞';
            document.getElementById('stat-variance').textContent = isFinite(variance) ? variance.toFixed(4) : '∞';
            document.getElementById('stat-stddev').textContent = isFinite(variance) ? Math.sqrt(variance).toFixed(4) : '∞';
            document.getElementById('stat-q1').textContent = quantile(0.25).toFixed(4);
            document.getElementById('stat-median').textContent = quantile(0.5).toFixed(4);
            document.getElementById('stat-q3').textContent = quantile(0.75).toFixed(4);
            const intervals = { '50': [quantile(0.25), quantile(0.75)], '90': [quantile(0.05), quantile(0.95)], '95': [quantile(0.025), quantile(0.975)], '99': [quantile(0.005), quantile(0.995)] };
            Object.entries(intervals).forEach(([key, val]) => { document.getElementById(`stat-int${key}`).textContent = `[${val[0].toFixed(2)}, ${val[1].toFixed(2)}]`; });
        }

        function updatePlot() {
            const config = DISTRIBUTIONS[currentState.distKey]; const j = currentState.jstat; if (!j) return;
            document.getElementById('shading-controls').style.display = config.type === 'discrete' ? 'none' : 'flex';
            const svgRect = svg.node().getBoundingClientRect(); width = svgRect.width - margin.left - margin.right; height = svgRect.height - margin.top - margin.bottom;
            plotArea.attr("transform", `translate(${margin.left},${margin.top})`); dragLayer.attr("transform", `translate(${margin.left},${margin.top})`);
            const xDomain = config.domain(currentState.params, j); xScale.domain(xDomain).range([0, width]);
            xAxis.attr("transform", `translate(${margin.left}, ${height + margin.top})`).call(d3.axisBottom(xScale));
            let plotData, yMax;
            if (config.type === 'continuous') { plotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 500).map(x => ({ x: x, y: config.pdfpmf(x, j, currentState.params) })); yMax = d3.max(plotData, d => d.y); }
            else { plotData = d3.range(Math.floor(xDomain[0]), Math.ceil(xDomain[1])).map(x => ({ x: x, y: config.pdfpmf(x, j, currentState.params) })); yMax = d3.max(plotData, d => d.y); }
            yScale.domain([0, yMax * 1.1]).range([height, 0]); yAxis.attr("transform", `translate(${margin.left}, ${margin.top})`).call(d3.axisLeft(yScale).ticks(5));
            plotArea.selectAll("*").remove(); dragLayer.selectAll("*").remove();
            document.getElementById('conditional-expectations-grid').innerHTML = '';
            const intervalValue = intervalSelect.value;
            if (config.type === 'continuous' && intervalValue !== '0') {
                const quantile = (prob) => config.inv(prob, j, currentState.params); let lower, upper;
                if (intervalValue.startsWith('p')) { const p = parseFloat(intervalValue.substring(1)) / 100; lower = quantile((1 - p) / 2); upper = quantile(1 - (1 - p) / 2); }
                else { const numSigmas = parseInt(intervalValue.substring(1)); const mean = config.mean(currentState.params); const stddev = Math.sqrt(config.variance(currentState.params)); if(isFinite(stddev)) { lower = mean - numSigmas * stddev; upper = mean + numSigmas * stddev; } }
                if (lower !== undefined) { const area = d3.area().x(d => xScale(d.x)).y0(height).y1(d => yScale(d.y)); plotArea.append("path").datum(plotData.filter(d => d.x >= lower && d.x <= upper)).attr("class", "area-path").attr("d", area); }
            }
            if (config.type === 'continuous') { plotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y))); }
            else { plotArea.selectAll(".bar-main").data(plotData.filter(d => d.y > 0)).enter().append("rect").attr("class", "bar").attr("x", d => xScale(d.x - 0.4)).attr("y", d => yScale(d.y)).attr("width", Math.max(1, xScale(0.8) - xScale(0))).attr("height", d => height - yScale(d.y)); }
            plotArea.selectAll(".sample-dot").data(currentState.samples).enter().append("circle").attr("class", "sample-dot").attr("cx", d => xScale(d)).attr("cy", height).attr("r", 3).attr("fill", "black");
            setupInteractionLayer();
        }

        function calculateAndDisplayConditionalExpectations(lower, upper) {
            const grid = document.getElementById('conditional-expectations-grid');
            const config = DISTRIBUTIONS[currentState.distKey];
            
            const { jstat, params } = currentState;
            const cdf = x => config.cdf(x, jstat, params);
            const xDomain = config.domain(params, jstat);
            
            let E_lower, E_middle, E_upper;

            if (config.type === 'continuous') {
                const pdf = x => config.pdfpmf(x, jstat, params);
                const domain_min = xDomain[0];
                const domain_max = xDomain[1];
                const prob_lower = cdf(lower) - cdf(domain_min);
                const prob_middle = cdf(upper) - cdf(lower);
                const prob_upper = cdf(domain_max) - cdf(upper);

                if (currentState.distKey === 'normal') {
                    const mu = params.mu;
                    const sigma = params.sigma;
                    const variance = sigma * sigma;
                    if (prob_lower > 1e-9) E_lower = mu - variance * pdf(lower) / prob_lower;
                    if (prob_middle > 1e-9) E_middle = mu - variance * (pdf(upper) - pdf(lower)) / prob_middle;
                    if (prob_upper > 1e-9) E_upper = mu + variance * pdf(upper) / prob_upper;
                } else {
                    const integrand = x => x * pdf(x);
                    if (prob_lower > 1e-9) {
                        const integral = integrate(integrand, domain_min, lower);
                        E_lower = integral / prob_lower;
                    }
                    if (prob_middle > 1e-9) {
                        const integral = integrate(integrand, lower, upper);
                        E_middle = integral / prob_middle;
                    }
                    if (prob_upper > 1e-9) {
                        const integral = integrate(integrand, upper, domain_max);
                        E_upper = integral / prob_upper;
                    }
                }
            } else { // Discrete
                const lowerBound = Math.ceil(lower);
                const upperBound = Math.floor(upper);
                
                const pmf = x => config.pdfpmf(x, jstat, params);
                const domain_min_k = Math.ceil(xDomain[0]);
                const domain_max_k = Math.floor(xDomain[1]);

                let sum_lower = 0, prob_lower = 0;
                for (let k = domain_min_k; k < lowerBound; k++) {
                    const p = pmf(k);
                    if (p > 0) {
                        prob_lower += p;
                        sum_lower += k * p;
                    }
                }

                let sum_middle = 0, prob_middle = 0;
                for (let k = lowerBound; k <= upperBound; k++) {
                     const p = pmf(k);
                    if (p > 0) {
                        prob_middle += p;
                        sum_middle += k * p;
                    }
                }

                let sum_upper = 0, prob_upper = 0;
                for (let k = upperBound + 1; k <= domain_max_k; k++) {
                     const p = pmf(k);
                    if (p > 0) {
                        prob_upper += p;
                        sum_upper += k * p;
                    }
                }

                if (prob_lower > 1e-9) E_lower = sum_lower / prob_lower;
                if (prob_middle > 1e-9) E_middle = sum_middle / prob_middle;
                if (prob_upper > 1e-9) E_upper = sum_upper / prob_upper;
            }
            
            const format = val => (val === undefined || !isFinite(val)) ? '\\text{N/A}' : val.toFixed(4);

            grid.innerHTML = `
                <div>\\(\\mathbb{E}[X \\mid X < ${lower.toFixed(2)}] = ${format(E_lower)}\\)</div>
                <div>\\(\\mathbb{E}[X \\mid ${lower.toFixed(2)} \\le X \\le ${upper.toFixed(2)}] = ${format(E_middle)}\\)</div>
                <div>\\(\\mathbb{E}[X \\mid X > ${upper.toFixed(2)}] = ${format(E_upper)}\\)</div>
            `;
            renderMathInElement(grid);
        }

        function setupInteractionLayer() {
            const config = DISTRIBUTIONS[currentState.distKey]; const focus = plotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            let dragState = { startX: null, isDragging: false }; let touchDragState = {};
            const interactionRect = svg.append("rect").attr("transform", `translate(${margin.left},${margin.top})`).style("fill", "none").style("pointer-events", "all").style("touch-action", "none").attr("width", width).attr("height", height);
            function calculateAndDisplayArea(pixel1, pixel2) {
                if (Math.abs(pixel1 - pixel2) < 5) {
                    dragLayer.selectAll("*").remove();
                    document.getElementById('conditional-expectations-grid').innerHTML = '';
                    return;
                }
                const x0 = xScale.invert(pixel1), x1 = xScale.invert(pixel2); const lower = Math.min(x0, x1), upper = Math.max(x0, x1); let area, text;
                if (config.type === 'discrete') {
                    const lowerBound = Math.ceil(lower), upperBound = Math.floor(upper);
                    area = (upperBound < lowerBound) ? 0 : config.cdf(upperBound, currentState.jstat, currentState.params) - config.cdf(lowerBound - 1, currentState.jstat, currentState.params);
                    text = `P(${lowerBound} ≤ X ≤ ${upperBound}) = ${area.toFixed(4)}`;
                    calculateAndDisplayConditionalExpectations(lower, upper);
                }
                else {
                    area = config.cdf(upper, currentState.jstat, currentState.params) - config.cdf(lower, currentState.jstat, currentState.params);
                    text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`;
                    calculateAndDisplayConditionalExpectations(lower, upper);
                }
                dragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
            }
            const drag = d3.drag().filter(event => !event.touches).on("start", (event) => { const [x_coord] = d3.pointer(event, interactionRect.node()); dragState.isDragging = true; dragState.startX = x_coord; dragLayer.selectAll("*").remove(); document.getElementById('conditional-expectations-grid').innerHTML = ''; dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; }).on("drag", (event) => { const [currentX] = d3.pointer(event, interactionRect.node()); const x = Math.min(dragState.startX, currentX), w = Math.abs(currentX - dragState.startX); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }).on("end", (event) => { dragState.isDragging = false; const [endX, endY] = d3.pointer(event, interactionRect.node()); if (endX >= 0 && endX <= width && endY >= 0 && endY <= height) { tooltip.style.opacity = 1; } calculateAndDisplayArea(dragState.startX, endX); });
            interactionRect.call(drag);
            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, document.getElementById('plot-container')); tooltip.style.left = tipX + "px"; tooltip.style.top = tipY + "px";
                const [x_coord] = d3.pointer(event, interactionRect.node()); const x_val = xScale.invert(x_coord); let y_val, display_x = x_val;
                if (config.type === 'continuous') { y_val = config.pdfpmf(x_val, currentState.jstat, currentState.params); } else { display_x = Math.round(x_val); y_val = config.pdfpmf(display_x, currentState.jstat, currentState.params); }
                focus.attr("cx", xScale(display_x)).attr("cy", yScale(y_val)); tooltip.innerHTML = `x: ${display_x.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }
            interactionRect.on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); tooltip.style.opacity = 1; }}).on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); tooltip.style.opacity = 0; }}).on("mousemove", (event) => { if (dragState.isDragging) return; updateTooltip(event); });
            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 2) { event.preventDefault(); touchDragState.isDragging = true; const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; dragLayer.selectAll("*").remove(); document.getElementById('conditional-expectations-grid').innerHTML = ''; dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; focus.style.opacity = 0; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1) { event.preventDefault(); dragLayer.selectAll("*").remove(); document.getElementById('conditional-expectations-grid').innerHTML = ''; updateTooltip(event.touches[0]); focus.style.opacity = 1; tooltip.style.opacity = 1; }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2 && touchDragState.isDragging) { event.preventDefault(); const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1 && !touchDragState.isDragging) { event.preventDefault(); updateTooltip(event.touches[0]); }
            });
            node.addEventListener('touchend', (event) => {
                if (touchDragState.isDragging) { event.preventDefault(); calculateAndDisplayArea(touchDragState.x1, touchDragState.x2); touchDragState = {}; }
                if (event.touches.length === 0) { focus.style.opacity = 0; tooltip.style.opacity = 0; }
            });
        }

        return {
            init: () => {
                Object.keys(DISTRIBUTIONS).forEach(key => distSelect.appendChild(new Option(DISTRIBUTIONS[key].name, key)));
                distSelect.addEventListener('change', () => handleDistChange());
                paramInputs.addEventListener('input', () => update());
                document.getElementById('quick-param-buttons').addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        showQuickSlider(e.target.dataset.param);
                    }
                });
                document.addEventListener('click', (e) => {
                    const quickControlsContainer = document.getElementById('quick-controls-container');
                    if (quickControlsContainer && !quickControlsContainer.contains(e.target)) {
                        const quickSliderContainer = document.getElementById('quick-slider-container');
                        if (quickSliderContainer) quickSliderContainer.innerHTML = '';
                    }
                });
                intervalSelect.addEventListener('change', () => update());
                sampleBtn1.addEventListener('click', () => generateSamples(1));
                sampleBtn10.addEventListener('click', () => generateSamples(10));
                document.getElementById('sample-clear-btn').addEventListener('click', () => { samplesOutput.innerHTML = ''; currentState.samples = []; if (currentState.jstat) updatePlot(); });
                window.addEventListener('resize', () => { if (currentState.jstat) updatePlot(); });
                const resizeObserver = new ResizeObserver(() => {
                    if (currentState.jstat) setTimeout(updatePlot, 0);
                });
                resizeObserver.observe(document.querySelector('#distributions-app .plot-svg-wrapper'));
                handleDistChange();
            },
            updateFromURL: (params) => {
                const dist = params.get('dist');
                if (dist && DISTRIBUTIONS[dist]) {
                    distSelect.value = dist;
                    handleDistChange({ fromURL: true });
                    const config = DISTRIBUTIONS[dist];
                    config.params.forEach(p => {
                        if (params.has(p.id)) {
                            const val = params.get(p.id);
                            const inputEl = document.getElementById(`param-${p.id}`);
                            if (inputEl) {
                                inputEl.value = val;
                                inputEl.dispatchEvent(new Event('change'));
                                inputEl.dispatchEvent(new Event('input'));
                            }
                        }
                    });
                    update({ fromURL: true });
                    updateURL();
                } else {
                    handleDistChange();
                }
            }
        };
    })();

    const CONTINUOUS_DISTRIBUTIONS = {
        uniform: DISTRIBUTIONS.uniform,
        normal: DISTRIBUTIONS.normal,
        exponential: DISTRIBUTIONS.exponential,
        gamma: DISTRIBUTIONS.gamma,
        beta: DISTRIBUTIONS.beta,
        pareto: DISTRIBUTIONS.pareto,
        lognormal: DISTRIBUTIONS.lognormal,
        weibull: DISTRIBUTIONS.weibull,
    };

    const orderStatisticsApp = (() => {
        const distSelect = document.getElementById('os-dist-select');
        const paramInputs = document.getElementById('os-param-inputs');
        const intervalSelect = document.getElementById('os-interval-select');
        const nInput = document.getElementById('os-n');
        const kInput = document.getElementById('os-k');

        let currentState = { distKey: 'uniform', params: {}, n: 10, k: 5, jstat: null, mean: null, variance: null };
        const svg = d3.select("#os-plot-svg");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        const xScale = d3.scaleLinear(), yScale = d3.scaleLinear();
        const xAxis = svg.append("g").attr("class", "x-axis axis");
        const yAxis = svg.append("g").attr("class", "y-axis axis");
        const plotArea = svg.append("g").attr("class", "plot-area");
        const dragLayer = svg.append("g").attr("class", "drag-layer");
        const tooltip = document.getElementById('os-tooltip');

        function showQuickSlider(paramId) {
            const quickSliderContainer = document.getElementById('os-quick-slider-container');
            quickSliderContainer.innerHTML = '';

            const config = CONTINUOUS_DISTRIBUTIONS[currentState.distKey];
            let p = config.params.find(param => param.id === paramId);

            let mainNumberInput;
            if (p) { // It's a distribution parameter
                mainNumberInput = document.getElementById(`os-param-${p.id}`);
            } else { // It must be n or k
                if (paramId === 'n') {
                    p = { id: 'n', step: 1, min: 1 };
                    mainNumberInput = document.getElementById('os-n');
                } else if (paramId === 'k') {
                    p = { id: 'k', step: 1, min: 1, max: currentState.n };
                    mainNumberInput = document.getElementById('os-k');
                } else {
                    return;
                }
            }

            if (!p || !mainNumberInput) return;

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.style.width = '100%';

            const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

            const updateSliderBounds = () => {
                const value = parseFloat(mainNumberInput.value);
                if (isNaN(value) || !mainNumberInput.checkValidity()) return;
                let sliderMin, sliderMax;
                if (value === 0) { sliderMin = -1; sliderMax = 1; } else {
                    const logVal = Math.log10(Math.abs(value));
                    sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1);
                    sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1);
                    if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin];
                }
                const finalMin = Math.max(p.min ?? -Infinity, sliderMin);
                const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                slider.min = finalMin;
                slider.max = finalMax;
                if (p.step % 1 === 0) {
                    slider.step = 1;
                    slider.min = Math.ceil(finalMin);
                    slider.max = Math.floor(finalMax);
                } else {
                    slider.step = (finalMax - finalMin) / 200;
                }
            };

            updateSliderBounds();
            slider.value = mainNumberInput.value;

            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                mainNumberInput.value = val.toFixed(precision);
                let mainSliderInput;
                if (paramId === 'n') mainSliderInput = document.getElementById('os-n-slider');
                else if (paramId === 'k') mainSliderInput = document.getElementById('os-k-slider');
                else mainSliderInput = document.getElementById(`os-slider-${p.id}`);

                if(mainSliderInput) mainSliderInput.value = val;
                update();
            });

            slider.addEventListener('change', updateSliderBounds);
            quickSliderContainer.appendChild(slider);
        }

        function orderStatPDF(x, distConfig, params, n, k, j) {
            if (k > n || k < 1 || !isFinite(x)) return 0;
            const fx = distConfig.pdfpmf(x, j, params);
            const Fx = distConfig.cdf(x, j, params);
            if (fx <= 0 || Fx <= 0 || Fx >= 1) return 0;
            const logTerm = (k - 1) * Math.log(Fx) + (n - k) * Math.log(1 - Fx);
            const logBeta = jStat.gammaln(k) + jStat.gammaln(n - k + 1) - jStat.gammaln(n + 1);
            const logPDF = -logBeta + Math.log(fx) + logTerm;
            return Math.exp(logPDF);
        }

        function orderStatInv(p, distConfig, params, n, k, j) {
            const u = jStat.beta.inv(p, k, n - k + 1);
            return distConfig.inv(u, j, params);
        }

        function integrate(f, a, b, n_steps) {
            if (a >= b) return 0;
            n_steps = n_steps % 2 === 0 ? n_steps : n_steps + 1;
            let h = (b - a) / n_steps;
            let sum = f(a) + f(b);
            for (let i = 1; i < n_steps; i += 2) {
                sum += 4 * f(a + i * h);
            }
            for (let i = 2; i < n_steps - 1; i += 2) {
                sum += 2 * f(a + i * h);
            }
            return sum * h / 3;
        }

        function update() {
            const distKey = distSelect.value;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            const params = {};
            let allValid = true;
            config.params.forEach(p => {
                const input = document.getElementById(`os-param-${p.id}`);
                if (input.checkValidity()) {
                    params[p.id] = parseFloat(input.value);
                } else {
                    allValid = false;
                }
            });
            const n = parseInt(nInput.value);
            const k = parseInt(kInput.value);
            if (!allValid || isNaN(n) || isNaN(k) || k > n || k < 1) return;

            config.params.forEach(p => {
                const btn = document.getElementById(`os-quick-btn-${p.id}`);
                if (btn) {
                    const val = params[p.id];
                    const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();
                    btn.innerHTML = `${p.name.split(' ')[0]} = ${val.toFixed(precision)}`;
                }
            });
            const btnN = document.getElementById('os-quick-btn-n');
            if (btnN) btnN.innerHTML = `Sample size = ${n}`;
            const btnK = document.getElementById('os-quick-btn-k');
            if (btnK) btnK.innerHTML = `k-th = ${k}`;

            currentState = { distKey, params, n, k, jstat: config.jStat(params) };
            updateStats();
            updatePlot();
            updateURL();
        }

        function handleDistChange() {
            currentState.distKey = distSelect.value;
            const config = CONTINUOUS_DISTRIBUTIONS[currentState.distKey];
            paramInputs.innerHTML = '';

            const quickParamButtons = document.getElementById('os-quick-param-buttons');
            quickParamButtons.innerHTML = '';
            document.getElementById('os-quick-slider-container').innerHTML = '';

            config.params.forEach(p => {
                const btn = document.createElement('button');
                btn.id = `os-quick-btn-${p.id}`;
                btn.innerHTML = p.name.split(' ')[0];
                btn.dataset.param = p.id;
                quickParamButtons.appendChild(btn);

                const group = document.createElement('div');
                group.className = 'param-group';
                group.innerHTML = `<label for="os-param-${p.id}">${p.name}</label>
                    <div class="slider-group">
                        <input type="range" id="os-slider-${p.id}" value="${p.default}">
                        <input type="number" id="os-param-${p.id}" data-param="${p.id}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}" style="width: 80px;">
                    </div>`;
                paramInputs.appendChild(group);

                const numberInput = document.getElementById(`os-param-${p.id}`);
                const sliderInput = document.getElementById(`os-slider-${p.id}`);
                const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

                const updateSliderBounds = () => {
                    const value = parseFloat(numberInput.value); if (isNaN(value) || !numberInput.checkValidity()) return;
                    let sliderMin, sliderMax;
                    if (value === 0) { sliderMin = -1; sliderMax = 1; } else { const logVal = Math.log10(Math.abs(value)); sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1); sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1); if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin]; }
                    const finalMin = Math.max(p.min ?? -Infinity, sliderMin); const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                    sliderInput.min = finalMin; sliderInput.max = finalMax;
                    if (p.step % 1 === 0) { sliderInput.step = 1; sliderInput.min = Math.ceil(finalMin); sliderInput.max = Math.floor(finalMax); } else { sliderInput.step = (finalMax - finalMin) / 200; }
                };
                numberInput.addEventListener('input', () => { const val = parseFloat(numberInput.value); if (!isNaN(val)) { sliderInput.value = val; } });
                numberInput.addEventListener('change', updateSliderBounds);
                sliderInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); numberInput.value = val.toFixed(precision); update(); });
                sliderInput.addEventListener('change', updateSliderBounds);
                updateSliderBounds(); sliderInput.value = numberInput.value;
            });

            const nk_params = [
                { id: 'n', name: 'Sample size n' },
                { id: 'k', name: 'k-th statistic' }
            ];
            nk_params.forEach(p => {
                 const btn = document.createElement('button');
                btn.id = `os-quick-btn-${p.id}`;
                btn.innerHTML = p.name.split(' ')[0];
                btn.dataset.param = p.id;
                quickParamButtons.appendChild(btn);
            });

            update();
        }

        function updateStats() {
            const { distKey, params, n, k, jstat } = currentState;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];

            const quantile = (p) => orderStatInv(p, config, params, n, k, jstat);

            document.getElementById('os-stat-q1').textContent = quantile(0.25).toFixed(4);
            document.getElementById('os-stat-median').textContent = quantile(0.5).toFixed(4);
            document.getElementById('os-stat-q3').textContent = quantile(0.75).toFixed(4);
            const intervals = { '50': [quantile(0.25), quantile(0.75)], '90': [quantile(0.05), quantile(0.95)], '95': [quantile(0.025), quantile(0.975)], '99': [quantile(0.005), quantile(0.995)] };
            Object.entries(intervals).forEach(([key, val]) => {
                document.getElementById(`os-stat-int${key}`).textContent = `[${val[0].toFixed(2)}, ${val[1].toFixed(2)}]`;
            });

            const meanIntegrand = u => config.inv(u, jstat, params) * jStat.beta.pdf(u, k, n - k + 1);
            const mean = integrate(meanIntegrand, 1e-6, 1-1e-6, 1000);
            currentState.mean = mean;
            document.getElementById('os-stat-mean').textContent = isFinite(mean) ? mean.toFixed(4) : 'N/A';

            if (isFinite(mean)) {
                const varianceIntegrand = u => Math.pow(config.inv(u, jstat, params) - mean, 2) * jStat.beta.pdf(u, k, n - k + 1);
                const variance = integrate(varianceIntegrand, 1e-6, 1 - 1e-6, 1000);
                currentState.variance = variance;
                document.getElementById('os-stat-variance').textContent = isFinite(variance) ? variance.toFixed(4) : 'N/A';
                document.getElementById('os-stat-stddev').textContent = isFinite(variance) ? Math.sqrt(variance).toFixed(4) : 'N/A';
            } else {
                 currentState.variance = null;
                 document.getElementById('os-stat-variance').textContent = 'N/A';
                 document.getElementById('os-stat-stddev').textContent = 'N/A';
            }
        }

        function updatePlot() {
            const { distKey, params, n, k, jstat } = currentState;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            if (!jstat) return;

            const svgRect = svg.node().getBoundingClientRect();
            width = svgRect.width - margin.left - margin.right;
            height = svgRect.height - margin.top - margin.bottom;
            plotArea.attr("transform", `translate(${margin.left},${margin.top})`);
            dragLayer.attr("transform", `translate(${margin.left},${margin.top})`);

            const lowerBound = orderStatInv(0.001, config, params, n, k, jstat);
            const upperBound = orderStatInv(0.999, config, params, n, k, jstat);

            if (!isFinite(lowerBound) || !isFinite(upperBound) || lowerBound >= upperBound) {
                plotArea.selectAll("*").remove();
                return;
            }

            const xDomain = [lowerBound, upperBound];
            xScale.domain(xDomain).range([0, width]);
            xAxis.attr("transform", `translate(${margin.left}, ${height + margin.top})`).call(d3.axisBottom(xScale));

            const plotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 500).map(x => ({ x: x, y: orderStatPDF(x, config, params, n, k, jstat) }));
            const yMax = d3.max(plotData, d => d.y);
            yScale.domain([0, (isFinite(yMax) ? yMax : 1) * 1.1]).range([height, 0]);
            yAxis.attr("transform", `translate(${margin.left}, ${margin.top})`).call(d3.axisLeft(yScale).ticks(5));

            plotArea.selectAll("*").remove();
            dragLayer.selectAll("*").remove();

            const intervalValue = intervalSelect.value;
            if (intervalValue !== '0') {
                const quantile = (p) => orderStatInv(p, config, params, n, k, jstat);
                let lower, upper;
                if (intervalValue.startsWith('p')) {
                    const p = parseFloat(intervalValue.substring(1)) / 100;
                    lower = quantile((1 - p) / 2);
                    upper = quantile(1 - (1 - p) / 2);
                } else {
                    const numSigmas = parseInt(intervalValue.substring(1));
                    const mean = currentState.mean;
                    const stddev = Math.sqrt(currentState.variance);
                    if(isFinite(stddev)) {
                        lower = mean - numSigmas * stddev;
                        upper = mean + numSigmas * stddev;
                    }
                }
                if (lower !== undefined) {
                    const area = d3.area()
                        .x(d => xScale(d.x))
                        .y0(height)
                        .y1(d => yScale(d.y));
                    plotArea.append("path")
                        .datum(plotData.filter(d => d.x >= lower && d.x <= upper))
                        .attr("class", "area-path")
                        .attr("d", area);
                }
            }

            plotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)));

            setupInteractionLayer();
        }

        function setupInteractionLayer() {
            const focus = plotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            let dragState = { startX: null, isDragging: false }; let touchDragState = {};
            const interactionRect = svg.append("rect").attr("transform", `translate(${margin.left},${margin.top})`).style("fill", "none").style("pointer-events", "all").style("touch-action", "none").attr("width", width).attr("height", height);

            function getOrderStatCDF(x) {
                const { distKey, params, n, k, jstat } = currentState;
                const config = CONTINUOUS_DISTRIBUTIONS[distKey];
                const Fx = config.cdf(x, jstat, params);
                return jStat.beta.cdf(Fx, k, n - k + 1);
            }

            function calculateAndDisplayArea(pixel1, pixel2) {
                if (Math.abs(pixel1 - pixel2) < 5) { dragLayer.selectAll("*").remove(); return; }
                const x0 = xScale.invert(pixel1), x1 = xScale.invert(pixel2);
                const lower = Math.min(x0, x1), upper = Math.max(x0, x1);
                const area = getOrderStatCDF(upper) - getOrderStatCDF(lower);
                const text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`;
                dragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
            }

            const drag = d3.drag().filter(event => !event.touches).on("start", (event) => { const [x_coord] = d3.pointer(event, interactionRect.node()); dragState.isDragging = true; dragState.startX = x_coord; dragLayer.selectAll("*").remove(); dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; }).on("drag", (event) => { const [currentX] = d3.pointer(event, interactionRect.node()); const x = Math.min(dragState.startX, currentX), w = Math.abs(currentX - dragState.startX); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }).on("end", (event) => { dragState.isDragging = false; const [endX, endY] = d3.pointer(event, interactionRect.node()); if (endX >= 0 && endX <= width && endY >= 0 && endY <= height) { tooltip.style.opacity = 1; } calculateAndDisplayArea(dragState.startX, endX); });
            interactionRect.call(drag);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, document.getElementById('os-plot-container'));
                tooltip.style.left = tipX + "px";
                tooltip.style.top = tipY + "px";
                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                const y_val = orderStatPDF(x_val, CONTINUOUS_DISTRIBUTIONS[currentState.distKey], currentState.params, currentState.n, currentState.k, currentState.jstat);
                focus.attr("cx", xScale(x_val)).attr("cy", yScale(y_val));
                tooltip.innerHTML = `x: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }

            interactionRect.on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); tooltip.style.opacity = 1; }}).on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); tooltip.style.opacity = 0; }}).on("mousemove", (event) => { if (dragState.isDragging) return; updateTooltip(event); });
            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 2) { event.preventDefault(); touchDragState.isDragging = true; const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; dragLayer.selectAll("*").remove(); dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; focus.style.opacity = 0; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1) { event.preventDefault(); dragLayer.selectAll("*").remove(); updateTooltip(event.touches[0]); focus.style.opacity = 1; tooltip.style.opacity = 1; }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2 && touchDragState.isDragging) { event.preventDefault(); const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1 && !touchDragState.isDragging) { event.preventDefault(); updateTooltip(event.touches[0]); }
            });
            node.addEventListener('touchend', (event) => {
                if (touchDragState.isDragging) { event.preventDefault(); calculateAndDisplayArea(touchDragState.x1, touchDragState.x2); touchDragState = {}; }
                if (event.touches.length === 0) { focus.style.opacity = 0; tooltip.style.opacity = 0; }
            });
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('dist', currentState.distKey);
            for(const p of CONTINUOUS_DISTRIBUTIONS[currentState.distKey].params) {
                params.set(p.id, currentState.params[p.id]);
            }
            params.set('n', currentState.n);
            params.set('k', currentState.k);
            history.replaceState(null, '', '#order-statistics?' + params.toString());
        }

        return {
            init: () => {
                Object.keys(CONTINUOUS_DISTRIBUTIONS).forEach(key => distSelect.appendChild(new Option(CONTINUOUS_DISTRIBUTIONS[key].name, key)));
                distSelect.addEventListener('change', handleDistChange);
                intervalSelect.addEventListener('change', update);
                paramInputs.addEventListener('input', update);
                document.getElementById('os-quick-param-buttons').addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        showQuickSlider(e.target.dataset.param);
                    }
                });
                document.addEventListener('click', (e) => {
                    const quickControlsContainer = document.getElementById('os-quick-controls-container');
                    if (quickControlsContainer && !quickControlsContainer.contains(e.target)) {
                        const quickSliderContainer = document.getElementById('os-quick-slider-container');
                        if (quickSliderContainer) quickSliderContainer.innerHTML = '';
                    }
                });
                const nSlider = document.getElementById('os-n-slider');
                const kSlider = document.getElementById('os-k-slider');

                const updateNSliderBounds = () => {
                    const value = parseFloat(nInput.value); if (isNaN(value) || !nInput.checkValidity()) return;
                    const logVal = Math.max(1, Math.log10(Math.abs(value)));
                    nSlider.min = 1;
                    nSlider.max = Math.ceil(10**(logVal + 1));
                };

                nInput.addEventListener('input', () => {
                    const old_n = currentState.n; const old_k = currentState.k; const new_n = parseInt(nInput.value);
                    if (old_k === old_n && new_n > old_n) { kInput.value = new_n; kSlider.value = new_n; }
                    if (!isNaN(new_n)) {
                        nSlider.value = new_n;
                        kSlider.max = new_n;
                    }
                    update();
                });
                nInput.addEventListener('change', updateNSliderBounds);

                kInput.addEventListener('input', () => { if (!isNaN(parseInt(kInput.value))) kSlider.value = kInput.value; update(); });

                nSlider.addEventListener('input', () => { nInput.value = nSlider.value; nInput.dispatchEvent(new Event('input')); });
                kSlider.addEventListener('input', () => { kInput.value = kSlider.value; kInput.dispatchEvent(new Event('input')); });

                updateNSliderBounds();
                kSlider.max = nInput.value;
                nSlider.value = nInput.value;
                kSlider.value = kInput.value;
                window.addEventListener('resize', () => { if (currentState.jstat) updatePlot(); });
                const resizeObserver = new ResizeObserver(() => {
                    if (currentState.jstat) setTimeout(updatePlot, 0);
                });
                resizeObserver.observe(document.querySelector('#order-statistics-app .plot-svg-wrapper'));
                handleDistChange();
                renderMathInElement(document.getElementById('order-statistics-app'), {
                    delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                });
            },
            updateFromURL: (params) => {
                const dist = params.get('dist');
                if (dist && CONTINUOUS_DISTRIBUTIONS[dist]) {
                    distSelect.value = dist;
                    const config = CONTINUOUS_DISTRIBUTIONS[dist];
                    paramInputs.innerHTML = '';
                    config.params.forEach(p => {
                        const group = document.createElement('div');
                        group.className = 'param-group';
                        const value = params.has(p.id) ? params.get(p.id) : p.default;
                        group.innerHTML = `<label for="os-param-${p.id}">${p.name}</label><input type="number" id="os-param-${p.id}" data-param="${p.id}" value="${value}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}">`;
                        paramInputs.appendChild(group);
                    });
                    if (params.has('n')) nInput.value = params.get('n');
                    if (params.has('k')) kInput.value = params.get('k');
                    update();
                } else {
                    handleDistChange();
                }
            }
        };
    })();

    const bivariateNormalCDF = (x, y, rho) => {
        // Based on the `mnormt` R package, which uses numerical integration.
        if (x === Infinity) return jStat.normal.cdf(y, 0, 1);
        if (y === Infinity) return jStat.normal.cdf(x, 0, 1);
        if (x === -Infinity || y === -Infinity) return 0;
        if (rho === 0) return jStat.normal.cdf(x, 0, 1) * jStat.normal.cdf(y, 0, 1);
        if (rho === 1) return jStat.normal.cdf(Math.min(x, y), 0, 1);
        if (rho === -1) return Math.max(0, jStat.normal.cdf(x, 0, 1) + jStat.normal.cdf(y, 0, 1) - 1);
        if (Math.abs(rho) > 1) rho = Math.sign(rho);

        // Quadrant reduction logic to ensure x > 0, y > 0
        if (x < 0) {
            if (y < 0) {
                return bivariateNormalCDF(-x, -y, rho) - jStat.normal.cdf(-x, 0, 1) - jStat.normal.cdf(-y, 0, 1) + 1;
            } else { // y >= 0
                return jStat.normal.cdf(y, 0, 1) - bivariateNormalCDF(-x, y, -rho);
            }
        } else { // x >= 0
            if (y < 0) {
                return jStat.normal.cdf(x, 0, 1) - bivariateNormalCDF(x, -y, -rho);
            }
            // Now x,y >= 0. If rho < 0, one more reduction.
            if (rho < 0) {
                return jStat.normal.cdf(x, 0, 1) + jStat.normal.cdf(y, 0, 1) - 1 + bivariateNormalCDF(x, y, -rho);
            }
        }

        // At this point, x>=0, y>=0, rho>=0
        const h = x, k = y;
        const hk = h * k;
        const b = (h + k) * (h + k) / 2;
        const rho1 = (rho * hk - b) / (1 - rho * rho);
        const rho2 = (rho * hk + b) / (1 - rho * rho);
        let t = 0;
        if (rho1 > -100) t = Math.exp(rho1) * (1 - rho*rho * (1 + rho1));
        if (rho2 > -100) t -= Math.exp(rho2) * (1 - rho*rho * (1 + rho2));
        t /= (2 * Math.PI * Math.sqrt(1-rho*rho));

        return -t + jStat.normal.cdf(x, 0, 1) * jStat.normal.cdf(y, 0, 1);
    };

    function setupMoveControls(containerSelector) {
        const container = document.querySelector(containerSelector);
        if (!container) return;

        container.addEventListener('click', e => {
            const moveBtn = e.target.closest('.move-btn');
            if (!moveBtn) return;

            const panel = moveBtn.closest('.panel');
            if (!panel || panel.parentElement !== container) return;

            if (moveBtn.classList.contains('move-up')) {
                const prev = panel.previousElementSibling;
                if (prev) {
                    container.insertBefore(panel, prev);
                }
            } else if (moveBtn.classList.contains('move-down')) {
                const next = panel.nextElementSibling;
                if (next) {
                    container.insertBefore(panel, next.nextElementSibling);
                }
            }
        });
    }

    const gaussianCopulaApp = (() => {
        let currentState = {
            distKeyX: 'normal', paramsX: {}, jstatX: null,
            distKeyY: 'normal', paramsY: {}, jstatY: null,
            rho: 0.5, samples: [], conditional: null,
        };

        function showQuickSlider(paramId, varName) {
            const quickSliderContainer = document.getElementById('gc-quick-slider-container');
            quickSliderContainer.innerHTML = '';

            let p, mainNumberInput;

            if (varName === 'x' || varName === 'y') {
                const distKey = (varName === 'x') ? currentState.distKeyX : currentState.distKeyY;
                const config = CONTINUOUS_DISTRIBUTIONS[distKey];
                p = config.params.find(param => param.id === paramId);
                mainNumberInput = document.getElementById(`gc-param-${p.id}-${varName}`);
            } else { // gc var
                if (paramId === 'rho-input') {
                    p = { id: 'rho-input', step: 0.01, min: -0.99, max: 0.99 };
                    mainNumberInput = document.getElementById('gc-rho-input');
                } else if (paramId === 'cond-value') {
                    const condVar = document.getElementById('gc-cond-var').value;
                    const domain = (condVar === 'X' ? CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].domain(currentState.paramsX, currentState.jstatX) : CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].domain(currentState.paramsY, currentState.jstatY));
                    p = { id: 'cond-value', step: 0.1, min: domain[0], max: domain[1] };
                    mainNumberInput = document.getElementById('gc-cond-value');
                } else {
                    return;
                }
            }

            if (!p || !mainNumberInput) return;

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.style.width = '100%';

            const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

            const updateSliderBounds = () => {
                const value = parseFloat(mainNumberInput.value);
                if (isNaN(value) || !mainNumberInput.checkValidity()) return;
                let sliderMin, sliderMax;
                if (paramId === 'cond-value') {
                     const condVar = document.getElementById('gc-cond-var').value;
                     const range = (condVar === 'X' ? CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].domain(currentState.paramsX, currentState.jstatX) : CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].domain(currentState.paramsY, currentState.jstatY));
                     sliderMin = range[0]; sliderMax = range[1];
                } else if (value === 0) { sliderMin = -1; sliderMax = 1; } else {
                    const logVal = Math.log10(Math.abs(value));
                    sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1);
                    sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1);
                    if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin];
                }
                const finalMin = Math.max(p.min ?? -Infinity, sliderMin);
                const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                slider.min = finalMin;
                slider.max = finalMax;
                if (p.step % 1 === 0) {
                    slider.step = 1;
                    slider.min = Math.ceil(finalMin);
                    slider.max = Math.floor(finalMax);
                } else {
                    slider.step = (finalMax - finalMin) / 200;
                }
            };

            updateSliderBounds();
            slider.value = mainNumberInput.value;

            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                mainNumberInput.value = val.toFixed(precision);

                let mainSliderInput;
                if (varName === 'x' || varName === 'y') {
                    mainSliderInput = document.getElementById(`gc-slider-${p.id}-${varName}`);
                } else if (paramId === 'rho-input') {
                    mainSliderInput = document.getElementById('gc-rho-slider');
                }

                if(mainSliderInput) mainSliderInput.value = val;

                if (paramId === 'cond-value') {
                    plotConditional();
                } else {
                    update();
                }
            });

            slider.addEventListener('change', updateSliderBounds);
            quickSliderContainer.appendChild(slider);
        }

        function integrate(f, a, b, n_steps = 200) {
            if (a >= b) return 0;
            n_steps = n_steps % 2 === 0 ? n_steps : n_steps + 1;
            let h = (b - a) / n_steps;
            let sum = f(a) + f(b);
            for (let i = 1; i < n_steps; i += 2) {
                sum += 4 * f(a + i * h);
            }
            for (let i = 2; i < n_steps - 1; i += 2) {
                sum += 2 * f(a + i * h);
            }
            return sum * h / 3;
        }

        const margin = { joint: { top: 10, right: 10, bottom: 40, left: 50 }, marginalX: { top: 10, right: 10, bottom: 5, left: 50 }, marginalY: { top: 10, right: 30, bottom: 40, left: 5 }, density: { top: 20, right: 30, bottom: 40, left: 50 } };

        // Scatter plot elements
        const jointSvg = d3.select("#gc-joint-plot-svg");
        const marginalXSvg = d3.select("#gc-marginal-x-svg");
        const marginalYSvg = d3.select("#gc-marginal-y-svg");

        const jointXScale = d3.scaleLinear(), jointYScale = d3.scaleLinear();
        const jointXAxis = jointSvg.append("g").attr("class", "x-axis axis");
        const jointYAxis = jointSvg.append("g").attr("class", "y-axis axis");
        const jointPlotArea = jointSvg.append("g").attr("class", "plot-area");

        const marginalXYScale = d3.scaleLinear();
        const marginalXPlotArea = marginalXSvg.append("g").attr("class", "plot-area");

        const marginalYXScale = d3.scaleLinear();
        const marginalYPlotArea = marginalYSvg.append("g").attr("class", "plot-area");

        // Density plot elements
        const densitySvg = d3.select("#gc-density-plot-svg");
        const densityTooltip = d3.select("#gc-density-tooltip");
        let densityWidth, densityHeight;
        const densityXScale = d3.scaleLinear(), densityYScale = d3.scaleLinear();
        const densityXAxis = densitySvg.append("g").attr("class", "x-axis axis");
        const densityYAxis = densitySvg.append("g").attr("class", "y-axis axis");
        const densityPlotArea = densitySvg.append("g").attr("class", "plot-area");
        const densityDragLayer = densitySvg.append("g").attr("class", "drag-layer");

        let condVarSelect, condValueInput;

        const updateCondValueToMean = () => {
            const condVar = condVarSelect.value;
            const distKey = (condVar === 'X') ? currentState.distKeyX : currentState.distKeyY;
            const params = (condVar === 'X') ? currentState.paramsX : currentState.paramsY;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            const mean = config.mean(params);
            if (isFinite(mean)) {
                condValueInput.value = mean.toFixed(4);
            }
        };

        function handleDistChange(varName) {
            const distSelect = document.getElementById(`gc-dist-select-${varName}`);
            const paramInputs = document.getElementById(`gc-param-inputs-${varName}`);
            const distKey = distSelect.value;
            currentState[`distKey${varName.toUpperCase()}`] = distKey;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            paramInputs.innerHTML = '';
            config.params.forEach(p => {
                const group = document.createElement('div');
                group.className = 'param-group';
                group.innerHTML = `<label for="gc-param-${p.id}-${varName}">${p.name}</label>
                    <div class="slider-group">
                        <input type="range" id="gc-slider-${p.id}-${varName}" value="${p.default}">
                        <input type="number" id="gc-param-${p.id}-${varName}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}" style="width: 80px;">
                    </div>`;
                paramInputs.appendChild(group);

                const numberInput = document.getElementById(`gc-param-${p.id}-${varName}`);
                const sliderInput = document.getElementById(`gc-slider-${p.id}-${varName}`);
                const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

                const updateSliderBounds = () => {
                    const value = parseFloat(numberInput.value); if (isNaN(value) || !numberInput.checkValidity()) return;
                    let sliderMin, sliderMax;
                    if (value === 0) { sliderMin = -1; sliderMax = 1; } else { const logVal = Math.log10(Math.abs(value)); sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1); sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1); if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin]; }
                    const finalMin = Math.max(p.min ?? -Infinity, sliderMin); const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                    sliderInput.min = finalMin; sliderInput.max = finalMax;
                    if (p.step % 1 === 0) { sliderInput.step = 1; sliderInput.min = Math.ceil(finalMin); sliderInput.max = Math.floor(finalMax); } else { sliderInput.step = (finalMax - finalMin) / 200; }
                };

                numberInput.addEventListener('input', () => { const val = parseFloat(numberInput.value); if (!isNaN(val)) { sliderInput.value = val; } });
                numberInput.addEventListener('change', updateSliderBounds);
                sliderInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); numberInput.value = val.toFixed(precision); update(); });
                sliderInput.addEventListener('change', updateSliderBounds);
                updateSliderBounds(); sliderInput.value = numberInput.value;
            });
            update({ distChangedFor: varName });
        }

        function update(options = {}) {
            let allValid = true;
            const readParams = (varName) => {
                const distKey = currentState[`distKey${varName.toUpperCase()}`];
                const config = CONTINUOUS_DISTRIBUTIONS[distKey];
                const params = {};
                config.params.forEach(p => {
                    const input = document.getElementById(`gc-param-${p.id}-${varName}`);
                    if (input && input.checkValidity()) {
                        params[p.id] = parseFloat(input.value);
                    } else {
                        allValid = false;
                    }
                });
                return params;
            };

            currentState.paramsX = readParams('x');
            currentState.paramsY = readParams('y');

            if (options.distChangedFor && condVarSelect) {
                const currentCondVar = condVarSelect.value.toLowerCase();
                if (options.distChangedFor === currentCondVar) {
                    updateCondValueToMean();
                }
            }

            currentState.rho = parseFloat(document.getElementById('gc-rho-input').value);
            if (!allValid) return;

            currentState.jstatX = CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].jStat(currentState.paramsX);
            currentState.jstatY = CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].jStat(currentState.paramsY);

            const quickParamButtons = document.getElementById('gc-quick-param-buttons');
            quickParamButtons.innerHTML = '';

            const createBtn = (p, varName) => {
                const btn = document.createElement('button');
                btn.id = `gc-quick-btn-${p.id}-${varName}`;
                btn.innerHTML = p.name.split(' ')[0];
                btn.dataset.param = p.id;
                btn.dataset.var = varName;
                quickParamButtons.appendChild(btn);
            };

            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].params.forEach(p => createBtn(p, 'x'));
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].params.forEach(p => createBtn(p, 'y'));
            createBtn({id: 'rho-input', name: 'Corr ρ'}, 'gc');
            createBtn({id: 'cond-value', name: 'Cond value'}, 'gc');

            updateJointAndMarginalPlots();
            plotConditional();
            if (!options.fromURL) updateURL();
        }

        function generateSamples(count) {
            const { distKeyX, paramsX, jstatX, distKeyY, paramsY, jstatY, rho } = currentState;
            const configX = CONTINUOUS_DISTRIBUTIONS[distKeyX];
            const configY = CONTINUOUS_DISTRIBUTIONS[distKeyY];

            for (let i = 0; i < count; i++) {
                const z1 = jStat.normal.sample(0, 1);
                const z2 = jStat.normal.sample(0, 1);
                const x_prime = z1;
                const y_prime = rho * z1 + Math.sqrt(1 - rho * rho) * z2;
                const u = jStat.normal.cdf(x_prime, 0, 1);
                const v = jStat.normal.cdf(y_prime, 0, 1);
                const x = configX.inv(u, jstatX, paramsX);
                const y = configY.inv(v, jstatY, paramsY);
                if (isFinite(x) && isFinite(y)) {
                    currentState.samples.push([x, y]);
                }
            }
            updateJointAndMarginalPlots();
        }

        function plotConditional() {
            const condVar = document.getElementById('gc-cond-var').value;
            const condType = document.getElementById('gc-cond-type').value;
            const condValue = parseFloat(document.getElementById('gc-cond-value').value);

            let config1, params1, jstat1, config2, params2, jstat2;
            if (condVar === 'X') {
                [config1, params1, jstat1] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX], currentState.paramsX, currentState.jstatX];
                [config2, params2, jstat2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY], currentState.paramsY, currentState.jstatY];
            } else {
                [config1, params1, jstat1] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY], currentState.paramsY, currentState.jstatY];
                [config2, params2, jstat2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX], currentState.paramsX, currentState.jstatX];
            }

            const rho = (condVar === 'X') ? currentState.rho : currentState.rho;
            const u = config1.cdf(condValue, jstat1, params1);
            const x_prime = jStat.normal.inv(u, 0, 1);

            let condPdf;
            if (condType === 'eq') {
                condPdf = y => {
                    const v = config2.cdf(y, jstat2, params2);
                    const y_prime = jStat.normal.inv(v, 0, 1);
                    if (!isFinite(y_prime)) return 0;
                    const f_y = config2.pdfpmf(y, jstat2, params2);
                    const phi_y_prime = jStat.normal.pdf(y_prime, 0, 1);
                    if (phi_y_prime < 1e-9) return 0;
                    const term = (y_prime - rho * x_prime) / Math.sqrt(1 - rho * rho);
                    return (f_y / phi_y_prime) * (1 / Math.sqrt(1 - rho * rho)) * jStat.normal.pdf(term, 0, 1);
                };
            } else if (condType === 'ge') {
                if (1 - u < 1e-9) {
                    condPdf = y => 0;
                } else {
                    condPdf = y => {
                        const v = config2.cdf(y, jstat2, params2);
                        const y_prime = jStat.normal.inv(v, 0, 1);
                        if (!isFinite(y_prime)) return 0;
                        const f_y = config2.pdfpmf(y, jstat2, params2);
                        const term = (x_prime - rho * y_prime) / Math.sqrt(1 - rho*rho);
                        return (f_y / (1 - u)) * (1 - jStat.normal.cdf(term, 0, 1));
                    };
                }
            } else { // le
                if (u < 1e-9) {
                    condPdf = y => 0;
                } else {
                    condPdf = y => {
                        const v = config2.cdf(y, jstat2, params2);
                        const y_prime = jStat.normal.inv(v, 0, 1);
                        if (!isFinite(y_prime)) return 0;
                        const f_y = config2.pdfpmf(y, jstat2, params2);
                        const term = (x_prime - rho * y_prime) / Math.sqrt(1 - rho*rho);
                        return (f_y / u) * jStat.normal.cdf(term, 0, 1);
                    };
                }
            }

            currentState.conditional = { condPdf, condVar, condType, condValue };
            updateDensityPlot();
        }


        function inverseConditionalCdf(p, condInfo, domain) {
            if (p <= 0) return domain[0];
            if (p >= 1) return domain[1];

            if (condInfo.condType === 'eq') {
                let config2, jstat2, params2;
                if (condInfo.condVar === 'X') {
                    [config2, jstat2, params2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY], currentState.jstatY, currentState.paramsY];
                } else {
                    [config2, jstat2, params2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX], currentState.jstatX, currentState.paramsX];
                }
                const rho = currentState.rho;
                const u = CONTINUOUS_DISTRIBUTIONS[condInfo.condVar === 'X' ? currentState.distKeyX : currentState.distKeyY].cdf(condInfo.condValue, condInfo.condVar === 'X' ? currentState.jstatX : currentState.jstatY, condInfo.condVar === 'X' ? currentState.paramsX : currentState.paramsY);
                const x_prime = jStat.normal.inv(u, 0, 1);
                const val = jStat.normal.inv(p, 0, 1) * Math.sqrt(1 - rho*rho) + rho * x_prime;
                return config2.inv(jStat.normal.cdf(val, 0, 1), jstat2, params2);
            }

            // For ge and le conditions, use numerical inversion (binary search) on integrated PDF
            let low = domain[0], high = domain[1];
            // Normalize total integral to 1 for robustness
            const total_integral = integrate(condInfo.condPdf, domain[0], domain[1], 400);

            for (let i = 0; i < 50; i++) { // 50 iterations for precision
                const mid = (low + high) / 2;
                const candidate = integrate(condInfo.condPdf, domain[0], mid, 200) / total_integral;
                if (candidate < p) {
                    low = mid;
                } else {
                    high = mid;
                }
            }
            return (low + high) / 2;
        }

        function updateJointAndMarginalPlots() {
            const jointRect = jointSvg.node().getBoundingClientRect();
            const marginalXRect = marginalXSvg.node().getBoundingClientRect();
            const marginalYRect = marginalYSvg.node().getBoundingClientRect();
            if (jointRect.width <= 0) return;

            const jointWidth = jointRect.width - margin.joint.left - margin.joint.right;
            const jointHeight = jointRect.height - margin.joint.top - margin.joint.bottom;
            const marginalXHeight = marginalXRect.height - margin.marginalX.top - margin.marginalX.bottom;
            const marginalYWidth = marginalYRect.width - margin.marginalY.left - margin.marginalY.right;

            jointPlotArea.attr("transform", `translate(${margin.joint.left},${margin.joint.top})`);
            marginalXPlotArea.attr("transform", `translate(${margin.marginalX.left},${margin.marginalX.top})`);
            marginalYPlotArea.attr("transform", `translate(${margin.marginalY.left},${margin.marginalY.top})`);

            const { distKeyX, paramsX, jstatX, distKeyY, paramsY, jstatY, samples } = currentState;
            if (!jstatX || !jstatY) return;
            const configX = CONTINUOUS_DISTRIBUTIONS[distKeyX];
            const configY = CONTINUOUS_DISTRIBUTIONS[distKeyY];

            const xDomain = configX.domain(paramsX, jstatX);
            const yDomain = configY.domain(paramsY, jstatY);

            jointXScale.domain(xDomain).range([0, jointWidth]);
            jointYScale.domain(yDomain).range([jointHeight, 0]);

            jointXAxis.attr("transform", `translate(${margin.joint.left}, ${jointHeight + margin.joint.top})`).call(d3.axisBottom(jointXScale));
            jointYAxis.attr("transform", `translate(${margin.joint.left}, ${margin.joint.top})`).call(d3.axisLeft(jointYScale));

            jointSvg.selectAll(".plot-label").remove();
            jointSvg.append("text").attr("class", "plot-label").attr("x", margin.joint.left + jointWidth / 2).attr("y", jointHeight + margin.joint.top + 35).style("text-anchor", "middle").text("X");
            jointSvg.append("text").attr("class", "plot-label").attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(margin.joint.top + jointHeight / 2)).attr("dy", "1em").style("text-anchor", "middle").text("Y");

            jointPlotArea.selectAll(".scatter-dot").remove();
            jointPlotArea.selectAll(".scatter-dot").data(samples).enter().append("circle").attr("class", "scatter-dot").attr("cx", d => jointXScale(d[0])).attr("cy", d => jointYScale(d[1])).attr("r", 3);

            marginalXPlotArea.selectAll("*").remove();
            marginalYPlotArea.selectAll("*").remove();

            // Marginal X plot (top)
            const xPlotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 200).map(x => ({ x: x, y: configX.pdfpmf(x, jstatX, paramsX) }));
            const yMaxX = d3.max(xPlotData, d => d.y);
            marginalXYScale.domain([0, yMaxX * 1.1]).range([marginalXHeight, 0]);

            // Marginal Y plot (right)
            const yPlotData = d3.range(yDomain[0], yDomain[1], (yDomain[1] - yDomain[0]) / 200).map(y => ({ x: y, y: configY.pdfpmf(y, jstatY, paramsY) }));
            const yMaxY = d3.max(yPlotData, d => d.y);
            marginalYXScale.domain([0, yMaxY * 1.1]).range([0, marginalYWidth]);

            if (samples.length > 0) {
                // X histogram
                const xSamples = samples.map(d => d[0]);
                const xHistogram = d3.histogram().domain(jointXScale.domain()).thresholds(jointXScale.ticks(20))(xSamples);
                const xHistMax = d3.max(xHistogram, d => d.length) || 1;
                marginalXPlotArea.selectAll(".histogram-bar").data(xHistogram).enter().append("rect").attr("class", "histogram-bar")
                    .attr("x", d => jointXScale(d.x0) + 1).attr("width", d => Math.max(0, jointXScale(d.x1) - jointXScale(d.x0) - 1))
                    .attr("y", d => marginalXYScale(d.length * yMaxX / xHistMax)).attr("height", d => marginalXHeight - marginalXYScale(d.length * yMaxX / xHistMax));

                // Y histogram
                const ySamples = samples.map(d => d[1]);
                const yHistogram = d3.histogram().domain(jointYScale.domain()).thresholds(jointYScale.ticks(20))(ySamples);
                const yHistMax = d3.max(yHistogram, d => d.length) || 1;
                marginalYPlotArea.selectAll(".histogram-bar").data(yHistogram).enter().append("rect").attr("class", "histogram-bar")
                    .attr("y", d => jointYScale(d.x1) + 1).attr("height", d => Math.max(0, jointYScale(d.x0) - jointYScale(d.x1) - 1))
                    .attr("x", 0).attr("width", d => marginalYXScale(d.length * yMaxY / yHistMax));
            }

            marginalXPlotArea.append("path").datum(xPlotData).attr("class", "line-path").attr("d", d3.line().x(d => jointXScale(d.x)).y(d => marginalXYScale(d.y)));
            marginalYPlotArea.append("path").datum(yPlotData).attr("class", "line-path").attr("d", d3.line().x(d => marginalYXScale(d.y)).y(d => jointYScale(d.x)));
        }

        function updateDensityPlot() {
            const titleEl = document.getElementById('gc-density-plot-title');
            const controlsEl = document.getElementById('gc-density-controls');
            const meanEl = document.getElementById('gc-conditional-mean-display');

            if (!currentState.conditional) {
                densitySvg.style("display", "none");
                titleEl.style.display = 'none';
                controlsEl.style.display = 'none';
                meanEl.style.display = 'none';
                return;
            }
            densitySvg.style("display", "block");
            titleEl.style.display = 'block';
            controlsEl.style.display = 'flex';
            meanEl.style.display = 'block';

            const { condPdf, condVar, condType, condValue } = currentState.conditional;
            const otherVar = condVar === 'X' ? 'Y' : 'X';
            const typeSymbol = { eq: '=', ge: '≥', le: '≤' }[condType];
            titleEl.textContent = `Density of ${otherVar} | ${condVar} ${typeSymbol} ${condValue}`;

            const svgRect = densitySvg.node().getBoundingClientRect();
             if (svgRect.width <= 0) return;
            densityWidth = svgRect.width - margin.density.left - margin.density.right;
            densityHeight = svgRect.height - margin.density.top - margin.density.bottom;
            densityPlotArea.attr("transform", `translate(${margin.density.left},${margin.density.top})`);
            densityDragLayer.attr("transform", `translate(${margin.density.left},${margin.density.top})`);

            const { distKeyX, paramsX, jstatX, distKeyY, paramsY, jstatY } = currentState;

            const [domainConfig, domainParams, domainJstat] = (condVar === 'X') ?
                [CONTINUOUS_DISTRIBUTIONS[distKeyY], paramsY, jstatY] :
                [CONTINUOUS_DISTRIBUTIONS[distKeyX], paramsX, jstatX];

            const marginalDomain = domainConfig.domain(domainParams, domainJstat);
            const lowerBound = inverseConditionalCdf(0.001, currentState.conditional, marginalDomain);
            const upperBound = inverseConditionalCdf(0.999, currentState.conditional, marginalDomain);

            let plotDomain = [lowerBound, upperBound];
            if (!isFinite(plotDomain[0]) || !isFinite(plotDomain[1]) || plotDomain[0] >= plotDomain[1]) {
                plotDomain = marginalDomain;
            }
            const plotData = d3.range(plotDomain[0], plotDomain[1], (plotDomain[1] - plotDomain[0]) / 200).map(v => ({x: v, y: condPdf(v)})).filter(d => isFinite(d.y));

            const totalIntegral = integrate(condPdf, plotDomain[0], plotDomain[1], 400);
            const meanIntegrand = x => x * condPdf(x);
            const mean = integrate(meanIntegrand, plotDomain[0], plotDomain[1], 400) / totalIntegral;
            if (isFinite(mean)) {
                meanEl.textContent = `Mean: ${mean.toFixed(4)}`;
            } else {
                meanEl.textContent = 'Mean: N/A';
            }

            const updateBtn = (p, varName, value) => {
                const btn = document.getElementById(`gc-quick-btn-${p.id}-${varName}`);
                if (btn) {
                    const inputEl = document.getElementById(`gc-param-${p.id}-${varName}`) || document.getElementById(`gc-${p.id}`);
                    const step = inputEl ? parseFloat(inputEl.step) : 0.01;
                    const precision = (() => { if (!step || String(step).indexOf('.') === -1) return 0; return String(step).split('.')[1].length; })();
                    btn.innerHTML = `${p.name.split(' ')[0]} = ${value.toFixed(precision)}`;
                }
            };
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].params.forEach(p => updateBtn(p, 'x', currentState.paramsX[p.id]));
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].params.forEach(p => updateBtn(p, 'y', currentState.paramsY[p.id]));
            updateBtn({id: 'rho-input', name: 'Corr ρ'}, 'gc', currentState.rho);
            updateBtn({id: 'cond-value', name: 'Cond value'}, 'gc', parseFloat(document.getElementById('gc-cond-value').value));

            const yMax = d3.max(plotData, d => d.y);

            densityXScale.domain(plotDomain).range([0, densityWidth]);
            densityYScale.domain([0, (isFinite(yMax) ? yMax : 1) * 1.1]).range([densityHeight, 0]);

            densityXAxis.attr("transform", `translate(${margin.density.left}, ${densityHeight + margin.density.top})`).call(d3.axisBottom(densityXScale));
            densityYAxis.attr("transform", `translate(${margin.density.left}, ${margin.density.top})`).call(d3.axisLeft(densityYScale));

            densityPlotArea.selectAll("*").remove();
            densityDragLayer.selectAll("*").remove();

            const intervalValue = document.getElementById('gc-interval-select').value;
            if (intervalValue !== '0') {
                const p = parseFloat(intervalValue.substring(1)) / 100;
                const lower = inverseConditionalCdf((1 - p) / 2, currentState.conditional, plotDomain);
                const upper = inverseConditionalCdf(1 - (1 - p) / 2, currentState.conditional, plotDomain);
                if (lower !== undefined) {
                    const area = d3.area().x(d => densityXScale(d.x)).y0(densityHeight).y1(d => densityYScale(d.y));
                    densityPlotArea.append("path").datum(plotData.filter(d => d.x >= lower && d.x <= upper)).attr("class", "area-path").attr("d", area);
                }
            }

            densityPlotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => densityXScale(d.x)).y(d => densityYScale(d.y)));

            setupDensityInteractionLayer();
        }

        function setupDensityInteractionLayer() {
            const focus = densityPlotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            let dragState = { startX: null, isDragging: false }; let touchDragState = {};
            const interactionRect = densitySvg.append("rect").attr("transform", `translate(${margin.density.left},${margin.density.top})`).style("fill", "none").style("pointer-events", "all").style("touch-action", "none").attr("width", densityWidth).attr("height", densityHeight);

            function calculateAndDisplayArea(pixel1, pixel2) {
                if (Math.abs(pixel1 - pixel2) < 5) { densityDragLayer.selectAll("*").remove(); return; }
                const x0 = densityXScale.invert(pixel1), x1 = densityXScale.invert(pixel2);
                const lower = Math.min(x0, x1), upper = Math.max(x0, x1);
                const area = integrate(currentState.conditional.condPdf, lower, upper);
                const text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`;
                densityDragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
            }

            const drag = d3.drag().filter(event => !event.touches).on("start", (event) => {
                const [x_coord] = d3.pointer(event, interactionRect.node());
                dragState = { isDragging: true, startX: x_coord };
                densityDragLayer.selectAll("*").remove();
                densityDragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", densityHeight);
                densityTooltip.style("opacity", 0);
            }).on("drag", (event) => {
                const [currentX] = d3.pointer(event, interactionRect.node());
                const x = Math.min(dragState.startX, currentX), w = Math.abs(currentX - dragState.startX);
                densityDragLayer.select(".drag-selection").attr("x", x).attr("width", w);
            }).on("end", (event) => {
                dragState.isDragging = false;
                const [endX] = d3.pointer(event, interactionRect.node());
                calculateAndDisplayArea(dragState.startX, endX);
            });

            interactionRect.call(drag);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, document.getElementById('gc-density-plot-container'));
                densityTooltip.style("left", tipX + "px").style("top", tipY + "px");
                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = densityXScale.invert(x_coord);
                const y_val = currentState.conditional.condPdf(x_val);
                focus.attr("cx", densityXScale(x_val)).attr("cy", densityYScale(y_val));
                densityTooltip.html(`x: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`);
            }

            interactionRect.on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); densityTooltip.style("opacity", 1); }})
                         .on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); densityTooltip.style("opacity", 0); }})
                         .on("mousemove", (event) => { if (!dragState.isDragging) { updateTooltip(event); }});

            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 2) {
                    event.preventDefault();
                    touchDragState.isDragging = true;
                    const pointers = d3.pointers(event, node);
                    touchDragState.x1 = pointers[0][0];
                    touchDragState.x2 = pointers[1][0];
                    densityDragLayer.selectAll("*").remove();
                    densityDragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", densityHeight);
                    densityTooltip.style("opacity", 0);
                    focus.style("opacity", 0);
                    const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2);
                    densityDragLayer.select(".drag-selection").attr("x", x).attr("width", w);
                } else if (event.touches.length === 1) {
                    event.preventDefault();
                    densityDragLayer.selectAll("*").remove();
                    updateTooltip(event.touches[0]);
                    focus.style("opacity", 1);
                    densityTooltip.style("opacity", 1);
                }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2 && touchDragState.isDragging) {
                    event.preventDefault();
                    const pointers = d3.pointers(event, node);
                    touchDragState.x1 = pointers[0][0];
                    touchDragState.x2 = pointers[1][0];
                    const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2);
                    densityDragLayer.select(".drag-selection").attr("x", x).attr("width", w);
                } else if (event.touches.length === 1 && !touchDragState.isDragging) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                }
            });
            node.addEventListener('touchend', (event) => {
                if (touchDragState.isDragging) {
                    event.preventDefault();
                    calculateAndDisplayArea(touchDragState.x1, touchDragState.x2);
                    touchDragState = {};
                }
                if (event.touches.length === 0) {
                    focus.style("opacity", 0);
                    densityTooltip.style("opacity", 0);
                }
            });
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('distX', currentState.distKeyX);
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].params.forEach(p => params.set(`${p.id}X`, currentState.paramsX[p.id]));
            params.set('distY', currentState.distKeyY);
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].params.forEach(p => params.set(`${p.id}Y`, currentState.paramsY[p.id]));
            params.set('rho', currentState.rho);
            history.replaceState(null, '', '#gaussian-copula?' + params.toString());
        }

        return {
            init: () => {
                const distSelectX = document.getElementById('gc-dist-select-x');
                const distSelectY = document.getElementById('gc-dist-select-y');
                Object.keys(CONTINUOUS_DISTRIBUTIONS).forEach(key => {
                    distSelectX.appendChild(new Option(CONTINUOUS_DISTRIBUTIONS[key].name, key));
                    distSelectY.appendChild(new Option(CONTINUOUS_DISTRIBUTIONS[key].name, key));
                });
                distSelectX.value = 'normal';
                distSelectY.value = 'normal';

                distSelectX.addEventListener('change', () => handleDistChange('x'));
                distSelectY.addEventListener('change', () => handleDistChange('y'));

                document.getElementById('gc-quick-param-buttons').addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        showQuickSlider(e.target.dataset.param, e.target.dataset.var);
                    }
                });
                document.addEventListener('click', (e) => {
                    const quickControlsContainer = document.getElementById('gc-quick-controls-container');
                    if (quickControlsContainer && !quickControlsContainer.contains(e.target)) {
                        const quickSliderContainer = document.getElementById('gc-quick-slider-container');
                        if (quickSliderContainer) quickSliderContainer.innerHTML = '';
                    }
                });

                document.getElementById('gc-param-inputs-x').addEventListener('input', update);
                document.getElementById('gc-param-inputs-y').addEventListener('input', update);
                const rhoSlider = document.getElementById('gc-rho-slider');
                const rhoInput = document.getElementById('gc-rho-input');
                rhoSlider.addEventListener('input', () => {
                    rhoInput.value = rhoSlider.value;
                    update();
                });
                rhoInput.addEventListener('input', () => {
                    if (rhoInput.checkValidity()) {
                        rhoSlider.value = rhoInput.value;
                        update();
                    }
                });

                document.getElementById('gc-sample-btn-1').addEventListener('click', () => generateSamples(1));
                document.getElementById('gc-sample-btn-10').addEventListener('click', () => generateSamples(10));
                document.getElementById('gc-sample-btn-100').addEventListener('click', () => generateSamples(100));
                document.getElementById('gc-sample-btn-1000').addEventListener('click', () => generateSamples(1000));
                document.getElementById('gc-sample-clear-btn').addEventListener('click', () => {
                    currentState.samples = [];
                    updateJointAndMarginalPlots();
                });

                condVarSelect = document.getElementById('gc-cond-var');
                const condTypeSelect = document.getElementById('gc-cond-type');
                condValueInput = document.getElementById('gc-cond-value');

                condVarSelect.addEventListener('input', () => {
                    updateCondValueToMean();
                    plotConditional();
                });
                condTypeSelect.addEventListener('input', plotConditional);
                condValueInput.addEventListener('input', plotConditional);
                document.getElementById('gc-interval-select').addEventListener('change', updateDensityPlot);

                window.addEventListener('resize', () => { updateJointAndMarginalPlots(); updateDensityPlot(); });

                const scatterResizeObserver = new ResizeObserver(() => setTimeout(updateJointAndMarginalPlots, 0));
                scatterResizeObserver.observe(document.getElementById('gc-joint-plot-grid'));

                const densityResizeObserver = new ResizeObserver(() => setTimeout(updateDensityPlot, 0));
                densityResizeObserver.observe(document.querySelector('#gc-density-plot-container .plot-svg-wrapper'));

                setupMoveControls('#gc-plots-panel');

                handleDistChange('x');
                handleDistChange('y');
                renderMathInElement(document.getElementById('gaussian-copula-app'), {
                    delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                });
            },
            updateFromURL: (params) => {
                const dists = { X: params.get('distX'), Y: params.get('distY') };
                ['X', 'Y'].forEach(v => {
                    if (dists[v] && CONTINUOUS_DISTRIBUTIONS[dists[v]]) {
                        document.getElementById(`gc-dist-select-${v.toLowerCase()}`).value = dists[v];
                        handleDistChange(v.toLowerCase());
                        const config = CONTINUOUS_DISTRIBUTIONS[dists[v]];
                        config.params.forEach(p => {
                            if (params.has(`${p.id}${v}`)) {
                                document.getElementById(`gc-param-${p.id}-${v.toLowerCase()}`).value = params.get(`${p.id}${v}`);
                            }
                        });
                    }
                });
                if (params.has('rho')) {
                    const rhoVal = params.get('rho');
                    document.getElementById('gc-rho-slider').value = rhoVal;
                    document.getElementById('gc-rho-input').value = rhoVal;
                }
                update({ fromURL: true });
            }
        };
    })();

    const wienerProcessApp = (() => {
        let state = {
            x0: 0, m: 0, sigma: 1, T: 1,
            barrier: 2,
            paths: []
        };

        function showQuickSlider(paramId, prefix) {
            document.querySelectorAll('.quick-slider-container').forEach(c => {
                if (c.id !== `${prefix}-quick-slider-container`) {
                    c.innerHTML = '';
                }
            });
            const quickSliderContainer = document.getElementById(`${prefix}-quick-slider-container`);
            quickSliderContainer.innerHTML = '';

            const mainNumberInput = document.getElementById(`wp-${paramId}`);
            if (!mainNumberInput) return;

            const p = {
                id: paramId,
                step: parseFloat(mainNumberInput.step),
                min: mainNumberInput.min ? parseFloat(mainNumberInput.min) : undefined,
                max: mainNumberInput.max ? parseFloat(mainNumberInput.max) : undefined
            };

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.style.width = '100%';

            const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

            const updateSliderBounds = () => {
                const value = parseFloat(mainNumberInput.value);
                if (isNaN(value) || !mainNumberInput.checkValidity()) return;
                let sliderMin, sliderMax;
                if (value === 0) { sliderMin = -1; sliderMax = 1; } else {
                    const logVal = Math.log10(Math.abs(value));
                    sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1);
                    sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1);
                    if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin];
                }
                const finalMin = Math.max(p.min ?? -Infinity, sliderMin);
                const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                slider.min = finalMin;
                slider.max = finalMax;
                if (p.step % 1 === 0) {
                    slider.step = 1;
                    slider.min = Math.ceil(finalMin);
                    slider.max = Math.floor(finalMax);
                } else {
                    slider.step = (finalMax - finalMin) / 200;
                }
            };

            updateSliderBounds();
            slider.value = mainNumberInput.value;

            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                mainNumberInput.value = val.toFixed(precision);
                const mainSliderInput = document.getElementById(`wp-${p.id}-slider`);
                if(mainSliderInput) mainSliderInput.value = val;
                update();
            });

            slider.addEventListener('change', updateSliderBounds);
            quickSliderContainer.appendChild(slider);
        }

        const pathsSvg = d3.select("#wp-paths-svg");
        const marginalSvg = d3.select("#wp-marginal-svg");
        const htDensitySvg = d3.select("#wp-ht-density-svg");
        const htProbSvg = d3.select("#wp-ht-prob-svg");
        const hpByBarrierSvg = d3.select("#wp-hp-by-barrier-svg");
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };

        function init() {
            const params = [
                { id: 'x0', step: 0.1 },
                { id: 'drift', step: 0.1 },
                { id: 'volatility', step: 0.01, min: 0.01 },
                { id: 'terminal-time', step: 0.1, min: 0.1 },
                { id: 'barrier', step: 0.01 }
            ];

            params.forEach(p => {
                const numberInput = document.getElementById(`wp-${p.id}`);
                const sliderInput = document.getElementById(`wp-${p.id}-slider`);
                const precision = (() => { if (!p.step || String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();

                const updateSliderBounds = () => {
                    const value = parseFloat(numberInput.value);
                    if (isNaN(value) || !numberInput.checkValidity()) return;
                    let sliderMin, sliderMax;
                    if (value === 0) { sliderMin = -1; sliderMax = 1; } else { const logVal = Math.log10(Math.abs(value)); sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1); sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1); if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin]; }
                    const finalMin = Math.max(p.min ?? -Infinity, sliderMin);
                    const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                    sliderInput.min = finalMin; sliderInput.max = finalMax;
                    if (p.step % 1 === 0) { sliderInput.step = 1; sliderInput.min = Math.ceil(finalMin); sliderInput.max = Math.floor(finalMax); } else { sliderInput.step = (finalMax - finalMin) / 200; }
                };

                numberInput.addEventListener('input', () => {
                    const val = parseFloat(numberInput.value); if (!isNaN(val)) { sliderInput.value = val; }
                    update();
                });
                numberInput.addEventListener('change', updateSliderBounds);
                sliderInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); numberInput.value = val.toFixed(precision); update(); });
                sliderInput.addEventListener('change', updateSliderBounds);
                updateSliderBounds(); sliderInput.value = numberInput.value;
            });

            document.getElementById('wp-cone-select').addEventListener('change', update);

            document.getElementById('wp-clear-paths-btn').addEventListener('click', () => {
                state.paths = [];
                updatePathsPlot();
            });
            document.getElementById('wp-draw1-btn').addEventListener('click', () => drawSamplePaths(1));
            document.getElementById('wp-draw10-btn').addEventListener('click', () => drawSamplePaths(10));
            document.getElementById('wp-draw100-btn').addEventListener('click', () => drawSamplePaths(100));

            const quickContainers = ['wp-paths', 'wp-ht', 'wp-hpbb'];
            quickContainers.forEach(prefix => {
                 const container = document.getElementById(`${prefix}-quick-param-buttons`);
                 if (container) {
                    container.addEventListener('click', (e) => {
                        if (e.target.tagName === 'BUTTON') {
                            showQuickSlider(e.target.dataset.param, e.target.dataset.prefix);
                        }
                    });
                 }
            });
            document.addEventListener('click', (e) => {
                let isInside = false;
                quickContainers.forEach(prefix => {
                    const quickControlsContainer = document.getElementById(`${prefix}-quick-controls-container`);
                    if (quickControlsContainer && quickControlsContainer.contains(e.target)) {
                        isInside = true;
                    }
                });
                if (!isInside) {
                     quickContainers.forEach(prefix => {
                        const quickSliderContainer = document.getElementById(`${prefix}-quick-slider-container`);
                        if (quickSliderContainer) quickSliderContainer.innerHTML = '';
                    });
                }
            });

            const resizeObserver = new ResizeObserver(() => {
                setTimeout(update, 0);
            });
            document.querySelectorAll('#wiener-process-app .wp-plot-container').forEach(el => resizeObserver.observe(el));

            setupMoveControls('#wp-plots-wrapper');

            update();
            renderMathInElement(document.getElementById('wiener-process-app'), {
                delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
            });
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('x0', state.x0);
            params.set('m', state.m);
            params.set('sigma', state.sigma);
            params.set('T', state.T);
            params.set('barrier', state.barrier);
            history.replaceState(null, '', '#wiener-process?' + params.toString());
        }

        function update(options = {}) {
            state.x0 = parseFloat(document.getElementById('wp-x0').value);
            state.m = parseFloat(document.getElementById('wp-drift').value);
            state.sigma = parseFloat(document.getElementById('wp-volatility').value);
            state.T = parseFloat(document.getElementById('wp-terminal-time').value);
            state.barrier = parseFloat(document.getElementById('wp-barrier').value);

            if (isNaN(state.x0) || isNaN(state.m) || isNaN(state.sigma) || isNaN(state.T) || state.sigma <= 0 || state.T <= 0) {
                return;
            }

            const params = [
                { id: 'x0', name: 'Start Value X₀', symbol: 'X₀' },
                { id: 'drift', name: 'Drift m', symbol: 'm' },
                { id: 'volatility', name: 'Volatility σ', symbol: 'σ' },
                { id: 'terminal-time', name: 'Terminal Time T', symbol: 'T' },
                { id: 'barrier', name: 'Barrier b', symbol: 'b' }
            ];
            const quickContainers = ['wp-paths', 'wp-ht', 'wp-hpbb'];
            quickContainers.forEach(prefix => {
                const quickParamButtons = document.getElementById(`${prefix}-quick-param-buttons`);
                if (!quickParamButtons) return;
                quickParamButtons.innerHTML = '';
                params.forEach(p => {
                    const btn = document.createElement('button');
                    btn.id = `${prefix}-quick-btn-${p.id}`;
                    btn.innerHTML = p.symbol;
                    btn.dataset.param = p.id;
                    btn.dataset.prefix = prefix;
                    quickParamButtons.appendChild(btn);
                });
            });

            updatePathsPlot();
            updateHittingTimePlots();
            updateHittingProbByBarrierPlot();

            const values = { x0: state.x0, drift: state.m, volatility: state.sigma, 'terminal-time': state.T, barrier: state.barrier };
            quickContainers.forEach(prefix => {
                 params.forEach(p => {
                    const btn = document.getElementById(`${prefix}-quick-btn-${p.id}`);
                    if (btn) {
                        const input = document.getElementById(`wp-${p.id}`);
                        const step = parseFloat(input.getAttribute('step'));
                        const precision = (() => { if (!step || String(step).indexOf('.') === -1) return 0; return String(step).split('.')[1].length; })();
                        btn.innerHTML = `${p.symbol} = ${values[p.id].toFixed(precision)}`;
                    }
                });
            });

            if (!options.fromURL) {
                updateURL();
            }
        }

        function drawSamplePaths(count) {
            const dt = state.T / 100;
            const drift_term = state.m * dt;
            const vol_term = state.sigma * Math.sqrt(dt);

            for (let i = 0; i < count; i++) {
                const path = [{t: 0, x: state.x0}];
                let current_x = state.x0;
                for (let j = 1; j <= 100; j++) {
                    const Z = jStat.normal.sample(0, 1);
                    current_x += drift_term + vol_term * Z;
                    path.push({ t: j * dt, x: current_x });
                }
                state.paths.push(path);
            }
            updatePathsPlot();
        }

        function updatePathsPlot() {
            const { x0, m, sigma, T } = state;
            const rect = pathsSvg.node().getBoundingClientRect();
            const marginalRect = marginalSvg.node().getBoundingClientRect();

            if (rect.width <= 0 || marginalRect.width <= 0) return;

            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            const marginalWidth = marginalRect.width - margin.right;

            if (width <= 0 || height <= 0) return;

            pathsSvg.selectAll("*").remove();
            marginalSvg.selectAll("*").remove();
            const g = pathsSvg.append("g")
                               .attr("transform", `translate(${margin.left},${margin.top})`);

            const timePoints = d3.range(0, T, T/100).concat(T);
            const meanPath = timePoints.map(t => x0 + m * t);
            const stdDevs = timePoints.map(t => sigma * Math.sqrt(t));

            const coneValue = document.getElementById('wp-cone-select').value;
            let z_score = 0;
            if (coneValue !== '0') {
                const p = parseFloat(coneValue.substring(1)) / 100;
                z_score = jStat.normal.inv(1 - (1-p)/2, 0, 1);
            }

            const lowerBound = meanPath.map((mean, i) => mean - z_score * stdDevs[i]);
            const upperBound = meanPath.map((mean, i) => mean + z_score * stdDevs[i]);

            const yDomain = d3.extent([
                ...lowerBound, ...upperBound,
                ...(state.paths.length > 0 ? state.paths.flatMap(path => path.map(p => p.x)) : [x0])
            ]);

            if (yDomain[0] === yDomain[1]) {
                 yDomain[0] -= 1; yDomain[1] += 1;
            }

            const xScale = d3.scaleLinear().domain([0, T]).range([0, width]);
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale));

            if (z_score > 0) {
                const coneData = timePoints.map((t, i) => ({ t, lower: lowerBound[i], upper: upperBound[i] }));
                const area = d3.area()
                    .x(d => xScale(d.t))
                    .y0(d => yScale(d.lower))
                    .y1(d => yScale(d.upper));
                g.append("path").datum(coneData).attr("class", "cone-area").attr("d", area);
            }

            g.append("path").datum(timePoints.map((t, i) => ({t, x: meanPath[i]})))
             .attr("class", "line-path").style("stroke", "black").style("stroke-dasharray", "4")
             .attr("d", d3.line().x(d => xScale(d.t)).y(d => yScale(d.x)));

            const line = d3.line().x(d => xScale(d.t)).y(d => yScale(d.x));
            g.selectAll(".sample-path").data(state.paths).enter()
             .append("path").attr("class", "sample-path").attr("d", line);

            const marginalG = marginalSvg.append("g")
                .attr("transform", `translate(0,${margin.top})`);

            const mu_T = x0 + m * T;
            const sigma_T = sigma * Math.sqrt(T);
            const terminalDist = jStat.normal(mu_T, sigma_T);

            const yValuesForDensity = d3.range(yDomain[0], yDomain[1], (yDomain[1] - yDomain[0]) / 100);
            const densityData = yValuesForDensity.map(y => ({ y: y, p: terminalDist.pdf(y) }));

            const maxDensity = d3.max(densityData, d => d.p) || 1;
            const marginalXScale = d3.scaleLinear().domain([0, maxDensity * 1.1]).range([0, marginalWidth]);

            if (state.paths.length > 0) {
                const terminalValues = state.paths.map(path => path[path.length - 1].x);
                const histogram = d3.histogram()
                    .domain(yScale.domain())
                    .thresholds(yScale.ticks(20))
                    (terminalValues);

                const histMax = d3.max(histogram, d => d.length) || 1;

                marginalG.selectAll(".histogram-bar")
                    .data(histogram)
                    .enter().append("rect")
                    .attr("class", "histogram-bar")
                    .attr("y", d => yScale(d.x1) + 1)
                    .attr("height", d => Math.max(0, yScale(d.x0) - yScale(d.x1) - 1))
                    .attr("x", 0)
                    .attr("width", d => marginalXScale(d.length * maxDensity / histMax));
            }

            marginalG.append("path")
                .datum(densityData)
                .attr("class", "line-path")
                .style("stroke", "#d9534f")
                .attr("d", d3.line()
                    .x(d => marginalXScale(d.p))
                    .y(d => yScale(d.y))
                );
        }

        function updateHittingTimePlots() {
            const { x0, m, sigma, T, barrier } = state;

            const a = barrier - x0;

            if (Math.abs(a) < 1e-9) {
                htDensitySvg.selectAll("*").remove();
                htProbSvg.selectAll("*").remove();
                return;
            }

            const htDensityPdf = t => {
                if (t <= 0) return 0;
                return (Math.abs(a) / (sigma * Math.sqrt(2 * Math.PI * t * t * t))) * Math.exp(-Math.pow(a - m * t, 2) / (2 * sigma * sigma * t));
            };

            const htProbCdf = t => {
                if (t <= 0) return 0;
                let eff_m = m, eff_a = a;
                if (eff_a < 0) {
                    eff_m = -m;
                    eff_a = -a;
                }
                const term1 = jStat.normal.cdf((eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                const expTerm = Math.exp(2 * eff_m * eff_a / (sigma * sigma));
                if (!isFinite(expTerm)) return term1;
                const term2 = expTerm * jStat.normal.cdf((-eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                return term1 + term2;
            };

            const plotTimePoints = d3.range(T/200, T, T/200);

            const densityData = plotTimePoints.map(t => ({t, p: htDensityPdf(t)}));
            plotOnSvg(htDensitySvg, densityData, [0, T], "Time (t)", "Density", null, document.getElementById('wp-ht-density-tooltip'), htDensityPdf);

            const probData = plotTimePoints.map(t => ({t, p: htProbCdf(t)}));
            plotOnSvg(htProbSvg, probData, [0, T], "Time (t)", "Probability", [0, 1], document.getElementById('wp-ht-prob-tooltip'), htProbCdf);
        }

        function updateHittingProbByBarrierPlot() {
            const { x0, m, sigma, T } = state;

            if (sigma <= 0 || T <= 0) {
                hpByBarrierSvg.selectAll("*").remove();
                return;
            }

            const hittingProbByBarrier = b => {
                const a = b - x0;
                if (Math.abs(a) < 1e-9) return 1.0;
                const t = T;

                let eff_m = m, eff_a = a;
                if (eff_a < 0) {
                    eff_m = -m;
                    eff_a = -a;
                }
                const term1 = jStat.normal.cdf((eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                const expTerm = Math.exp(2 * eff_m * eff_a / (sigma * sigma));
                if (!isFinite(expTerm)) return term1;
                const term2 = expTerm * jStat.normal.cdf((-eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                return term1 + term2;
            };

            const range_dev = 4 * sigma * Math.sqrt(T);
            const barrierDomain = [x0 - range_dev, x0 + range_dev];

            const plotBarrierPoints = d3.range(barrierDomain[0], barrierDomain[1], (barrierDomain[1] - barrierDomain[0])/200);

            const plotData = plotBarrierPoints.map(b => ({b, p: hittingProbByBarrier(b)}));

            plotBarrierProbOnSvg(hpByBarrierSvg, plotData, barrierDomain, "Barrier (b)", "Hitting Probability", [0, 1], document.getElementById('wp-hp-by-barrier-tooltip'), hittingProbByBarrier);
        }

        function plotOnSvg(svg, data, xDomain, xLabel, yLabel, yDomain = null, tooltipEl = null, yFunc = null) {
            const rect = svg.node().getBoundingClientRect();
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            if (width <= 0 || height <= 0) return;

            svg.selectAll("*").remove();
            const g = svg.append("g")
                         .attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);

            if (!yDomain) {
                const yMax = d3.max(data, d => d.p);
                yDomain = [0, isFinite(yMax) && yMax > 0 ? yMax * 1.1 : 1];
            }
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale).ticks(5));

            g.append("text").attr("x", width/2).attr("y", height + 35).style("text-anchor", "middle").text(xLabel);
            g.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left+15).attr("x", -height/2).style("text-anchor", "middle").text(yLabel);

            g.append("path").datum(data)
             .attr("class", "line-path").style("stroke", "steelblue")
             .attr("d", d3.line().x(d => xScale(d.t)).y(d => yScale(d.p)));

            if (!tooltipEl || !yFunc) return;

            const focus = g.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);

            const interactionRect = svg.append("rect")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .style("fill", "none")
                .style("pointer-events", "all")
                .style("touch-action", "none")
                .attr("width", width)
                .attr("height", height);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, svg.node().parentNode);
                tooltipEl.style.left = tipX + "px";
                tooltipEl.style.top = tipY + "px";

                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                if (x_val < xDomain[0] || x_val > xDomain[1]) return;
                const y_val = yFunc(x_val);

                focus.attr("cx", xScale(x_val)).attr("cy", yScale(y_val));
                tooltipEl.innerHTML = `t: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }

            interactionRect.on("mouseover", () => {
                focus.style("opacity", 1);
                tooltipEl.style.opacity = 1;
            }).on("mouseout", () => {
                focus.style("opacity", 0);
                tooltipEl.style.opacity = 0;
            }).on("mousemove", updateTooltip);

            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                    focus.style("opacity", 1);
                    tooltipEl.style.opacity = 1;
                }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                }
            });
            node.addEventListener('touchend', (event) => {
                if (event.touches.length === 0) {
                    focus.style("opacity", 0);
                    tooltipEl.style.opacity = 0;
                }
            });
        }

        function plotBarrierProbOnSvg(svg, data, xDomain, xLabel, yLabel, yDomain = null, tooltipEl = null, yFunc = null) {
            const rect = svg.node().getBoundingClientRect();
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            if (width <= 0 || height <= 0) return;

            svg.selectAll("*").remove();
            const g = svg.append("g")
                            .attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);

            if (!yDomain) {
                const yMax = d3.max(data, d => d.p);
                yDomain = [0, isFinite(yMax) && yMax > 0 ? yMax * 1.1 : 1];
            }
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale).ticks(5));

            g.append("text").attr("x", width/2).attr("y", height + 35).style("text-anchor", "middle").text(xLabel);
            g.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left+15).attr("x", -height/2).style("text-anchor", "middle").text(yLabel);

            g.append("path").datum(data)
             .attr("class", "line-path").style("stroke", "steelblue")
             .attr("d", d3.line().x(d => xScale(d.b)).y(d => yScale(d.p)));

            if (!tooltipEl || !yFunc) return;

            const focus = g.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);

            const interactionRect = svg.append("rect")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .style("fill", "none")
                .style("pointer-events", "all")
                .style("touch-action", "none")
                .attr("width", width)
                .attr("height", height);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, svg.node().parentNode);
                tooltipEl.style.left = tipX + "px";
                tooltipEl.style.top = tipY + "px";

                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                if (x_val < xDomain[0] || x_val > xDomain[1]) return;
                const y_val = yFunc(x_val);

                focus.attr("cx", xScale(x_val)).attr("cy", yScale(y_val));
                tooltipEl.innerHTML = `b: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }

            interactionRect.on("mouseover", () => {
                focus.style("opacity", 1);
                tooltipEl.style.opacity = 1;
            }).on("mouseout", () => {
                focus.style("opacity", 0);
                tooltipEl.style.opacity = 0;
            }).on("mousemove", updateTooltip);

            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                    focus.style("opacity", 1);
                    tooltipEl.style.opacity = 1;
                }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                }
            });
            node.addEventListener('touchend', (event) => {
                if (event.touches.length === 0) {
                    focus.style("opacity", 0);
                    tooltipEl.style.opacity = 0;
                }
            });
        }

        return {
            init: init,
            updateFromURL: (params) => {
                const paramMap = {
                    'x0': 'wp-x0',
                    'm': 'wp-drift',
                    'sigma': 'wp-volatility',
                    'T': 'wp-terminal-time',
                    'barrier': 'wp-barrier'
                };
                let needsUpdate = false;
                for (const [key, id] of Object.entries(paramMap)) {
                    if (params.has(key)) {
                        const input = document.getElementById(id);
                        if (input) {
                            input.value = params.get(key);
                            needsUpdate = true;
                        }
                    }
                }
                if (needsUpdate) {
                    update({ fromURL: true });
                }
            }
        };
    })();

    const expectedValueApp = (() => {
        let state = {
            rows: [
                { p: 0.5, x: 1, id: 0 },
                { p: 0.25, x: 2, id: 1 },
                { p: 0.25, x: 4, id: 2 }
            ],
            nextId: 3
        };

        function formatParam(value) {
            if (Math.abs(value) < 1e-9) return "0";
            const s = value.toPrecision(3);
            const parts = s.split('e');
            if (parts.length === 1) return s;
            return `${parts[0]}\\times 10^{${parts[1].replace('+', '')}}`;
        }

        const inputGrid = document.getElementById('ev-input-grid');
        const addRowBtn = document.getElementById('ev-add-row-btn');
        const normalizeBtn = document.getElementById('ev-normalize-btn');
        const uniformBtn = document.getElementById('ev-uniform-btn');
        const roundBtn = document.getElementById('ev-round-btn');
        const orderBtn = document.getElementById('ev-order-btn');
        const svg = d3.select("#ev-plot-svg");
        const overlaySelect = document.getElementById('ev-overlay-select');
        const mleParamsSpan = document.getElementById('ev-mle-params');
        const margin = { top: 30, right: 50, bottom: 40, left: 50 };

        function renderInputs() {
            // Using a document fragment for performance
            const fragment = document.createDocumentFragment();
            inputGrid.querySelectorAll('.input-row').forEach(row => row.remove());

            state.rows.forEach(row => {
                const rowEl = document.createElement('div');
                rowEl.className = 'input-row';
                rowEl.dataset.id = row.id;

                const pInput = document.createElement('input');
                pInput.type = 'number';
                pInput.className = 'prob-input';
                pInput.min = 0;
                pInput.max = 1;
                pInput.step = 0.01;
                pInput.value = isNaN(row.p) ? '' : row.p;
                pInput.placeholder = "Probability";
                pInput.addEventListener('input', (e) => handleInputChange(row.id, 'p', e.target.value));

                const xInput = document.createElement('input');
                xInput.type = 'number';
                xInput.className = 'value-input';
                xInput.value = isNaN(row.x) ? '' : row.x;
                xInput.placeholder = "Value";
                xInput.addEventListener('input', (e) => handleInputChange(row.id, 'x', e.target.value));

                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-row-btn';
                removeBtn.innerHTML = '🗑️';
                removeBtn.addEventListener('click', () => removeRow(row.id));

                rowEl.appendChild(pInput);
                rowEl.appendChild(xInput);
                rowEl.appendChild(removeBtn);
                fragment.appendChild(rowEl);
            });
            inputGrid.appendChild(fragment);
            validateAndPlot();
        }

        function handleInputChange(id, field, value) {
            const rowIndex = state.rows.findIndex(r => r.id === id);
            if (rowIndex !== -1) {
                state.rows[rowIndex][field] = value === '' ? NaN : parseFloat(value);
            }
            validateAndPlot();
        }

        function addRow() {
            state.rows.push({ p: NaN, x: NaN, id: state.nextId++ });
            renderInputs();
        }

        function removeRow(id) {
            if (state.rows.length <= 1) return;
            state.rows = state.rows.filter(r => r.id !== id);
            renderInputs();
        }

        function normalizeProbabilities() {
            const totalP = state.rows.reduce((sum, row) => sum + (isNaN(row.p) ? 0 : row.p), 0);
            if (totalP > 0) {
                state.rows.forEach(row => {
                    if (!isNaN(row.p)) {
                        row.p = row.p / totalP;
                    }
                });
            }
            renderInputs();
        }

        function setUniformProbabilities() {
            const n = state.rows.length;
            if (n > 0) {
                const uniformP = 1 / n;
                state.rows.forEach(row => {
                    row.p = uniformP;
                });
            }
            renderInputs();
        }

        function roundProbabilities() {
            if (state.rows.length === 0) return;

            let roundedProbs = state.rows.map(row => isNaN(row.p) ? 0 : parseFloat(row.p.toPrecision(2)));
            let sumRounded = roundedProbs.reduce((sum, p) => sum + p, 0);

            let diff = 1 - sumRounded;

            if (Math.abs(diff) > 1e-9) {
                // Find row with largest probability to adjust
                let maxP = -1;
                let maxIdx = -1;
                for (let i = 0; i < roundedProbs.length; i++) {
                    if (roundedProbs[i] > maxP) {
                        maxP = roundedProbs[i];
                        maxIdx = i;
                    }
                }
                if (maxIdx > -1) {
                    roundedProbs[maxIdx] += diff;
                }
            }

            state.rows.forEach((row, i) => {
                row.p = roundedProbs[i];
            });

            renderInputs();
        }

        function orderRowsByX() {
            state.rows.sort((a, b) => {
                const aX = isNaN(a.x) ? Infinity : a.x;
                const bX = isNaN(b.x) ? Infinity : b.x;
                return aX - bX;
            });
            renderInputs();
        }

        function validateAndPlot() {
            const totalP = state.rows.reduce((sum, row) => sum + (isNaN(row.p) ? 0 : row.p), 0);
            const isSumInvalid = Math.abs(totalP - 1) > 1e-9 && totalP > 0;

            inputGrid.querySelectorAll('.prob-input').forEach(input => {
                input.classList.toggle('error', isSumInvalid);
            });

            normalizeBtn.disabled = !isSumInvalid;

            if (Math.abs(totalP - 1) < 1e-9) {
                plotPMF();
            } else {
                 svg.selectAll("*").remove();
                 mleParamsSpan.innerHTML = '';
            }
        }

        function plotPMF() {
            svg.selectAll("*").remove();
            mleParamsSpan.innerHTML = '';
            const validRows = state.rows.filter(r => !isNaN(r.p) && !isNaN(r.x) && r.p > 0);
            if (validRows.length === 0) return;

            const rect = svg.node().getBoundingClientRect();
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            if (width <= 0 || height <= 0) return;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            const xValues = validRows.map(r => r.x);
            const xExtent = d3.extent(xValues);
            const xPadding = (xExtent[1] - xExtent[0]) * 0.1 || 1;
            const xDomain = [xExtent[0] - xPadding, xExtent[1] + xPadding];
            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);

            const pValues = validRows.map(r => r.p);
            const yMax = d3.max(pValues);
            const yScale = d3.scaleLinear().domain([0, yMax * 1.1]).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale).ticks(5));

            const barWidth = Math.max(1, Math.min(20, width / validRows.length / 4));
            g.selectAll(".bar")
                .data(validRows)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.x) - barWidth / 2)
                .attr("y", d => yScale(d.p))
                .attr("width", barWidth)
                .attr("height", d => height - yScale(d.p));

            const overlayDist = overlaySelect.value;
            if (overlayDist !== 'none') {
                let params, distConfig;
                const mean = validRows.reduce((sum, row) => sum + row.p * row.x, 0);

                if (overlayDist === 'normal') {
                    const variance = validRows.reduce((sum, row) => sum + row.p * Math.pow(row.x - mean, 2), 0);
                    params = { mu: mean, sigma: Math.sqrt(variance) };
                    distConfig = DISTRIBUTIONS.normal;
                } else if (overlayDist === 'exponential') {
                    if (mean > 0) {
                        params = { lambda: 1 / mean };
                        distConfig = DISTRIBUTIONS.exponential;
                    }
                } else if (overlayDist === 'lognormal') {
                    const logRows = validRows.filter(r => r.x > 0);
                    if (logRows.length > 0) {
                        const totalP = logRows.reduce((sum, row) => sum + row.p, 0);
                        const meanLog = logRows.reduce((sum, row) => sum + (row.p/totalP) * Math.log(row.x), 0);
                        const varianceLog = logRows.reduce((sum, row) => sum + (row.p/totalP) * Math.pow(Math.log(row.x) - meanLog, 2), 0);
                        params = { mu: meanLog, sigma: Math.sqrt(varianceLog) };
                        distConfig = DISTRIBUTIONS.lognormal;
                    }
                } else if (overlayDist === 'gamma') {
                    const positiveRows = validRows.filter(r => r.x > 0);
                    if (positiveRows.length > 0) {
                        const totalP = positiveRows.reduce((sum, row) => sum + row.p, 0);
                        const mean = positiveRows.reduce((sum, row) => sum + (row.p/totalP) * row.x, 0);
                        const variance = positiveRows.reduce((sum, row) => sum + (row.p/totalP) * Math.pow(row.x - mean, 2), 0);
                        if (variance > 0) {
                            params = {
                                alpha: Math.pow(mean, 2) / variance,
                                lambda: mean / variance
                            };
                            distConfig = DISTRIBUTIONS.gamma;
                        }
                    }
                } else if (overlayDist === 'pareto') {
                    const positiveRows = validRows.filter(r => r.x > 0);
                    if (positiveRows.length > 1) {
                        const xm = Math.min(...positiveRows.map(r => r.x));
                        const totalP = positiveRows.reduce((sum, row) => sum + row.p, 0);
                        const sum_log_x = positiveRows.reduce((sum, row) => sum + (row.p/totalP) * Math.log(row.x), 0);
                        if (isFinite(sum_log_x) && sum_log_x > Math.log(xm)) {
                            const alpha = 1 / (sum_log_x - Math.log(xm));
                            params = { xm, alpha };
                            distConfig = DISTRIBUTIONS.pareto;
                        }
                    }
                }

                if (params && distConfig) {
                    let paramsString;
                    if (overlayDist === 'normal') {
                        if (params.sigma > 0) paramsString = `\\mathcal{N}(\\mu=${formatParam(params.mu)}, \\sigma^2=${formatParam(params.sigma**2)})`;
                    } else if (overlayDist === 'exponential') {
                        paramsString = `\\text{Exp}(\\lambda=${formatParam(params.lambda)})`;
                    } else if (overlayDist === 'lognormal') {
                        if (params.sigma > 0) paramsString = `\\text{Lognormal}(\\mu=${formatParam(params.mu)}, \\sigma^2=${formatParam(params.sigma**2)})`;
                    } else if (overlayDist === 'gamma') {
                        paramsString = `\\text{Gamma}(\\alpha=${formatParam(params.alpha)}, \\lambda=${formatParam(params.lambda)})`;
                    } else if (overlayDist === 'pareto') {
                        paramsString = `\\text{Pareto}(x_m=${formatParam(params.xm)}, \\alpha=${formatParam(params.alpha)})`;
                    }
                    if (paramsString) {
                        katex.render(paramsString, mleParamsSpan, { throwOnError: false });
                    }

                    const jstat = distConfig.jStat(params);
                    const lineData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 200)
                        .map(x => ({ x: x, y: distConfig.pdfpmf(x, jstat, params) }));

                    const y2Max = d3.max(lineData, d => d.y);
                    const y2Scale = d3.scaleLinear().domain([0, y2Max * 1.1]).range([height, 0]);

                    g.append("g").attr("class", "y-axis-2 axis").attr("transform", `translate(${width}, 0)`).call(d3.axisRight(y2Scale).ticks(5));

                    g.append("path")
                        .datum(lineData)
                        .attr("class", "line-path")
                        .style("stroke", "#d9534f")
                        .attr("d", d3.line().x(d => xScale(d.x)).y(d => y2Scale(d.y)));
                }
            }

            const expectedValue = validRows.reduce((sum, row) => sum + row.p * row.x, 0);

            if (isFinite(expectedValue)) {
                g.append("line")
                    .attr("class", "expected-value-line")
                    .attr("x1", xScale(expectedValue))
                    .attr("x2", xScale(expectedValue))
                    .attr("y1", 0)
                    .attr("y2", height);

                g.append("text")
                    .attr("class", "expected-value-text")
                    .attr("x", xScale(expectedValue))
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .text(`E[X] = ${expectedValue.toFixed(4)}`);
            }
        }

        function init() {
            addRowBtn.addEventListener('click', addRow);
            renderMathInElement(document.getElementById('ev-input-grid'));
            normalizeBtn.addEventListener('click', normalizeProbabilities);
            uniformBtn.addEventListener('click', setUniformProbabilities);
            roundBtn.addEventListener('click', roundProbabilities);
            orderBtn.addEventListener('click', orderRowsByX);
            overlaySelect.addEventListener('change', validateAndPlot);
            const resizeObserver = new ResizeObserver(() => {
                setTimeout(validateAndPlot, 0);
            });
            const plotContainer = document.getElementById('ev-plot-container');
            if(plotContainer) {
                resizeObserver.observe(plotContainer);
            }
            renderInputs();
        }

        return {
            init: init,
            updateFromURL: () => { /* Not implemented yet, can be added later */ }
        };
    })();

    const informationValueApp = (() => {
        let state = {
            states: [
                { id: 0, name: 'S1', prob: 0.5 },
                { id: 1, name: 'S2', prob: 0.5 }
            ],
            actions: [
                { id: 0, name: 'A1' },
                { id: 1, name: 'A2' }
            ],
            payoffs: {
                0: { 0: 10, 1: 0 }, // state 0, action 0 and 1
                1: { 0: 0, 1: 20 }  // state 1, action 0 and 1
            },
            nextStateId: 2,
            nextActionId: 2
        };

        const tableContainer = document.getElementById('iv-table-container');
        const resultsGrid = document.getElementById('iv-results-grid');
        const svg = d3.select("#iv-plot-svg");
        const tooltip = d3.select("#iv-tooltip");
        const margin = { top: 30, right: 30, bottom: 40, left: 50 };

        function renderTable() {
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            
            // Actions header row
            if (state.actions.length > 0) {
                const trHeadActions = document.createElement('tr');
                trHeadActions.innerHTML = '<th colspan="2" style="border-top: 0; border-left: 0; background: transparent;"></th>';
                const thActions = document.createElement('th');
                thActions.colSpan = state.actions.length;
                thActions.textContent = 'Actions';
                thActions.style.textAlign = 'center';
                trHeadActions.appendChild(thActions);
                thead.appendChild(trHeadActions);
            }

            // Header row
            const trHead = document.createElement('tr');
            trHead.innerHTML = '<th>State</th><th>P(S)</th>';
            state.actions.forEach(action => {
                const th = document.createElement('th');
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.alignItems = 'center';

                const input = document.createElement('input');
                input.type = 'text';
                input.value = action.name;
                input.style.textAlign = 'left';
                input.addEventListener('change', e => {
                    action.name = e.target.value;
                });
                container.appendChild(input);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '&times;';
                removeBtn.style.background = 'none';
                removeBtn.style.border = 'none';
                removeBtn.style.cursor = 'pointer';
                removeBtn.addEventListener('click', () => removeAction(action.id));
                container.appendChild(removeBtn);
                th.appendChild(container);
                trHead.appendChild(th);
            });
            thead.appendChild(trHead);

            // State rows
            state.states.forEach(s => {
                const tr = document.createElement('tr');
                // State name
                let td = document.createElement('td');
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.alignItems = 'center';

                let input = document.createElement('input');
                input.type = 'text';
                input.value = s.name;
                input.style.textAlign = 'left';
                input.addEventListener('change', e => {
                    s.name = e.target.value;
                });
                container.appendChild(input);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '&times;';
                removeBtn.style.background = 'none';
                removeBtn.style.border = 'none';
                removeBtn.style.cursor = 'pointer';
                removeBtn.addEventListener('click', () => removeState(s.id));
                container.appendChild(removeBtn);
                td.appendChild(container);
                tr.appendChild(td);

                // Probability
                td = document.createElement('td');
                input = document.createElement('input');
                input.type = 'number';
                input.className = 'prob-input';
                input.min = 0; input.max = 1; input.step = 0.01;
                input.value = s.prob;
                input.addEventListener('input', e => {
                    s.prob = e.target.value === '' ? NaN : parseFloat(e.target.value);
                    calculateAndRender();
                });
                td.appendChild(input);
                tr.appendChild(td);

                // Payoffs
                state.actions.forEach(a => {
                    td = document.createElement('td');
                    input = document.createElement('input');
                    input.type = 'number';
                    input.value = state.payoffs[s.id]?.[a.id] ?? 0;
                     input.addEventListener('input', e => {
                        if (!state.payoffs[s.id]) state.payoffs[s.id] = {};
                        state.payoffs[s.id][a.id] = e.target.value === '' ? NaN : parseFloat(e.target.value);
                        calculateAndRender();
                    });
                    td.appendChild(input);
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            
            table.appendChild(thead);
            table.appendChild(tbody);
            tableContainer.innerHTML = '';
            tableContainer.appendChild(table);
        }

        function calculateAndRender() {
            const priors = state.states.map(s => s.prob);
            const totalP = priors.reduce((sum, p) => sum + (isNaN(p) ? 0 : p), 0);
            const isSumInvalid = Math.abs(totalP - 1) > 1e-9 && totalP > 0;

            tableContainer.querySelectorAll('.prob-input').forEach(input => {
                input.classList.toggle('error', isSumInvalid);
            });

            if (isSumInvalid || state.states.length < 2) {
                resultsGrid.innerHTML = '';
                svg.selectAll("*").remove();
                return;
            }

            const n = state.states.length;
            const m = state.actions.length;

            const V = state.actions.map(a => 
                state.states.map(s => state.payoffs[s.id]?.[a.id] ?? 0)
            );

            // EV without info
            const ev_actions = state.actions.map((a, j) => {
                return state.states.reduce((sum, s, i) => sum + (V[j][i] * s.prob), 0);
            });
            const ev_without = Math.max(...ev_actions);

            // EV with perfect info
            const ev_perfect_info_per_state = state.states.map((s, i) => {
                const best_payoff = Math.max(...state.actions.map((a, j) => V[j][i]));
                return s.prob * best_payoff;
            });
            const ev_with_pi = ev_perfect_info_per_state.reduce((sum, v) => sum + v, 0);
            const evpi = ev_with_pi - ev_without;

            // EVSI
            const accuracy_points = d3.range(0.5, 1.01, 0.01);
            const evsi_data = accuracy_points.map(a => {
                if (a < 1 / n) return {a, evsi: 0}; // information is useless
                if (Math.abs(a-1) < 1e-9) return {a, evsi: evpi};
                
                const L = new Array(n).fill(0).map(() => new Array(n).fill(0));
                for(let i = 0; i < n; i++) {
                    for(let j = 0; j < n; j++) {
                        L[i][j] = (i === j) ? a : (1 - a) / (n - 1);
                    }
                }

                const p_reports = new Array(n).fill(0);
                for (let j = 0; j < n; j++) {
                    for (let i = 0; i < n; i++) {
                        p_reports[j] += L[i][j] * priors[i];
                    }
                }
                
                let ev_with_si = 0;
                for (let j = 0; j < n; j++) { // for each report R_j
                    if (p_reports[j] < 1e-9) continue;
                    const posteriors = new Array(n).fill(0);
                    for (let k = 0; k < n; k++) { // for each state S_k
                        posteriors[k] = (L[k][j] * priors[k]) / p_reports[j];
                    }

                    const ev_actions_posterior = state.actions.map((act, l) => {
                        return posteriors.reduce((sum, post, k) => sum + V[l][k] * post, 0);
                    });

                    ev_with_si += p_reports[j] * Math.max(...ev_actions_posterior);
                }
                const evsi = ev_with_si - ev_without;
                return {a, evsi};
            });
            
            renderResults(ev_without, ev_with_pi, evpi);
            plotEVSI(evsi_data);
        }

        function renderResults(ev_without, ev_with_pi, evpi) {
            resultsGrid.innerHTML = `
                <div class="result-item"><h4>EV without Information</h4><em>The best action (column), in expectation, yields:</em><br /><span>${ev_without.toFixed(4)}</span></div>
                <div class="result-item"><h4>EV with Perfect Info</h4><em>The best action if you know the true state, yields in expectation:</em><br /><span>${ev_with_pi.toFixed(4)}</span></div>
                <div class="result-item"><h4>Value of Perfect Info (EVPI)</h4><em>The delta between EV with and without perfect information:</em><br /><span>${evpi.toFixed(4)}</span></div>
            `;
        }

        function plotEVSI(data) {
            svg.selectAll("*").remove();
            const rect = svg.node().getBoundingClientRect();
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            if (width <= 0 || height <= 0) return;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleLinear().domain([0.5, 1]).range([0, width]);
            const yMax = d3.max(data, d => d.evsi);
            const yScale = d3.scaleLinear().domain([0, yMax > 0 ? yMax * 1.1 : 1]).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale).ticks(5));

            g.append("text").attr("x", width / 2).attr("y", height + 35).style("text-anchor", "middle").text("Accuracy (a)");
            g.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left + 15).attr("x", -height / 2).style("text-anchor", "middle").text("EVSI");
            
            g.append("path").datum(data).attr("class", "line-path").attr("d", d3.line().x(d => xScale(d.a)).y(d => yScale(d.evsi)));
            
            const focus = g.append("circle").style("fill", "steelblue").attr("r", 4).style("opacity", 0);
            
            const interactionRect = svg.append("rect")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .style("fill", "none").style("pointer-events", "all")
                .attr("width", width).attr("height", height);

            const bisect = d3.bisector(d => d.a).left;

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, svg.node().parentNode);
                tooltip.style("left", tipX + "px").style("top", tipY + "px");

                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                const index = bisect(data, x_val, 1);
                const d0 = data[index - 1], d1 = data[index] || d0;
                const d = (x_val - d0.a > d1.a - x_val) ? d1 : d0;
                
                focus.attr("cx", xScale(d.a)).attr("cy", yScale(d.evsi));
                tooltip.html(`a: ${d.a.toFixed(2)}<br>EVSI: ${d.evsi.toFixed(4)}`);
            }

            interactionRect.on("mouseover", () => { focus.style("opacity", 1); tooltip.style("opacity", 1); })
                .on("mouseout", () => { focus.style("opacity", 0); tooltip.style("opacity", 0); })
                .on("mousemove", updateTooltip);
        }

        function addState() {
            const newId = state.nextStateId++;
            state.states.push({ id: newId, name: `S${state.states.length+1}`, prob: 0});
            state.payoffs[newId] = {};
            state.actions.forEach(a => state.payoffs[newId][a.id] = 0);
            renderTable();
            calculateAndRender();
        }

        function removeState(id) {
            if (state.states.length <= 1) return;
            state.states = state.states.filter(s => s.id !== id);
            delete state.payoffs[id];
            renderTable();
            calculateAndRender();
        }

        function addAction() {
            const newId = state.nextActionId++;
            state.actions.push({ id: newId, name: `A${state.actions.length+1}` });
            Object.values(state.payoffs).forEach(p => p[newId] = 0);
            renderTable();
            calculateAndRender();
        }

        function removeAction(id) {
            if (state.actions.length <= 1) return;
            state.actions = state.actions.filter(a => a.id !== id);
            Object.values(state.payoffs).forEach(p => delete p[id]);
            renderTable();
            calculateAndRender();
        }

        return {
            init: () => {
                document.getElementById('iv-add-state-btn').addEventListener('click', addState);
                document.getElementById('iv-add-action-btn').addEventListener('click', addAction);
                renderTable();
                calculateAndRender();

                const resizeObserver = new ResizeObserver(() => {
                    setTimeout(calculateAndRender, 0);
                });
                const plotContainer = document.getElementById('iv-plot-container');
                if (plotContainer) {
                    resizeObserver.observe(plotContainer);
                }
                renderMathInElement(document.getElementById('information-value-app'), {
                    delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                });
            },
            updateFromURL: () => {}
        };
    })();

    let deferredPrompt;
    const installButton = document.getElementById('install-button');

    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
        if (installButton) {
            installButton.style.display = 'inline-flex';
            installButton.disabled = true;
        }
    }

    window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent Chrome 67 and earlier from automatically showing the prompt
        e.preventDefault();
        // Stash the event so it can be triggered later.
        deferredPrompt = e;
        // Update UI to notify the user they can add to home screen
        if (installButton) {
            installButton.style.display = 'inline-flex';
            installButton.disabled = false;
        }
    });

    if (installButton) {
        installButton.addEventListener('click', async () => {
            if (deferredPrompt) {
                // Show the prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                // We've used the prompt, and can't use it again, throw it away
                deferredPrompt = null;
                if (outcome === 'accepted') {
                    installButton.disabled = true;
                } else {
                    installButton.style.display = 'none';
                }
            }
        });
    }

    // Main App Router and Controls
    const menuBtn = document.getElementById('menu-btn');
    const menu = document.getElementById('menu');
    const appContainers = {
        distributions: document.getElementById('distributions-app'),
        'order-statistics': document.getElementById('order-statistics-app'),
        'gaussian-copula': document.getElementById('gaussian-copula-app'),
        'wiener-process': document.getElementById('wiener-process-app'),
        bernoulli: document.getElementById('bernoulli-app'),
        'expected-value': document.getElementById('expected-value-app'),
        'information-value': document.getElementById('information-value-app'),
        about: document.getElementById('about-app'),
        install: document.getElementById('install-app')
    };
    const appModules = {
        distributions: distributionsApp,
        'order-statistics': orderStatisticsApp,
        'gaussian-copula': gaussianCopulaApp,
        'wiener-process': wienerProcessApp,
        bernoulli: bernoulliApp,
        'expected-value': expectedValueApp,
        'information-value': informationValueApp
    };
    const initializedApps = { distributions: false, 'order-statistics': false, 'gaussian-copula': false, 'wiener-process': false, bernoulli: false, 'expected-value': false, 'information-value': false };
    const appTitles = {
        distributions: 'Distributions',
        'order-statistics': 'Order Statistics',
        'gaussian-copula': 'Gaussian Copula',
        'wiener-process': 'Wiener Process',
        bernoulli: 'Correlated Bernoulli',
        'expected-value': 'Expected Value',
        'information-value': 'Information Value',
        about: 'About',
        install: 'Install on device'
    };

    menuBtn.addEventListener('click', () => {
        menu.classList.toggle('visible');
    });

    document.body.addEventListener('click', (e) => {
        if (!menu.contains(e.target) && !menuBtn.contains(e.target) && menu.classList.contains('visible')) {
            menu.classList.remove('visible');
        }
    });

    menu.addEventListener('click', () => menu.classList.remove('visible'));

    function router() {
        const hash = window.location.hash || '#distributions';
        const [appNameWithHash, queryString] = hash.split('?');
        const appName = appNameWithHash.substring(1);
        const params = new URLSearchParams(queryString);

        Object.values(appContainers).forEach(c => c.classList.remove('active'));

        if (!appContainers[appName]) {
            appName = 'distributions'
        }
        const title = `Probly: ${appTitles[appName]}`;
        document.title = title;
        document.getElementById('app-title-bar').textContent = title;
        appContainers[appName].classList.add('active');
        if (appModules[appName] && !initializedApps[appName]) {
            appModules[appName].init();
            initializedApps[appName] = true;
        }
        if (appModules[appName]) {
            appModules[appName].updateFromURL(params);
        }
    }

    window.addEventListener('hashchange', router);
    router();
});
</script>

</body>
</html>
