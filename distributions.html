<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probability Distribution Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        :root { --panel-bg: #f9f9f9; --border-color: #ccc; --accent-color: steelblue; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto auto 1fr;
            grid-template-areas:
                "controls plot"
                "stats    plot"
                "sampling plot";
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: auto;
            min-height: 100vh;
        }
        .panel { padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--panel-bg); }
        #controls-panel { grid-area: controls; }
        #stats-panel { grid-area: stats; }
        #sampling-panel { grid-area: sampling; }
        #plot-container { grid-area: plot; padding: 0; display: flex; flex-direction: column; min-height: 400px; position: relative; }
        h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        .param-group, .control-group { margin-bottom: 15px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        input, select, button { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        button { background-color: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 0.9em; }
        #stats-grid span { font-weight: bold; color: #333; }
        #formula-display { margin-top: 20px; padding: 10px; background: #eee; border-radius: 3px; text-align: center; min-height: 50px; display: flex; align-items: center; justify-content: center; overflow-x: auto;}
        #plot-svg { flex-grow: 1; user-select: none; }
        .axis path, .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
        .line-path { fill: none; stroke: var(--accent-color); stroke-width: 2px; }
        .area-path { fill: var(--accent-color); opacity: 0.3; }
        .bar { fill: var(--accent-color); }
        #tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(10px, -25px); }
        .sample-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        #sample-clear-btn { grid-column: 1 / -1; background-color: #6c757d; }
        #sample-clear-btn:hover { background-color: #5a6268; }
        #samples-output { background: #e9ecef; padding: 10px; border-radius: 3px; height: 150px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; word-break: break-all; }
        .drag-selection { fill: rgba(255, 165, 0, 0.4); stroke: rgba(255, 165, 0, 1); stroke-width: 1px; }
        .drag-text { font-size: 12px; font-weight: bold; fill: #d9534f; text-anchor: middle; }
        #shading-controls { display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px; }

        @media (max-width: 800px) {
            body { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "stats" "sampling" "plot"; }
            #stats-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div id="controls-panel" class="panel">
        <h3>Controls</h3>
        <div class="control-group">
            <label for="dist-select">Distribution</label>
            <select id="dist-select"></select>
        </div>
        <div id="param-inputs"></div>
        <div id="formula-display"></div>
    </div>

    <div id="stats-panel" class="panel">
        <h3>Summary Statistics</h3>
        <div id="stats-grid">
            <div>Mean: <span id="stat-mean"></span></div>
            <div>Variance: <span id="stat-variance"></span></div>
            <div>Std. Dev: <span id="stat-stddev"></span></div>
            <div>25th %ile: <span id="stat-q1"></span></div>
            <div>Median: <span id="stat-median"></span></div>
            <div>75th %ile: <span id="stat-q3"></span></div>
            <div>50% Interval: <span id="stat-int50"></span></div>
            <div>90% Interval: <span id="stat-int90"></span></div>
            <div>95% Interval: <span id="stat-int95"></span></div>
            <div>99% Interval: <span id="stat-int99"></span></div>
        </div>
    </div>

    <div id="sampling-panel" class="panel">
        <h3>Sampling</h3>
        <div class="sample-buttons">
            <button id="sample-btn-1">Generate 1 Sample</button>
            <button id="sample-btn-10">Generate 10 Samples</button>
            <button id="sample-clear-btn">Clear</button>
        </div>
        <div id="samples-output"></div>
    </div>

    <div id="plot-container" class="panel">
        <div id="shading-controls">
            <div class="control-group">
                <label for="interval-select">Shade Interval</label>
                <select id="interval-select">
                    <option value="0">None</option>
                    <option value="p50">50%</option>
                    <option value="p90">90%</option>
                    <option value="p95" selected>95%</option>
                    <option value="p99">99%</option>
                    <option value="s1">+/- 1σ</option>
                    <option value="s2">+/- 2σ</option>
                    <option value="s3">+/- 3σ</option>
                </select>
            </div>
        </div>
        <svg id="plot-svg"></svg>
        <div id="param-sliders" style="padding: 10px 20px 0;"></div>
        <div id="tooltip"></div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const discreteInv = (prob, cdf, params) => {
        if (prob <= 0) return params.min !== undefined ? params.min : 0;
        const maxK = params.n !== undefined ? params.n : (params.max !== undefined ? params.max : Math.max(40, params.lambda * 4));
        if (prob >= 1) return maxK;
        let k = params.min !== undefined ? params.min : 0;
        while (cdf(k) < prob) {
            k++;
            if (k > maxK * 2) return Infinity;
        }
        return k;
    };

    const DISTRIBUTIONS = {
        normal: { name: 'Normal', type: 'continuous', params: [{ id: 'mu', name: 'μ (Mean)', default: 0, step: 0.1 }, { id: 'sigma', name: 'σ (Std. Dev)', default: 1, min: 0.1, step: 0.1 }], jStat: p => jStat.normal(p.mu, p.sigma), domain: p => [p.mu - 4 * p.sigma, p.mu + 4 * p.sigma], formula: 'f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}', mean: p => p.mu, variance: p => p.sigma**2, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.normal.sample(p.mu, p.sigma) },
        lognormal: { name: 'Lognormal', type: 'continuous', params: [{ id: 'mu', name: 'μ (log-scale)', default: 0, step: 0.1 }, { id: 'sigma', name: 'σ (shape)', default: 1, min: 0.1, step: 0.1 }], jStat: p => jStat.lognormal(p.mu, p.sigma), domain: (p, j) => [0.001, j.inv(0.995)], formula: 'f(x) = \\frac{1}{x\\sigma\\sqrt{2\\pi}} e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}', mean: p => Math.exp(p.mu + p.sigma**2 / 2), variance: p => (Math.exp(p.sigma**2) - 1) * Math.exp(2 * p.mu + p.sigma**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.lognormal.sample(p.mu, p.sigma) },
        exponential: { name: 'Exponential', type: 'continuous', params: [ { id: 'lambda', name: 'λ (Rate)', default: 1, min: 0.0001, step: 0.0001 } ], jStat: p => jStat.exponential(p.lambda), domain: (p, j) => [0, j.inv(0.999)], formula: 'f(x; \\lambda) = \\lambda e^{-\\lambda x}', mean: p => 1 / p.lambda, variance: p => 1 / (p.lambda**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.exponential.sample(p.lambda) },
        gamma: { name: 'Gamma', type: 'continuous', params: [{ id: 'alpha', name: 'α (Shape)', default: 2, min: 0.1, step: 0.1 }, { id: 'beta', name: 'β (Rate)', default: 1, min: 0.1, step: 0.1 }], jStat: p => jStat.gamma(p.alpha, p.beta), domain: (p, j) => [0.001, j.inv(0.999)], formula: 'f(x; \\alpha,\\beta) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} x^{\\alpha-1}e^{-\\beta x}', mean: p => p.alpha / p.beta, variance: p => p.alpha / (p.beta**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.gamma.sample(p.alpha, p.beta) },
        beta: { name: 'Beta', type: 'continuous', params: [{ id: 'alpha', name: 'α (Shape)', default: 2, min: 0.1, step: 0.1 }, { id: 'beta', name: 'β (Shape)', default: 3, min: 0.1, step: 0.1 }], jStat: p => jStat.beta(p.alpha, p.beta), domain: p => [0, 1], formula: 'f(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{\\mathrm{B}(\\alpha, \\beta)}', mean: p => p.alpha / (p.alpha + p.beta), variance: p => (p.alpha * p.beta) / ((p.alpha + p.beta)**2 * (p.alpha + p.beta + 1)), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.beta.sample(p.alpha, p.beta) },
        pareto: { name: 'Pareto', type: 'continuous', params: [{ id: 'xm', name: 'xₘ (scale)', default: 1, min: 0.1, step: 0.1 }, { id: 'alpha', name: 'α (shape)', default: 2, min: 0.1, step: 0.1 }], jStat: p => jStat.pareto(p.xm, p.alpha), domain: (p, j) => [p.xm, j.inv(0.98)], formula: 'f(x) = \\frac{\\alpha x_m^\\alpha}{x^{\\alpha+1}}', mean: p => p.alpha > 1 ? (p.alpha * p.xm) / (p.alpha - 1) : Infinity, variance: p => p.alpha > 2 ? ((p.xm**2 * p.alpha) / ((p.alpha - 1)**2 * (p.alpha - 2))) : Infinity, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: null },
        weibull: { name: 'Weibull', type: 'continuous', params: [{ id: 'scale', name: 'λ (Scale)', default: 1, min: 0.1, step: 0.1 }, { id: 'shape', name: 'k (Shape)', default: 2, min: 0.1, step: 0.1 }], jStat: p => jStat.weibull(p.scale, p.shape), domain: (p, j) => [0.001, j.inv(0.999)], formula: 'f(x; k, \\lambda) = \\frac{k}{\\lambda}(\\frac{x}{\\lambda})^{k-1}e^{-(x/\\lambda)^k}', mean: p => p.scale * jStat.gammafn(1 + 1 / p.shape), variance: p => p.scale**2 * (jStat.gammafn(1 + 2 / p.shape) - (jStat.gammafn(1 + 1 / p.shape))**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.weibull.sample(p.scale, p.shape) },
        uniform: { name: 'Uniform (continuous)', type: 'continuous', params: [{ id: 'a', name: 'a (Min)', default: 0, step: 1 }, { id: 'b', name: 'b (Max)', default: 1, step: 1 }], jStat: p => jStat.uniform(p.a, p.b), domain: p => [p.a - (p.b-p.a)*0.1, p.b + (p.b-p.a)*0.1], formula: 'f(x) = \\frac{1}{b-a}', mean: p => (p.a + p.b) / 2, variance: p => (p.b - p.a)**2 / 12, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.uniform.sample(p.a, p.b) },
        discreteUniform: { name: 'Uniform (discrete)', type: 'discrete', params: [{ id: 'min', name: 'Min', default: 0, step: 1 }, { id: 'max', name: 'Max', default: 9, step: 1 }], jStat: p => ({}), domain: p => [p.min - 1, p.max + 1], formula: 'P(X=k) = \\frac{1}{n}', mean: p => (p.min + p.max) / 2, variance: p => ((p.max - p.min + 1)**2 - 1) / 12, pdfpmf: (x, j, p) => { const k = Math.round(x); return k >= p.min && k <= p.max ? 1 / (p.max - p.min + 1) : 0; }, cdf: (x, j, p) => { const k = Math.floor(x); if (k < p.min) return 0; if (k >= p.max) return 1; return (k - p.min + 1) / (p.max - p.min + 1); }, inv: (prob, j, p) => discreteInv(prob, (k) => DISTRIBUTIONS.discreteUniform.cdf(k, j, p), p), sampler: p => Math.floor(jStat.uniform.sample(p.min, p.max + 1)) },
        binomial: { name: 'Binomial', type: 'discrete', params: [{ id: 'n', name: 'n (Trials)', default: 20, min: 1, step: 1 }, { id: 'p', name: 'p (Probability)', default: 0.5, min: 0, max: 1, step: 0.01 }], jStat: p => ({}), domain: p => [-0.5, p.n + 0.5], formula: 'P(k; n,p) = \\binom{n}{k} p^k(1-p)^{n-k}', mean: p => p.n * p.p, variance: p => p.n * p.p * (1 - p.p), pdfpmf: (x, j, p) => jStat.binomial.pdf(Math.round(x), p.n, p.p), cdf: (x, j, p) => jStat.binomial.cdf(Math.round(x), p.n, p.p), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.binomial.cdf(k, p.n, p.p), p), sampler: null },
        negativeBinomial: { name: 'Negative Binomial', type: 'discrete', params: [{ id: 'r', name: 'r (Successes)', default: 10, min: 1, step: 1 }, { id: 'p', name: 'p (Probability)', default: 0.5, min: 0.01, max: 1, step: 0.01 }], jStat: p => ({}), domain: (p, j) => [-0.5, discreteInv(0.9999, (k) => jStat.negbin.cdf(k, p.r, p.p), { ...p, min: 0 })], formula: 'P(k; r,p) = \\binom{k+r-1}{k} p^r(1-p)^{k}', mean: p => p.r * (1 - p.p) / p.p, variance: p => p.r * (1 - p.p) / (p.p**2), pdfpmf: (x, j, p) => jStat.negbin.pdf(Math.round(x), p.r, p.p), cdf: (x, j, p) => jStat.negbin.cdf(Math.round(x), p.r, p.p), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.negbin.cdf(k, p.r, p.p), { ...p, min: 0 }), sampler: null },
        hypergeometric: { name: 'Hypergeometric', type: 'discrete', params: [{ id: 'N', name: 'N (Population)', default: 50, min: 1, step: 1 }, { id: 'K', name: 'K (Successes in Pop.)', default: 10, min: 0, step: 1 }, { id: 'n', name: 'n (Sample Size)', default: 20, min: 1, step: 1 }], jStat: p => ({}), domain: p => [Math.max(0, p.n - p.N + p.K) - 1, Math.min(p.n, p.K) + 1], formula: 'P(X=k) = \\frac{\\binom{K}{k}\\binom{N-K}{n-k}}{\\binom{N}{n}}', mean: p => p.n * p.K / p.N, variance: p => p.n * (p.K / p.N) * (1 - p.K / p.N) * ((p.N - p.n) / (p.N - 1)), pdfpmf: (x, j, p) => jStat.hypgeom.pdf(Math.round(x), p.N, p.K, p.n), cdf: (x, j, p) => jStat.hypgeom.cdf(Math.round(x), p.N, p.K, p.n), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.hypgeom.cdf(k, p.N, p.K, p.n), { ...p, min: Math.max(0, p.n - (p.N - p.K)) }), sampler: null },
        poisson: { name: 'Poisson', type: 'discrete', params: [ { id: 'lambda', name: 'λ (Mean)', default: 5, min: 0.1, step: 0.1 } ], jStat: p => jStat.poisson(p.lambda), domain: (p, j) => [-0.5, Math.max(20, discreteInv(0.9999, (k) => jStat.poisson.cdf(k, p.lambda), p))], formula: 'P(k; \\lambda) = \\frac{\\lambda^k e^{-\\lambda}}{k!}', mean: p => p.lambda, variance: p => p.lambda, pdfpmf: (x, j, p) => jStat.poisson.pdf(Math.round(x), p.lambda), cdf: (x, j, p) => jStat.poisson.cdf(Math.round(x), p.lambda), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.poisson.cdf(k, p.lambda), p), sampler: p => jStat.poisson.sample(p.lambda) }
    };

    const distSelect = document.getElementById('dist-select');
    const paramInputs = document.getElementById('param-inputs');
    const paramSliders = document.getElementById('param-sliders');
    const formulaDisplay = document.getElementById('formula-display');
    const intervalSelect = document.getElementById('interval-select');
    const samplesOutput = document.getElementById('samples-output');
    const tooltip = document.getElementById('tooltip');
    const sampleBtn1 = document.getElementById('sample-btn-1');
    const sampleBtn10 = document.getElementById('sample-btn-10');

    let currentState = { distKey: 'normal', params: {}, jstat: null, samples: [] };

    const svg = d3.select("#plot-svg");
    const margin = { top: 20, right: 30, bottom: 40, left: 50 };
    let width, height;

    const xScale = d3.scaleLinear();
    const yScale = d3.scaleLinear();

    const xAxis = svg.append("g").attr("class", "x-axis axis");
    const yAxis = svg.append("g").attr("class", "y-axis axis");
    const plotArea = svg.append("g").attr("class", "plot-area");
    const dragLayer = svg.append("g").attr("class", "drag-layer");

    function init() {
        Object.keys(DISTRIBUTIONS).forEach(key => distSelect.appendChild(new Option(DISTRIBUTIONS[key].name, key)));
        distSelect.addEventListener('change', handleDistChange);
        paramInputs.addEventListener('input', update);
        intervalSelect.addEventListener('change', update);
        sampleBtn1.addEventListener('click', () => generateSamples(1));
        sampleBtn10.addEventListener('click', () => generateSamples(10));
        document.getElementById('sample-clear-btn').addEventListener('click', () => {
            samplesOutput.innerHTML = '';
            currentState.samples = [];
            if (currentState.jstat) updatePlot();
        });
        window.addEventListener('resize', () => { if (currentState.jstat) updatePlot(); });
        handleDistChange();
    }

    function handleDistChange() {
        currentState.distKey = distSelect.value;
        const config = DISTRIBUTIONS[currentState.distKey];
        paramInputs.innerHTML = '';
        paramSliders.innerHTML = '';

        config.params.forEach(p => {
            const group = document.createElement('div');
            group.className = 'param-group';
            group.innerHTML = `<label for="param-${p.id}">${p.name}</label><input type="number" id="param-${p.id}" data-param="${p.id}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}">`;
            paramInputs.appendChild(group);

            const sliderGroup = document.createElement('div');
            sliderGroup.className = 'param-group';
            sliderGroup.innerHTML = `
                <label for="slider-${p.id}" style="display: block; margin-bottom: 5px;">${p.name}: <span id="slider-val-${p.id}">${p.default}</span></label>
                <input type="range" id="slider-${p.id}" data-param="${p.id}" value="${p.default}" style="width: 100%;">`;
            paramSliders.appendChild(sliderGroup);

            const numberInput = document.getElementById(`param-${p.id}`);
            const sliderInput = document.getElementById(`slider-${p.id}`);
            const sliderValSpan = document.getElementById(`slider-val-${p.id}`);

            const getPrecision = (step) => {
                if (String(step).indexOf('.') === -1) return 0;
                return String(step).split('.')[1].length;
            };
            const precision = getPrecision(p.step);

            const updateSliderBounds = () => {
                const value = parseFloat(numberInput.value);
                if (isNaN(value) || !numberInput.checkValidity()) return;

                let sliderMin, sliderMax;
                if (value === 0) {
                    sliderMin = -1; sliderMax = 1;
                } else {
                    const logVal = Math.log10(Math.abs(value));
                    sliderMin = (value > 0 ? 1 : -1) * Math.pow(10, logVal - 1);
                    sliderMax = (value > 0 ? 1 : -1) * Math.pow(10, logVal + 1);
                    if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin];
                }

                const finalMin = Math.max(p.min ?? -Infinity, sliderMin);
                const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                sliderInput.min = finalMin;
                sliderInput.max = finalMax;

                if (p.step % 1 === 0) {
                    sliderInput.step = 1;
                    sliderInput.min = Math.ceil(finalMin);
                    sliderInput.max = Math.floor(finalMax);
                } else {
                    sliderInput.step = (finalMax - finalMin) / 200;
                }
            };

            numberInput.addEventListener('input', () => {
                const val = parseFloat(numberInput.value);
                if (!isNaN(val)) {
                    sliderInput.value = val;
                    sliderValSpan.textContent = val.toFixed(precision);
                }
            });
            numberInput.addEventListener('change', updateSliderBounds);

            sliderInput.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                numberInput.value = val.toFixed(precision);
                sliderValSpan.textContent = val.toFixed(precision);
                update();
            });
            sliderInput.addEventListener('change', updateSliderBounds);
            
            updateSliderBounds();
            sliderInput.value = numberInput.value;
        });
        katex.render(config.formula, formulaDisplay, { throwOnError: false, displayMode: true });
        update();
    }

    function generateSamples(count) {
        const sampler = DISTRIBUTIONS[currentState.distKey].sampler;
        if (!sampler) {
            samplesOutput.innerHTML = 'Sampling not supported for this distribution.';
            return;
        }
        const newSamples = Array.from({ length: count }, () => sampler(currentState.params));
        currentState.samples.push(...newSamples);

        const formattedSamples = newSamples.map(s => Number.isInteger(s) ? s : s.toFixed(4)).join('\n');
        if (samplesOutput.innerHTML.includes('not supported')) samplesOutput.innerHTML = '';
        samplesOutput.innerHTML += (samplesOutput.innerHTML ? '\n' : '') + formattedSamples;
        samplesOutput.scrollTop = samplesOutput.scrollHeight;
        updatePlot();
    }

    function update() {
        const config = DISTRIBUTIONS[currentState.distKey];
        const params = {};
        let allValid = true;
        config.params.forEach(p => {
            const input = document.getElementById(`param-${p.id}`);
            if (input.checkValidity()){ params[p.id] = parseFloat(input.value); }
            else { allValid = false; }
        });
        if (!allValid) return;
        currentState.params = params;
        currentState.jstat = config.jStat(params);

        const sampler = config.sampler;
        sampleBtn1.disabled = !sampler;
        sampleBtn10.disabled = !sampler;

        updateStats();
        updatePlot();
    }

    function updateStats() {
        const config = DISTRIBUTIONS[currentState.distKey];
        if (!currentState.jstat) return;

        const quantile = (prob) => config.inv(prob, currentState.jstat, currentState.params);
        const mean = config.mean(currentState.params);
        const variance = config.variance(currentState.params);

        document.getElementById('stat-mean').textContent = isFinite(mean) ? mean.toFixed(4) : '∞';
        document.getElementById('stat-variance').textContent = isFinite(variance) ? variance.toFixed(4) : '∞';
        document.getElementById('stat-stddev').textContent = isFinite(variance) ? Math.sqrt(variance).toFixed(4) : '∞';
        document.getElementById('stat-q1').textContent = quantile(0.25).toFixed(4);
        document.getElementById('stat-median').textContent = quantile(0.5).toFixed(4);
        document.getElementById('stat-q3').textContent = quantile(0.75).toFixed(4);

        const intervals = { '50': [quantile(0.25), quantile(0.75)], '90': [quantile(0.05), quantile(0.95)], '95': [quantile(0.025), quantile(0.975)], '99': [quantile(0.005), quantile(0.995)] };
        Object.entries(intervals).forEach(([key, val]) => {
            document.getElementById(`stat-int${key}`).textContent = `[${val[0].toFixed(2)}, ${val[1].toFixed(2)}]`;
        });
    }

    function updatePlot() {
        const config = DISTRIBUTIONS[currentState.distKey];
        const j = currentState.jstat;
        if (!j) return;

        document.getElementById('shading-controls').style.display = config.type === 'discrete' ? 'none' : 'flex';

        const svgRect = svg.node().getBoundingClientRect();
        width = svgRect.width - margin.left - margin.right;
        height = svgRect.height - margin.top - margin.bottom;
        plotArea.attr("transform", `translate(${margin.left},${margin.top})`);
        dragLayer.attr("transform", `translate(${margin.left},${margin.top})`);

        const xDomain = config.domain(currentState.params, j);
        xScale.domain(xDomain).range([0, width]);
        xAxis.attr("transform", `translate(${margin.left}, ${height + margin.top})`).call(d3.axisBottom(xScale));

        let plotData, yMax;
        if (config.type === 'continuous') {
            plotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 500).map(x => ({ x: x, y: config.pdfpmf(x, j, currentState.params) }));
            yMax = d3.max(plotData, d => d.y);
        } else {
            plotData = d3.range(Math.floor(xDomain[0]), Math.ceil(xDomain[1])).map(x => ({ x: x, y: config.pdfpmf(x, j, currentState.params) }));
            yMax = d3.max(plotData, d => d.y);
        }
        yScale.domain([0, yMax * 1.1]).range([height, 0]);
        yAxis.attr("transform", `translate(${margin.left}, ${margin.top})`).call(d3.axisLeft(yScale).ticks(5));

        plotArea.selectAll("*").remove();
        dragLayer.selectAll("*").remove();

        const intervalValue = intervalSelect.value;
        if (config.type === 'continuous' && intervalValue !== '0') {
            const quantile = (prob) => config.inv(prob, j, currentState.params);
            let lower, upper;

            if (intervalValue.startsWith('p')) {
                const p = parseFloat(intervalValue.substring(1)) / 100;
                lower = quantile((1 - p) / 2);
                upper = quantile(1 - (1 - p) / 2);
            } else { // 's' for sigma
                const numSigmas = parseInt(intervalValue.substring(1));
                const mean = config.mean(currentState.params);
                const stddev = Math.sqrt(config.variance(currentState.params));
                if(isFinite(stddev)) {
                    lower = mean - numSigmas * stddev;
                    upper = mean + numSigmas * stddev;
                }
            }

            if (lower !== undefined) {
                const area = d3.area().x(d => xScale(d.x)).y0(height).y1(d => yScale(d.y));
                plotArea.append("path").datum(plotData.filter(d => d.x >= lower && d.x <= upper)).attr("class", "area-path").attr("d", area);
            }
        }

        if (config.type === 'continuous') {
            plotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)));
        } else {
            plotArea.selectAll(".bar-main").data(plotData.filter(d => d.y > 0)).enter().append("rect").attr("class", "bar").attr("x", d => xScale(d.x - 0.4)).attr("y", d => yScale(d.y)).attr("width", Math.max(1, xScale(0.8) - xScale(0))).attr("height", d => height - yScale(d.y));
        }

        plotArea.selectAll(".sample-dot")
            .data(currentState.samples)
            .enter().append("circle")
            .attr("class", "sample-dot")
            .attr("cx", d => xScale(d))
            .attr("cy", height)
            .attr("r", 3)
            .attr("fill", "black");

        setupInteractionLayer();
    }

    function setupInteractionLayer() {
        const config = DISTRIBUTIONS[currentState.distKey];
        const focus = plotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
        let dragState = { startX: null, isDragging: false };
        let touchDragState = {};

        const interactionRect = svg.append("rect")
            .attr("transform", `translate(${margin.left},${margin.top})`)
            .style("fill", "none").style("pointer-events", "all")
            .style("touch-action", "none")
            .attr("width", width).attr("height", height);

        function calculateAndDisplayArea(pixel1, pixel2) {
            if (Math.abs(pixel1 - pixel2) < 5) {
                dragLayer.selectAll("*").remove();
                return;
            }
            const x0 = xScale.invert(pixel1);
            const x1 = xScale.invert(pixel2);
            const lower = Math.min(x0, x1), upper = Math.max(x0, x1);

            let area, text;
            if (config.type === 'discrete') {
                const lowerBound = Math.ceil(lower), upperBound = Math.floor(upper);
                if (upperBound < lowerBound) { area = 0; }
                else { area = config.cdf(upperBound, currentState.jstat, currentState.params) - config.cdf(lowerBound - 1, currentState.jstat, currentState.params); }
                text = `P(${lowerBound} ≤ X ≤ ${upperBound}) = ${area.toFixed(4)}`;
            } else {
                area = config.cdf(upper, currentState.jstat, currentState.params) - config.cdf(lower, currentState.jstat, currentState.params);
                text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`;
            }

            dragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
        }

        const drag = d3.drag()
            .filter(event => !event.touches) // Mouse only
            .on("start", (event) => {
                const [x_coord] = d3.pointer(event, interactionRect.node());
                dragState.isDragging = true;
                dragState.startX = x_coord;
                dragLayer.selectAll("*").remove();
                dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height);
                tooltip.style.opacity = 0;
            })
            .on("drag", (event) => {
                const [currentX] = d3.pointer(event, interactionRect.node());
                const x = Math.min(dragState.startX, currentX);
                const w = Math.abs(currentX - dragState.startX);
                dragLayer.select(".drag-selection").attr("x", x).attr("width", w);
            })
            .on("end", (event) => {
                dragState.isDragging = false;
                const [endX, endY] = d3.pointer(event, interactionRect.node());
                if (endX >= 0 && endX <= width && endY >= 0 && endY <= height) {
                    tooltip.style.opacity = 1;
                }
                calculateAndDisplayArea(dragState.startX, endX);
            });

        interactionRect.call(drag);

        function updateTooltip(event) {
            const [tipX, tipY] = d3.pointer(event, document.getElementById('plot-container'));
            tooltip.style.left = tipX + "px";
            tooltip.style.top = tipY + "px";
            const [x_coord] = d3.pointer(event, interactionRect.node());
            const x_val = xScale.invert(x_coord);
            let y_val, display_x = x_val;
            if (config.type === 'continuous') {
                y_val = config.pdfpmf(x_val, currentState.jstat, currentState.params);
            } else {
                display_x = Math.round(x_val);
                y_val = config.pdfpmf(display_x, currentState.jstat, currentState.params);
            }
            focus.attr("cx", xScale(display_x)).attr("cy", yScale(y_val));
            tooltip.innerHTML = `x: ${display_x.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
        }

        interactionRect
            .on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); tooltip.style.opacity = 1; }})
            .on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); tooltip.style.opacity = 0; }})
            .on("mousemove", (event) => {
                if (dragState.isDragging) return;
                updateTooltip(event);
            });

        const node = interactionRect.node();

        node.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                touchDragState.isDragging = true;
                const pointers = d3.pointers(event, node);
                touchDragState.x1 = pointers[0][0];
                touchDragState.x2 = pointers[1][0];
                dragLayer.selectAll("*").remove();
                dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height);
                tooltip.style.opacity = 0; focus.style.opacity = 0;
                const x = Math.min(touchDragState.x1, touchDragState.x2);
                const w = Math.abs(touchDragState.x1 - touchDragState.x2);
                dragLayer.select(".drag-selection").attr("x", x).attr("width", w);
            } else if (event.touches.length === 1) {
                event.preventDefault();
                dragLayer.selectAll("*").remove();
                updateTooltip(event.touches[0]);
                focus.style.opacity = 1; tooltip.style.opacity = 1;
            }
        });

        node.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2 && touchDragState.isDragging) {
                event.preventDefault();
                const pointers = d3.pointers(event, node);
                touchDragState.x1 = pointers[0][0];
                touchDragState.x2 = pointers[1][0];
                const x = Math.min(touchDragState.x1, touchDragState.x2);
                const w = Math.abs(touchDragState.x1 - touchDragState.x2);
                dragLayer.select(".drag-selection").attr("x", x).attr("width", w);
            } else if (event.touches.length === 1 && !touchDragState.isDragging) {
                event.preventDefault();
                updateTooltip(event.touches[0]);
            }
        });

        node.addEventListener('touchend', (event) => {
            if (touchDragState.isDragging) {
                event.preventDefault();
                calculateAndDisplayArea(touchDragState.x1, touchDragState.x2);
                touchDragState = {};
            }
            if (event.touches.length === 0) {
                focus.style.opacity = 0;
                tooltip.style.opacity = 0;
            }
        });
    }

    init();
});
</script>

</body>
</html>
