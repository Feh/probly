<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probly</title>

    <link rel="manifest" href="/manifest.json">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
    <link rel="stylesheet" href="/assets/katex.min.css">
    <script defer src="/assets/katex.min.js"></script>
    <script defer src="/assets/auto-render.min.js"></script>
    <script src="/assets/numeric.min.js"></script>
    <script src="/assets/d3.v7.min.js"></script>
    <script src="/assets/jstat.min.js"></script>
    <script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                .then((registration) => {
                        console.log('Service Worker registered with scope:', registration.scope);
                        })
                .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                        });
                });
    }
    </script>

    <style>
        /* General and Layout Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #fdfdfd;
            color: #333;
            margin: 0;
        }
        header { display: flex; align-items: center; background-color: #f8f9fa; padding: 10px 20px; border-bottom: 1px solid #dee2e6; position: sticky; top: 0; z-index: 1001; }
        header h1 { margin: 0; font-size: 1.5rem; }
        #menu-btn { font-size: 1.5rem; background: none; border: none; cursor: pointer; margin-right: 15px; }
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 250px;
            background-color: white;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1002;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            box-sizing: border-box;
        }
        #menu.visible {
            transform: translateX(0);
        }
        .menu-header {
            height: 60px;
            display: flex;
            align-items: center;
            padding-left: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            border-bottom: 1px solid #dee2e6;
            box-sizing: border-box;
        }
        #menu ul { list-style: none; margin: 0; padding: 0; }
        #menu a { display: block; padding: 10px 20px; text-decoration: none; color: #333; }
        #menu a:hover { background-color: #f0f0f0; }
        .app-container { display: none; }
        .app-container.active { display: block; }
        #distributions-app.active, #order-statistics-app.active, #gaussian-copula-app.active, #wiener-process-app.active { display: grid; }

        /* Scoped styles for Correlated Bernoulli App */
        #bernoulli-app { max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        #bernoulli-app h2, #bernoulli-app h3 { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
        #bernoulli-app table { border-collapse: collapse; width: 100%; margin-bottom: 1.5rem; text-align: center; }
        #bernoulli-app th, #bernoulli-app td { border: 1px solid #ccc; padding: 0; }
        #bernoulli-app th { background-color: #f7f7f7; font-weight: normal; }
        #bernoulli-app td.label { background-color: #f7f7f7; font-weight: bold; }
        #bernoulli-app input[type="number"] { width: 100%; height: 100%; border: 2px solid transparent; padding: 10px; box-sizing: border-box; text-align: center; font-size: 1em; background-color: transparent; color: #888; }
        #bernoulli-app input.user-input { color: black; font-weight: bold; }
        #bernoulli-app input:focus { outline: none; border-color: #007bff; }
        #bernoulli-app .error { color: #d9534f !important; border-color: #d9534f !important; }
        #bernoulli-app .correlation-container { display: flex; align-items: center; gap: 10px; margin-bottom: 1.5rem; }
        #bernoulli-app .correlation-container label { font-weight: bold; }
        #bernoulli-app .correlation-container input { flex-grow: 1; }
        #bernoulli-app button { padding: 10px 15px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; border-radius: 4px; }
        #bernoulli-app button:hover { background-color: #e0e0e0; }
        #bernoulli-app details { margin-top: 2rem; border: 1px solid #ddd; border-radius: 4px; }
        #bernoulli-app summary { padding: 1rem; font-weight: bold; cursor: pointer; background-color: #f7f7f7; }
        #bernoulli-app .formulas { padding: 0 1rem 1rem 1rem; background-color: #fff; }
        #bernoulli-app #plots-container { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 20px; margin-top: 2rem; }
        #bernoulli-app .plot { border: 1px solid #ddd; padding: 10px; border-radius: 4px; }
        #bernoulli-app .plot-title { text-align: center; font-weight: bold; margin-bottom: 5px; font-size: 0.9em; }
        #bernoulli-app .variable-names-container { margin-top: 1rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        #bernoulli-app .variable-names-container input { padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; }

        /* Scoped styles for Distributions App */
        #distributions-app {
            --panel-bg: #f9f9f9; --border-color: #ccc; --accent-color: steelblue;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto auto 1fr;
            grid-template-areas: "controls plot" "stats plot" "sampling plot";
            gap: 20px; padding: 20px; max-width: 1400px; margin: auto;
        }
        #distributions-app .panel { padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--panel-bg); }
        #distributions-app #controls-panel { grid-area: controls; }
        #distributions-app #stats-panel { grid-area: stats; }
        #distributions-app #sampling-panel { grid-area: sampling; }
        #distributions-app #plot-container { grid-area: plot; padding: 0; display: flex; flex-direction: column; position: relative; }
        #distributions-app h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        #distributions-app .param-group, #distributions-app .control-group { margin-bottom: 15px; }
        #distributions-app label { display: block; font-weight: bold; margin-bottom: 5px; }
        #distributions-app input, #distributions-app select, #distributions-app button { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #distributions-app button { background-color: #007bff; color: white; border: none; cursor: pointer; }
        #distributions-app button:hover { background-color: #0056b3; }
        #distributions-app button:disabled { background-color: #ccc; cursor: not-allowed; }
        #distributions-app #stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 0.9em; }
        #distributions-app #stats-grid span { font-weight: bold; color: #333; }
        #distributions-app #formula-display { margin-top: 20px; padding: 10px; background: #eee; border-radius: 3px; text-align: center; min-height: 50px; display: flex; align-items: center; justify-content: center; overflow-x: auto;}
        #distributions-app .plot-svg-wrapper { position: relative; resize: both; overflow: auto; flex-grow: .5; display: flex; }
        #distributions-app #plot-svg { user-select: none; width: 100%; height: 100%; }
        #distributions-app .axis path, #distributions-app .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
        #distributions-app .line-path { fill: none; stroke: var(--accent-color); stroke-width: 2px; }
        #distributions-app .area-path { fill: var(--accent-color); opacity: 0.3; }
        #distributions-app .bar { fill: var(--accent-color); }
        #distributions-app #tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #distributions-app .sample-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        #distributions-app #sample-clear-btn { grid-column: 1 / -1; background-color: #6c757d; }
        #distributions-app #sample-clear-btn:hover { background-color: #5a6268; }
        #distributions-app #samples-output { background: #e9ecef; padding: 10px; border-radius: 3px; height: 150px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; word-break: break-all; }
        #distributions-app .drag-selection { fill: rgba(255, 165, 0, 0.4); stroke: rgba(255, 165, 0, 1); stroke-width: 1px; }
        #distributions-app .drag-text { font-size: 12px; font-weight: bold; fill: #d9534f; text-anchor: middle; }
        #distributions-app #shading-controls { display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px; }

        /* Scoped styles for Order Statistics App */
        #order-statistics-app {
            --panel-bg: #f9f9f9; --border-color: #ccc; --accent-color: steelblue;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas: "controls plot" "stats plot";
            gap: 20px; padding: 20px; max-width: 1400px; margin: auto;
        }
        #order-statistics-app .panel { padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--panel-bg); }
        #order-statistics-app #os-controls-panel { grid-area: controls; }
        #order-statistics-app #os-stats-panel { grid-area: stats; }
        #order-statistics-app #os-plot-container { grid-area: plot; padding: 0; display: flex; flex-direction: column; position: relative; }
        #order-statistics-app h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        #order-statistics-app .param-group, #order-statistics-app .control-group { margin-bottom: 15px; }
        #order-statistics-app label { display: block; font-weight: bold; margin-bottom: 5px; }
        #order-statistics-app input, #order-statistics-app select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #order-statistics-app #os-stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 0.9em; }
        #order-statistics-app #os-stats-grid span { font-weight: bold; color: #333; }
        #order-statistics-app .plot-svg-wrapper { position: relative; resize: both; overflow: auto; flex-grow: 1; display: flex; }
        #order-statistics-app #os-plot-svg { user-select: none; width: 100%; height: 100%; }
        #order-statistics-app .axis path, #order-statistics-app .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
        #order-statistics-app .line-path { fill: none; stroke: var(--accent-color); stroke-width: 2px; }
        #order-statistics-app .area-path { fill: var(--accent-color); opacity: 0.3; }
        #order-statistics-app #os-tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #order-statistics-app .drag-selection { fill: rgba(255, 165, 0, 0.4); stroke: rgba(255, 165, 0, 1); stroke-width: 1px; }
        #order-statistics-app .drag-text { font-size: 12px; font-weight: bold; fill: #d9534f; text-anchor: middle; }
        #order-statistics-app details.panel { grid-column: 1 / -1; }
        #order-statistics-app details > summary { font-weight: bold; cursor: pointer; }
        #order-statistics-app details .formulas { padding-top: 1rem; }

        /* Scoped styles for Gaussian Copula App */
        #gaussian-copula-app {
            --panel-bg: #f9f9f9; --border-color: #ccc; --accent-color: steelblue;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto;
            grid-template-areas: "controls plots";
            gap: 20px; padding: 20px; max-width: 1400px; margin: auto;
        }
        #gaussian-copula-app .panel { padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--panel-bg); }
        #gaussian-copula-app #gc-controls-panel { grid-area: controls; }
        #gaussian-copula-app #gc-formulas-panel { grid-column: 1 / -1; }
        #gaussian-copula-app #gc-plots-panel { grid-area: plots; display: flex; flex-direction: column; gap: 20px; padding: 0; border: none; background: transparent; }
        #gaussian-copula-app .gc-plot-container { padding: 0; display: flex; flex-direction: column; position: relative; }
        #gaussian-copula-app #gc-scatter-plot-container { min-height: 530px; }
        #gaussian-copula-app #gc-joint-plot-grid { flex-grow: 1; display: grid; grid-template-areas: "marg-x corner" "scatter marg-y"; grid-template-columns: 1fr 80px; grid-template-rows: 80px 1fr; gap: 5px; position: relative; resize: both; overflow: auto; }
        #gaussian-copula-app #gc-marginal-x-svg { grid-area: marg-x; }
        #gaussian-copula-app #gc-joint-plot-svg { grid-area: scatter; }
        #gaussian-copula-app #gc-marginal-y-svg { grid-area: marg-y; }
        #gaussian-copula-app #gc-joint-plot-grid svg { width: 100%; height: 100%; }
        #gaussian-copula-app .histogram-bar { fill: steelblue; opacity: 0.5; }
        #gaussian-copula-app h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        #gaussian-copula-app h4 { margin-top: 0; }
        #gaussian-copula-app .param-group, #gaussian-copula-app .control-group { margin-bottom: 15px; }
        #gaussian-copula-app label { display: block; font-weight: bold; margin-bottom: 5px; }
        #gaussian-copula-app input, #gaussian-copula-app select, #gaussian-copula-app button:not(.move-btn) { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #gaussian-copula-app button:not(.move-btn) { background-color: #007bff; color: white; border: none; cursor: pointer; }
        #gaussian-copula-app button:not(.move-btn):hover { background-color: #0056b3; }
        #gaussian-copula-app .sample-buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; margin-bottom: 10px; justify-content: center; }
        #gaussian-copula-app .sample-buttons button { width: auto; }
        #gaussian-copula-app #gc-sample-clear-btn { background-color: #6c757d; }
        #gaussian-copula-app #gc-sample-clear-btn:hover { background-color: #5a6268; }
        #gaussian-copula-app .plot-svg-wrapper { position: relative; resize: both; overflow: auto; flex-grow: 1; display: flex; }
        #gaussian-copula-app #gc-scatter-plot-svg { flex-grow: 1; user-select: none; }
        #gaussian-copula-app #gc-density-plot-svg { user-select: none; width: 100%; height: 100%; min-height: 300px; }
        #gaussian-copula-app .axis path, #gaussian-copula-app .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
        #gaussian-copula-app .scatter-dot { fill: lightblue; stroke: steelblue; opacity: 0.6; }
        #gaussian-copula-app .line-path { fill: none; stroke: #d9534f; stroke-width: 2px; }
        #gaussian-copula-app .area-path { fill: steelblue; opacity: 0.3; }
        #gaussian-copula-app #gc-density-tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #gaussian-copula-app .drag-selection { fill: rgba(255, 165, 0, 0.4); stroke: rgba(255, 165, 0, 1); stroke-width: 1px; }
        #gaussian-copula-app .drag-text { font-size: 12px; font-weight: bold; fill: #d9534f; text-anchor: middle; }
        #gaussian-copula-app .gc-conditional-controls-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: center; justify-content: center; padding: 10px 0; }
        #gaussian-copula-app .gc-conditional-controls-row .control-group { flex: 1 1 150px; margin: 10px; }

        /* Scoped styles for Wiener Process App */
        #wiener-process-app {
            --panel-bg: #f9f9f9; --border-color: #ccc; --accent-color: steelblue;
            grid-template-columns: 320px 1fr;
            grid-template-areas: "params plots";
            gap: 20px; padding: 20px; max-width: 1400px; margin: auto;
        }
        #wp-params-panel { grid-area: params; }
        #wp-plots-wrapper { grid-area: plots; display: flex; flex-direction: column; gap: 20px; min-width: 0; }
        #wiener-process-app .panel { position: relative; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--panel-bg); display: flex; flex-direction: column; }
        #wiener-process-app h3, #wiener-process-app h4 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        #wiener-process-app .control-group { margin-bottom: 15px; }
        #wiener-process-app label { font-weight: bold; margin-bottom: 5px; }
        #wiener-process-app input, #wiener-process-app select, #wiener-process-app button:not(.move-btn) { width: 8em; padding: 8px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 3px; }
        #wiener-process-app .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        #wiener-process-app .button-flex { justify-content: center; display: flex; gap: 20px; margin-top: 10px; }
        #wiener-process-app button:not(.move-btn) { background-color: #007bff; color: white; border: none; cursor: pointer; }
        #wiener-process-app button:not(.move-btn):hover { background-color: #0056b3; }
        #wiener-process-app #wp-clear-paths-btn { background-color: #6c757d; }
        #wiener-process-app #wp-clear-paths-btn:hover { background-color: #5a6268; }
        #wiener-process-app .wp-plot-container { min-height: 300px; position: relative; flex-grow: 1; resize: both; overflow: auto; display: flex; }
        #wiener-process-app #wp-paths-plot-grid { display: grid; grid-template-columns: 1fr 100px; grid-template-rows: 1fr; gap: 5px; }
        #wiener-process-app svg { width: 100%; height: 100%; }
        #wiener-process-app .axis path, #wiener-process-app .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
        #wiener-process-app .line-path { fill: none; stroke-width: 1.5px; }
        #wiener-process-app .cone-area { fill: var(--accent-color); opacity: 0.3; }
        #wiener-process-app .sample-path { fill: none; stroke: #555; stroke-width: 1px; opacity: 0.6; }
        #wiener-process-app .wp-tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 5px 10px; border-radius: 3px; pointer-events: none; opacity: 0; font-size: 0.9em; z-index: 10; transform: translate(-9em, -25px); }
        #wiener-process-app .histogram-bar { fill: steelblue; opacity: 0.5; }
        #wiener-process-app details.panel { grid-column: 1 / -1; }
        #wiener-process-app details > summary { font-weight: bold; cursor: pointer; }
        #wiener-process-app details .formulas { padding-top: 1rem; }

        .move-controls { position: absolute; top: 5px; right: 5px; z-index: 5; display: flex; flex-direction: column; }
        .move-btn { background: none; border: none; cursor: pointer; font-size: 0.8rem; padding: 0; line-height: 1; color: #888; }
        .move-btn:hover { color: #333; }

        #menu .nav-divider {
            height: 1px;
            background-color: #dee2e6;
            margin: 10px 0;
        }
        #menu .nav-secondary-item a {
            font-size: 0.9em;
            color: #555;
        }
        #install-app {
            max-width: 600px;
            margin: 2rem auto;
            padding: 2rem;
            text-align: center;
        }
        #install-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        #install-button:hover {
            background-color: #0056b3;
        }
        #install-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #install-button .icon {
            width: 24px;
            height: 24px;
        }
        #about-app {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        @media (max-width: 800px) {
            #distributions-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "stats" "sampling" "plot"; }
            #distributions-app #stats-grid { grid-template-columns: 1fr; }
            #order-statistics-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "stats" "plot"; }
            #order-statistics-app #os-stats-grid { grid-template-columns: 1fr; }
            #gaussian-copula-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "controls" "plots" "formulas"; }
            #wiener-process-app { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "params" "plots"; }
        }
    </style>
</head>
<body>
    <header>
        <button id="menu-btn">☰</button>
        <h1 id="app-title-bar">Probly</h1>
    </header>
    <nav id="menu">
        <div class="menu-header">Probly</div>
        <ul>
            <li><a href="#distributions">Distributions</a></li>
            <li><a href="#order-statistics">Order Statistics</a></li>
            <li><a href="#gaussian-copula">Gaussian Copula</a></li>
            <li><a href="#wiener-process">Wiener Process</a></li>
            <li><a href="#bernoulli">Correlated Bernoulli</a></li>
            <div class="nav-divider"></div>
            <li class="nav-secondary-item"><a href="#about">About</a></li>
            <li class="nav-secondary-item"><a href="#install">Install on device</a></li>
        </ul>
    </nav>
    <main>
        <div id="bernoulli-app" class="app-container">
            <h2>Correlated Bernoulli Variables Calculator</h2>
            <p>Enter exactly three values to compute the rest. User-entered values are <strong>black</strong>, calculated values are <span style="color:#888">grey</span>. Invalid states are shown in <span style="color:#d9534f">red</span>.</p>

            <p><button id="reset-button">Reset</button></p>

            <div class="variable-names-container">
                <label for="x-name">Name for variable X:</label><input type="text" id="x-name" value="X">
                <label for="y-name">Name for variable Y:</label><input type="text" id="y-name" value="Y">
            </div>

            <h3 class="katex-dynamic" data-katex-template="Joint & Marginal Probabilities: \( \mathbb{P}(\X=i, \Y=j) \)"></h3>
            <table>
                <tr>
                    <th style="border:none; background:transparent;"></th>
                    <th class="katex-dynamic" data-katex-template="\( \Y = 0 \)"></th>
                    <th class="katex-dynamic" data-katex-template="\( \Y = 1 \)"></th>
                    <th class="katex-dynamic" data-katex-template="Marginal (\( \X \))"></th>
                </tr>
                <tr>
                    <td class="label katex-dynamic" data-katex-template="\( \X = 0 \)"></td>
                    <td><input type="number" id="p00" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="p01" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pX0" step="0.01" min="0" max="1"></td>
                </tr>
                <tr>
                    <td class="label katex-dynamic" data-katex-template="\( \X = 1 \)"></td>
                    <td><input type="number" id="p10" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="p11" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pX" step="0.01" min="0" max="1"></td>
                </tr>
                <tr>
                    <td class="katex-dynamic" data-katex-template="Marginal (\( \Y \))"></td>
                    <td><input type="number" id="pY0" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pY" step="0.01" min="0" max="1"></td>
                    <td style="background:#eee;">1</td>
                </tr>
            </table>

            <h3>Conditional Probabilities</h3>
            <table>
                <caption class="katex-dynamic" data-katex-template="Conditional Probabilities \( \mathbb{P}(\Y=j \mid \X=i) \)"></caption>
                <tr>
                    <th style="border:none; background:transparent;"></th>
                    <th class="katex-dynamic" data-katex-template="\( \Y = 0 \)"></th>
                    <th class="katex-dynamic" data-katex-template="\( \Y = 1 \)"></th>
                </tr>
                <tr>
                    <td class="label katex-dynamic" data-katex-template="Given \( \X = 0 \)"></td>
                    <td><input type="number" id="pY0_X0" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pY1_X0" step="0.01" min="0" max="1"></td>
                </tr>
                <tr>
                    <td class="label katex-dynamic" data-katex-template="Given \( \X = 1 \)"></td>
                    <td><input type="number" id="pY0_X1" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pY1_X1" step="0.01" min="0" max="1"></td>
                </tr>
            </table>
            <table>
                <caption class="katex-dynamic" data-katex-template="Conditional Probabilities \( \mathbb{P}(\X=i \mid \Y=j) \)"></caption>
                <tr>
                    <th style="border:none; background:transparent;"></th>
                    <th class="katex-dynamic" data-katex-template="\( \X = 0 \)"></th>
                    <th class="katex-dynamic" data-katex-template="\( \X = 1 \)"></th>
                </tr>
                <tr>
                    <td class="label katex-dynamic" data-katex-template="Given \( \Y = 0 \)"></td>
                    <td><input type="number" id="pX0_Y0" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pX1_Y0" step="0.01" min="0" max="1"></td>
                </tr>
                <tr>
                    <td class="label katex-dynamic" data-katex-template="Given \( \Y = 1 \)"></td>
                    <td><input type="number" id="pX0_Y1" step="0.01" min="0" max="1"></td>
                    <td><input type="number" id="pX1_Y1" step="0.01" min="0" max="1"></td>
                </tr>
            </table>

            <h3>Correlation</h3>
            <div class="correlation-container">
                <label for="rho">Correlation Coefficient (\( ρ \))</label>
                <input type="number" id="rho" step="0.01" min="-1" max="1" style='border:1px solid #ccc;'>
            </div>

            <h3>Visualizations</h3>
            <div id="plots-container"></div>

            <details>
                <summary>Formulas</summary>
                <div class="formulas" id="formula-container" data-katex-template='
                <p>In these formulas, \( p_{\X} = \mathbb{P}(\X=1) \) and \( p_{\Y} = \mathbb{P}(\Y=1) \).</p>
                <h4>Joint Distribution from Marginals and Correlation</h4>
                $$
                \begin{aligned}
                p_{11} &= p_{\X} p_{\Y} + \rho \sqrt{p_{\X}(1-p_{\X}) p_{\Y}(1-p_{\Y})} \\
                p_{10} &= p_{\X} - p_{11} \\
                p_{01} &= p_{\Y} - p_{11} \\
                p_{00} &= 1 - p_{\X} - p_{\Y} + p_{11}
                \end{aligned}
                $$

                <h4>Correlation from Joint and Marginals</h4>
                $$
                \rho = \frac{p_{11} - p_{\X} p_{\Y}}{\sqrt{p_{\X}(1-p_{\X})p_{\Y}(1-p_{\Y})}}
                $$

                <h4>Conditional Distributions</h4>
                $$
                \begin{aligned}
                \mathbb{P}(\Y=1\mid \X=1) &= \frac{p_{11}}{p_{\X}} \\
                \mathbb{P}(\Y=1\mid \X=0) &= \frac{p_{01}}{1-p_{\X}}
                \end{aligned}
                $$'>
                </div>
            </details>
        </div>
        <div id="distributions-app" class="app-container">
            <div id="controls-panel" class="panel">
                <h3>Controls</h3>
                <div class="control-group">
                    <label for="dist-select">Distribution</label>
                    <select id="dist-select"></select>
                </div>
                <div id="param-inputs"></div>
                <div id="formula-display"></div>
            </div>

            <div id="stats-panel" class="panel">
                <h3>Summary Statistics</h3>
                <div id="stats-grid">
                    <div>Mean: <span id="stat-mean"></span></div>
                    <div>Variance: <span id="stat-variance"></span></div>
                    <div>Std. Dev: <span id="stat-stddev"></span></div>
                    <div>25th %ile: <span id="stat-q1"></span></div>
                    <div>Median: <span id="stat-median"></span></div>
                    <div>75th %ile: <span id="stat-q3"></span></div>
                    <div>50% Interval: <span id="stat-int50"></span></div>
                    <div>90% Interval: <span id="stat-int90"></span></div>
                    <div>95% Interval: <span id="stat-int95"></span></div>
                    <div>99% Interval: <span id="stat-int99"></span></div>
                </div>
            </div>

            <div id="sampling-panel" class="panel">
                <h3>Sampling</h3>
                <div class="sample-buttons">
                    <button id="sample-btn-1">Generate 1 Sample</button>
                    <button id="sample-btn-10">Generate 10 Samples</button>
                    <button id="sample-clear-btn">Clear</button>
                </div>
                <div id="samples-output"></div>
            </div>

            <div id="plot-container" class="panel">
                <div id="shading-controls">
                    <div class="control-group">
                        <label for="interval-select">Shade Interval</label>
                        <select id="interval-select">
                            <option value="0">None</option>
                            <option value="p50">50%</option>
                            <option value="p90">90%</option>
                            <option value="p95" selected>95%</option>
                            <option value="p99">99%</option>
                            <option value="s1">+/- 1σ</option>
                            <option value="s2">+/- 2σ</option>
                            <option value="s3">+/- 3σ</option>
                        </select>
                    </div>
                </div>
                <div class="plot-svg-wrapper">
                    <svg id="plot-svg"></svg>
                </div>
                <div id="param-sliders" style="padding: 10px 20px 0;"></div>
                <div id="tooltip"></div>
            </div>
        </div>
        <div id="order-statistics-app" class="app-container">
            <div id="os-controls-panel" class="panel">
                <h3>Controls</h3>
                <div class="control-group">
                    <label for="os-dist-select">Distribution</label>
                    <select id="os-dist-select"></select>
                </div>
                <div id="os-param-inputs"></div>
                <div class="control-group">
                    <p>Drawing from <input type="number" id="os-n" value="10" min="1" step="1" style="width: 60px; display: inline-block;"> samples, the density of the <input type="number" id="os-k" value="5" min="1" step="1" style="width: 60px; display: inline-block;">-th order statistic is:</p>
                </div>
            </div>

            <div id="os-stats-panel" class="panel">
                <h3>Summary Statistics</h3>
                <div id="os-stats-grid">
                    <div>Mean: <span id="os-stat-mean"></span></div>
                    <div>Variance: <span id="os-stat-variance"></span></div>
                    <div>Std. Dev: <span id="os-stat-stddev"></span></div>
                    <div>25th %ile: <span id="os-stat-q1"></span></div>
                    <div>Median: <span id="os-stat-median"></span></div>
                    <div>75th %ile: <span id="os-stat-q3"></span></div>
                    <div>50% Interval: <span id="os-stat-int50"></span></div>
                    <div>90% Interval: <span id="os-stat-int90"></span></div>
                    <div>95% Interval: <span id="os-stat-int95"></span></div>
                    <div>99% Interval: <span id="os-stat-int99"></span></div>
                </div>
            </div>

            <div id="os-plot-container" class="panel">
                <div id="os-shading-controls" style="display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px;">
                    <div class="control-group">
                        <label for="os-interval-select">Shade Interval</label>
                        <select id="os-interval-select">
                            <option value="0">None</option>
                            <option value="p50">50%</option>
                            <option value="p90">90%</option>
                            <option value="p95" selected>95%</option>
                            <option value="p99">99%</option>
                            <option value="s1">+/- 1σ</option>
                            <option value="s2">+/- 2σ</option>
                            <option value="s3">+/- 3σ</option>
                        </select>
                    </div>
                </div>
                <div class="plot-svg-wrapper">
                    <svg id="os-plot-svg"></svg>
                </div>
                <div id="os-tooltip"></div>
            </div>
            <details class="panel">
                <summary>Formulas</summary>
                <div class="formulas">
                    <h4>The marginal density of the k-th order statistic</h4>
                    <p>In a sample of size \(n\), the CDF and PDF of the \(k\)-th order statistic, \(X_{(k)}\), are:</p>
                    $$
                    \begin{aligned}
                    \mathbb{P}(X_{(k)} \le x) &= \sum_{i=k}^n {n \choose i} F(x)^i(1-F(x))^{n-i} \\
                    f_{X_{(k)}}(x) &= k{n\choose k}f(x)F(x)^{k-1}(1-F(x))^{n-k}
                    \end{aligned}
                    $$
                </div>
            </details>
        </div>
        <div id="gaussian-copula-app" class="app-container">
            <div id="gc-controls-panel" class="panel">
                <h3>Marginal Distributions</h3>
                <h4>Marginal for X</h4>
                <div class="control-group">
                    <label for="gc-dist-select-x">Distribution</label>
                    <select id="gc-dist-select-x"></select>
                </div>
                <div id="gc-param-inputs-x"></div>

                <h4>Marginal for Y</h4>
                <div class="control-group">
                    <label for="gc-dist-select-y">Distribution</label>
                    <select id="gc-dist-select-y"></select>
                </div>
                <div id="gc-param-inputs-y"></div>

                <h3>Dependence Structure</h3>
                <div class="control-group">
                    <label for="gc-rho-input">Correlation ρ: <span id="gc-rho-value">0.5</span></label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="gc-rho-slider" min="-0.99" max="0.99" step="0.01" value="0.5" style="flex-grow: 1;">
                        <input type="number" id="gc-rho-input" min="-0.99" max="0.99" step="0.01" value="0.5" style="width: 80px;">
                    </div>
                </div>
            </div>

            <div id="gc-plots-panel">
                <div id="gc-scatter-plot-container" class="panel gc-plot-container">
                    <h4 style="text-align: center; margin-top: 0;">Samples from Joint Distribution</h4>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <div id="gc-joint-plot-grid">
                        <svg id="gc-marginal-x-svg"></svg>
                        <svg id="gc-joint-plot-svg"></svg>
                        <svg id="gc-marginal-y-svg"></svg>
                    </div>
                    <div class="sample-buttons">
                        <button id="gc-sample-clear-btn">Clear Samples</button>
                        <button id="gc-sample-btn-1">Sample 1</button>
                        <button id="gc-sample-btn-10">Sample 10</button>
                        <button id="gc-sample-btn-100">Sample 100</button>
                        <button id="gc-sample-btn-1000">Sample 1000</button>
                    </div>
                </div>
                <div id="gc-density-plot-container" class="panel gc-plot-container">
                    <h4 id="gc-density-plot-title" style="text-align: center; margin-top: 0;">Conditional Density</h4>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                     <div id="gc-density-controls" style="display: flex; gap: 10px; justify-content: flex-end; padding: 0 20px;">
                        <div class="control-group" style="margin-bottom: 0;">
                            <label for="gc-interval-select">Shade Interval</label>
                            <select id="gc-interval-select">
                                <option value="0">None</option>
                                <option value="p50">50%</option>
                                <option value="p90">90%</option>
                                <option value="p95" selected>95%</option>
                                <option value="p99">99%</option>
                            </select>
                        </div>
                    </div>
                    <div class="plot-svg-wrapper">
                        <svg id="gc-density-plot-svg"></svg>
                    </div>
                    <div id="gc-conditional-mean-display" style="text-align: center; padding: 5px;"></div>
                    <div class="gc-conditional-controls-row">
                        <div class="control-group">
                            <label for="gc-cond-var">Condition on variable:</label>
                            <select id="gc-cond-var">
                                <option value="X">X</option>
                                <option value="Y">Y</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="gc-cond-type">Condition type:</label>
                            <select id="gc-cond-type">
                                <option value="eq">equal to</option>
                                <option value="ge">&ge; to</option>
                                <option value="le">&le; to</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="gc-cond-value">Value:</label>
                            <input type="number" id="gc-cond-value" value="0" step="0.1">
                        </div>
                    </div>
                    <div id="gc-density-tooltip"></div>
                </div>
            </div>
             <details id="gc-formulas-panel" class="panel">
                <summary>Formulas</summary>
                <div style="padding-top: 1rem;">
                    <p>Let \(u = F_X(x)\), \(v = F_Y(y)\), \(x' = \Phi^{-1}(u)\), and \(y' = \Phi^{-1}(v)\).</p>
                    <h4>Conditional on \(X=x\)</h4>
                    $$ f_{Y|X}(y|x) = \frac{f_Y(y)}{\phi(y')} \frac{1}{\sqrt{1-\rho^2}} \phi\left(\frac{y' - \rho x'}{\sqrt{1-\rho^2}}\right) $$
                    <h4>Conditional on \(X \ge x\)</h4>
                    $$ f_{Y|X \ge x}(y) = \frac{f_Y(y)}{1-u} \left[ 1 - \Phi\left(\frac{x' - \rho y'}{\sqrt{1-\rho^2}}\right) \right] $$
                    <h4>Conditional on \(X \le x\)</h4>
                    $$ f_{Y|X \le x}(y) = \frac{f_Y(y)}{u} \Phi\left(\frac{x' - \rho y'}{\sqrt{1-\rho^2}}\right) $$
                </div>
            </details>
        </div>
        <div id="wiener-process-app" class="app-container">
            <div id="wp-params-panel" class="panel">
                <h3>Process Parameters</h3>
                <p>\( dX_t = m\,dt + \sigma\,dW_t \)</p>
                <div class="control-grid">
                    <div class="control-group">
                        <label for="wp-x0">Start Value \( X_0 \)</label>
                        <input type="number" id="wp-x0" value="0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="wp-drift">Drift \( m \)</label>
                        <input type="number" id="wp-drift" value="0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="wp-volatility">Volatility \( \sigma \)</label>
                        <input type="number" id="wp-volatility" value="1" min="0.01" step="0.01">
                    </div>
                    <div class="control-group">
                        <label for="wp-terminal-time">Terminal Time \( T \)</label>
                        <input type="number" id="wp-terminal-time" value="1" min="0.01" step="0.1">
                    </div>
                </div>
            </div>
            <div id="wp-plots-wrapper">
                <div id="wp-paths-panel" class="panel">
                    <h3>Sample Paths of \( X_t \)</h3>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <div class="control-group">
                        <label for="wp-cone-select">Percentile Cone:</label>
                        <select id="wp-cone-select">
                            <option value="0">None</option>
                            <option value="p50">50%</option>
                            <option value="p90">90%</option>
                            <option value="p95" selected>95%</option>
                            <option value="p99">99%</option>
                        </select>
                    </div>
                    <div class="wp-plot-container" id="wp-paths-plot-grid">
                        <svg id="wp-paths-svg"></svg>
                        <svg id="wp-marginal-svg"></svg>
                    </div>
                    <div class="button-flex">
                        <button id="wp-clear-paths-btn">Clear</button>
                        <button id="wp-draw1-btn">Draw 1</button>
                        <button id="wp-draw10-btn">Draw 10</button>
                        <button id="wp-draw100-btn">Draw 100</button>
                    </div>
                </div>
                <div id="wp-hitting-time-panel" class="panel">
                    <h3>First Hitting Time \( T_b \)</h3>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <div class="control-group">
                        <label for="wp-barrier">Barrier \( b =\, \)</label>
                        <input type="number" id="wp-barrier" value="0.5" step="0.01">
                    </div>
                    <p style="text-align: center;">Density of \( T_b = \inf\{t \ge 0 \mid X_t = b\} \)</p>
                    <div class="wp-plot-container">
                        <svg id="wp-ht-density-svg"></svg>
                        <div id="wp-ht-density-tooltip" class="wp-tooltip"></div>
                    </div>
                    <p style="text-align: center;">Hitting Probability \( \mathbb{P}(T_b \le t) \)</p>
                    <div class="wp-plot-container">
                        <svg id="wp-ht-prob-svg"></svg>
                        <div id="wp-ht-prob-tooltip" class="wp-tooltip"></div>
                    </div>
                </div>
                <div id="wp-hitting-prob-by-barrier-panel" class="panel">
                    <h3>Hitting Probability by Barrier distance</h3>
                    <div class="move-controls"><button class="move-btn move-up">▲</button><button class="move-btn move-down">▼</button></div>
                    <p style="text-align: center;">\( \mathbb{P}(\{X_t = b \text{ for any } 0\le t\le T\}) \) as a function of barrier \(b\)</p>
                    <div class="wp-plot-container">
                        <svg id="wp-hp-by-barrier-svg"></svg>
                        <div id="wp-hp-by-barrier-tooltip" class="wp-tooltip"></div>
                    </div>
                </div>
            </div>
            <details class="panel">
                <summary>Formulas</summary>
                <div class="formulas" style="padding-top: 1rem;">
                    <h4>Distribution of the process at time \(t\)</h4>
                    <p>The value of the process \(X_t\) at time \(t\) is normally distributed:</p>
                    $$ X_t \sim \mathcal{N}(X_0 + mt, \sigma^2 t) $$

                    <h4>First Hitting Time</h4>
                    <p>Let \(a = b - X_0\) be the distance to the barrier. The first time the process hits the barrier, \(T_b = \inf\{t \ge 0 \mid X_t = b\}\), follows an Inverse-Gaussian distribution with PDF:</p>
                    $$ f_{T_b}(t) = \frac{|a|}{\sigma\sqrt{2\pi t^3}} e^{-\frac{(a-mt)^2}{2\sigma^2 t}} $$
                    
                    <h4>Hitting Probability by time \(T\)</h4>
                    <p>The probability of hitting the barrier \(b\) at or before time \(T\) is:</p>
                    $$ \mathbb{P}(T_b \le T) = \Phi\left(\frac{mT-a}{\sigma\sqrt{T}}\right) + e^{\frac{2ma}{\sigma^2}} \Phi\left(\frac{-mT-a}{\sigma\sqrt{T}}\right) $$
                    <p>where \(a=b-X_0\) and \(\Phi\) is the standard normal CDF. This applies when \(a > 0\). If \(a < 0\), the signs of both \(a\) and \(m\) are flipped.</p>
                </div>
            </details>
        </div>
        <div id="about-app" class="app-container">
            <div class="panel">
                <h3>About</h3>
                <p>This is a web app that helps you do quick probability calculations on your phone or computer.</p>
                <h4>What the app can do:</h4>
                <ul>
                    <li>Plot probability distributions of widely used continuous and discrete distributions, and compute summary statistics.</li>
                    <li>For any probability density graph, compute the area under the curve (click and move over the density graphs). Useful for e.g. estimating tail probabilities of conditional variables.</li>
                    <li>Compute the density of order statistics of i.i.d. variables (for example if you want to know what the 2nd largest of 10 samples is).</li>
                    <li>Plot, generate samples, and compute summary statistics of dependent variables (either continuous, or Bernoulli variables).</li>
                    <li>Compute Brownian Motion sample paths, first hitting time distributions, and hitting probabilities.</li>
                </ul>
                <h4>How it works</h4>
                <p>For all calculations there are either closed form solutions available, or some simple numeric calculations. The app uses <a href="https://ccc-js.github.io/numeric2/">numeric.js</a> and <a href="https://jstat.github.io/">jStat</a> for most calculations. The values you input never leave your device, all computation is done locally.</p>
                <p>The graphs and visualizations are created using <a href="https://d3js.org/">d3.js</a>.</p>
                <p>If you make consequential decisions, don’t solely rely on the answers given here, you should perhaps double check the results with some Python code.</p>
                <h4>Bugs/Contributions</h4>
                <p>The repository is available at TODO. You are welcome to open issues there, or better yet, send a pull request. The purpose of the app is to enable quick and easy probability calculations – so I won’t be accepting contributions of the form “enter 20 data points and compute statistic X”, you’d want a proper data science environment for that.</p>
                <h4>Author & License</h4>
                <p>Copyright 2025 Julius Plenz. Published under the <a href="https://opensource.org/license/mit">MIT license</a>.</p>
            </div>
        </div>
        <div id="install-app" class="app-container">
             <h3>Install <em>Probly</em></h3>
             <p>For a better experience, you can install this application on your device. It will work offline and feel like a native app. Click the button below to install.</p>
             <img src="/assets/icon-192x192.png" alt="Probly Logo" style="width: 128px; height: 128px; margin: 1rem auto; display: block;">
             <button id="install-button" style="display: none;">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM12 17l-5-5h3V9h4v3h3l-5 5z"/></svg>
                Install
            </button>
        </div>
    </main>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const bernoulliApp = (() => {
        let state = {};
        const ALL_IDS = [
            'p00', 'p01', 'p10', 'p11', 'pX', 'pX0', 'pY', 'pY0',
            'pY0_X0', 'pY1_X0', 'pY0_X1', 'pY1_X1', 'pX0_Y0', 'pX1_Y0', 'pX0_Y1', 'pX1_Y1', 'rho'
        ];
        const INPUT_IDS = ALL_IDS.filter(id => document.getElementById(id));
        const TOLERANCE = 1e-4;

        const calcFuncs = {
            p01: vars => vars[0], p10: vars => vars[1], p11: vars => vars[2], p00: vars => 1 - vars[0] - vars[1] - vars[2],
            pX:  vars => vars[1] + vars[2], pY:  vars => vars[0] + vars[2], pX0: vars => 1 - (vars[1] + vars[2]), pY0: vars => 1 - (vars[0] + vars[2]),
            rho: vars => {
                const pX = vars[1] + vars[2]; const pY = vars[0] + vars[2]; const p11 = vars[2]; const pX_var = pX * (1 - pX); const pY_var = pY * (1 - pY);
                if (pX_var < TOLERANCE || pY_var < TOLERANCE) return 0;
                return (p11 - pX * pY) / Math.sqrt(pX_var * pY_var);
            },
            pX1_Y1: vars => { const pY = vars[0] + vars[2]; return pY < TOLERANCE ? null : vars[2] / pY; },
            pX0_Y1: vars => { const pY = vars[0] + vars[2]; return pY < TOLERANCE ? null : vars[0] / pY; },
            pX1_Y0: vars => { const pY = vars[0] + vars[2]; return (1 - pY) < TOLERANCE ? null : vars[1] / (1 - pY); },
            pX0_Y0: vars => { const pY = vars[0] + vars[2]; const p00 = 1 - vars[0] - vars[1] - vars[2]; return (1 - pY) < TOLERANCE ? null : p00 / (1 - pY); },
            pY1_X1: vars => { const pX = vars[1] + vars[2]; return pX < TOLERANCE ? null : vars[2] / pX; },
            pY0_X1: vars => { const pX = vars[1] + vars[2]; return pX < TOLERANCE ? null : vars[1] / pX; },
            pY1_X0: vars => { const pX = vars[1] + vars[2]; return (1 - pX) < TOLERANCE ? null : vars[0] / (1 - pX); },
            pY0_X0: vars => { const pX = vars[1] + vars[2]; const p00 = 1 - vars[0] - vars[1] - vars[2]; return (1 - pX) < TOLERANCE ? null : p00 / (1 - pX); }
        };

        function updateURL() {
            const params = new URLSearchParams();
            for (const id in state) {
                if (state[id].isUserInput && state[id].value !== null) {
                    params.set(id, state[id].value);
                }
            }
            params.set('x-name', document.getElementById('x-name').value);
            params.set('y-name', document.getElementById('y-name').value);
            history.replaceState(null, '', '#bernoulli?' + params.toString());
        }

        function updateAndRenderMath() {
            const xName = document.getElementById('x-name').value || 'X';
            const yName = document.getElementById('y-name').value || 'Y';
            document.querySelectorAll('#bernoulli-app [data-katex-template]').forEach(el => {
                el.innerHTML = el.dataset.katexTemplate;
            });
            xmacro = xName.length > 1 ? `\\text{${xName}}` : xName;
            ymacro = yName.length > 1 ? `\\text{${yName}}` : yName;
            renderMathInElement(document.getElementById('bernoulli-app'), {
                delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                macros: { "\\X": xmacro, "\\Y": ymacro }
            });
        }

        function createState() {
            const newState = {};
            INPUT_IDS.forEach(id => { newState[id] = { value: null, isUserInput: false }; });
            return newState;
        }

        function resetState() {
            state = createState();
            document.getElementById('x-name').value = 'X';
            document.getElementById('y-name').value = 'Y';
            updateAndRenderMath();
            render();
            updateURL();
        }

        function handleInput(e) {
            const id = e.target.id;
            const value = e.target.value === '' ? null : parseFloat(e.target.value);
            const userInputs = Object.values(state).filter(s => s.isUserInput);
            if (userInputs.length === 0 && value !== null) {
                state = createState();
            }
            state[id].value = value;
            state[id].isUserInput = (value !== null);
            const complementary = { pX: 'pX0', pX0: 'pX', pY: 'pY0', pY0: 'pY', pY0_X0: 'pY1_X0', pY1_X0: 'pY0_X0', pY0_X1: 'pY1_X1', pY1_X1: 'pY0_X1', pX0_Y0: 'pX1_Y0', pX1_Y0: 'pX0_Y0', pX0_Y1: 'pX1_Y1', pX1_Y1: 'pX0_Y1' };
            if (complementary[id] && value !== null && value >= 0 && value <= 1) {
                const complementId = complementary[id];
                state[complementId].value = 1 - value;
                state[complementId].isUserInput = false;
            }
            calculateAll(id);
            updateURL();
        }

        function calculateAll(activeElementId = null) {
            for (const id in state) { if (!state[id].isUserInput) state[id].value = null; }
            const solution = solve();
            if (solution.success) propagate(solution.vars);
            const validationResult = validate();
            const userInputsCount = Object.values(state).filter(s => s.isUserInput && s.value !== null).length;
            const isError = (!solution.success && userInputsCount >= 3) || (solution.success && validationResult);
            render(isError, activeElementId);
        }

        function solve() {
            const userInputs = Object.entries(state).filter(([, s]) => s.isUserInput && s.value !== null);
            if (userInputs.length !== 3) return { success: false };
            const objectiveFunction = (vars) => {
                let totalError = 0;
                const [p01, p10, p11] = vars;
                const p00 = 1 - p01 - p10 - p11;
                if (p00 < 0) totalError += 1e6 * p00 * p00;
                if (p01 < 0) totalError += 1e6 * p01 * p01;
                if (p10 < 0) totalError += 1e6 * p10 * p10;
                if (p11 < 0) totalError += 1e6 * p11 * p11;
                for (const [id, s] of userInputs) {
                    if (calcFuncs[id]) {
                        const calculatedValue = calcFuncs[id](vars);
                        if (calculatedValue !== null && isFinite(calculatedValue)) totalError += (calculatedValue - s.value)**2;
                    }
                }
                return totalError;
            };
            let result, success = false;
            for (let i = 0; i < 10; i++) {
                result = numeric.uncmin(objectiveFunction, [Math.random(), Math.random(), Math.random()]);
                if (result.f < 1e-6 && Array.isArray(result.solution)) { success = true; break; }
            }
            return { success, vars: result.solution };
        }

        function propagate(vars) {
            const [p01, p10, p11] = vars;
            state.p00.value = 1 - p01 - p10 - p11; state.p01.value = p01; state.p10.value = p10; state.p11.value = p11;
            for (const id in state) {
                if (state[id].value === null && calcFuncs[id]) state[id].value = calcFuncs[id](vars);
            }
        }

        function validate() {
            let hasError = false;
            for (const id in state) {
                const val = state[id].value;
                if (val === null) continue;
                let isFieldInvalid = (id === 'rho') ? (val < -1 - TOLERANCE || val > 1 + TOLERANCE) : (val < 0 - TOLERANCE || val > 1 + TOLERANCE);
                if (isNaN(val)) isFieldInvalid = true;
                if (isFieldInvalid) hasError = true;
            }
            return hasError;
        }

        function render(isError = false, activeElementId = null) {
            const userInputsCount = Object.values(state).filter(s => s.isUserInput && s.value !== null).length;
            const showError = isError && userInputsCount >= 3;
            INPUT_IDS.forEach(id => {
                const el = document.getElementById(id);
                if (id === activeElementId) { el.classList.toggle('error', showError); return; }
                const s = state[id];
                el.value = (s.value !== null && !isNaN(s.value)) ? parseFloat(s.value).toFixed(3) : '';
                el.classList.toggle('user-input', s.isUserInput);
                el.classList.toggle('error', showError);
            });
            renderPlots(state);
        }

        function renderPlots(state) {
            const xName = document.getElementById('x-name').value || 'X'; const yName = document.getElementById('y-name').value || 'Y';
            const container = d3.select("#plots-container"); container.html("");
            const plotData = [
                { id: 'joint', title: 'Joint Probabilities', data: ['p00', 'p01', 'p10', 'p11'] }, { id: 'marginal-x', title: `Marginal P(${xName})`, data: ['pX0', 'pX'] },
                { id: 'marginal-y', title: `Marginal P(${yName})`, data: ['pY0', 'pY'] }, { id: 'cond-y-x0', title: `P(${yName}|${xName}=0)`, data: ['pY0_X0', 'pY1_X0'] },
                { id: 'cond-y-x1', title: `P(${yName}|${xName}=1)`, data: ['pY0_X1', 'pY1_X1'] }, { id: 'cond-x-y0', title: `P(${xName}|${yName}=0)`, data: ['pX0_Y0', 'pX1_Y0'] },
                { id: 'cond-x-y1', title: `P(${xName}|${yName}=1)`, data: ['pX0_Y1', 'pX1_Y1'] }
            ];
            const labelMap = { 'p00': `${xName}=0,${yName}=0`, 'p01': `${xName}=0,${yName}=1`, 'p10': `${xName}=1,${yName}=0`, 'p11': `${xName}=1,${yName}=1`, 'pX0': `${xName}=0`, 'pX': `${xName}=1`, 'pY0': `${yName}=0`, 'pY': `${yName}=1`, 'pY0_X0': `${yName}=0`, 'pY1_X0': `${yName}=1`, 'pY0_X1': `${yName}=0`, 'pY1_X1': `${yName}=1`, 'pX0_Y0': `${xName}=0`, 'pX1_Y0': `${xName}=1`, 'pX0_Y1': `${xName}=0`, 'pX1_Y1': `${xName}=1` };
            if (!Object.values(state).some(s => s.value !== null)) { container.html("(none)"); return; }
            plotData.forEach(plot => {
                const data = plot.data.map(id => ({ id: id, label: labelMap[id] || id, value: state[id].value, isUserInput: state[id].isUserInput })).filter(d => d.value !== null && !isNaN(d.value));
                if (data.length > 0) createBarChart(plot.id, plot.title, data);
            });
            createCorrelationPlot(state);
            function createBarChart(id, title, data) {
                const plotContainer = container.append("div").attr("class", "plot").attr("id", `plot-${id}`);
                plotContainer.append("div").attr("class", "plot-title").text(title);
                const margin = {top: 20, right: 10, bottom: 40, left: 40}, width = 200 - margin.left - margin.right, height = 150 - margin.top - margin.bottom;
                const svg = plotContainer.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleBand().range([0, width]).domain(data.map(d => d.label)).padding(0.2);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x)).selectAll("text").attr("transform", "translate(-10,0)rotate(-45)").style("text-anchor", "end");
                const y = d3.scaleLinear().domain([0, 1]).range([height, 0]);
                svg.append("g").call(d3.axisLeft(y));
                svg.selectAll("rect").data(data).enter().append("rect").attr("x", d => x(d.label)).attr("y", d => y(d.value)).attr("width", x.bandwidth()).attr("height", d => height - y(d.value)).attr("fill", d => d.isUserInput ? "#a1d99b" : "#9ecae1");
                svg.selectAll(".bar-label").data(data).enter().append("text").attr("x", d => x(d.label) + x.bandwidth() / 2).attr("y", d => y(d.value) - 5).attr("text-anchor", "middle").style("font-size", "10px").text(d => d.value.toFixed(3));
            }
            function createCorrelationPlot(state) {
                const jointProbs = [ { x: 0, y: 0, p: state.p00.value, isUserInput: state.p00.isUserInput }, { x: 1, y: 0, p: state.p10.value, isUserInput: state.p10.isUserInput }, { x: 0, y: 1, p: state.p01.value, isUserInput: state.p01.isUserInput }, { x: 1, y: 1, p: state.p11.value, isUserInput: state.p11.isUserInput } ].filter(d => d.p !== null && !isNaN(d.p) && d.p >= 0);
                if (jointProbs.length !== 4) return;
                const plotContainer = d3.select("#plots-container").append("div").attr("class", "plot").attr("id", "plot-correlation");
                plotContainer.append("div").attr("class", "plot-title").text("Joint Distribution & Correlation");
                const margin = { top: 20, right: 20, bottom: 40, left: 40 }, width = 200 - margin.left - margin.right, height = 200 - margin.top - margin.bottom;
                const svg = plotContainer.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleLinear().domain([-0.2, 1.2]).range([0, width]); const y = d3.scaleLinear().domain([-0.2, 1.2]).range([height, 0]);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(1).tickFormat(d3.format("d")));
                svg.append("g").call(d3.axisLeft(y).ticks(1).tickFormat(d3.format("d")));
                const xName = document.getElementById('x-name').value || 'X'; const yName = document.getElementById('y-name').value || 'Y';
                svg.append("text").attr("x", width / 2).attr("y", height + margin.bottom - 5).style("text-anchor", "middle").text(xName);
                svg.append("text").attr("transform", "rotate(-90)").attr("y", 0 - margin.left).attr("x", 0 - (height / 2)).attr("dy", "1em").style("text-anchor", "middle").text(yName);
                const r = d3.scaleSqrt().domain([0, 1]).range([0, 30]);
                svg.selectAll("circle").data(jointProbs).enter().append("circle").attr("cx", d => x(d.x)).attr("cy", d => y(d.y)).attr("r", d => r(d.p)).attr("fill", d => d.isUserInput ? "#a1d99b" : "#9ecae1").attr("opacity", 0.8);
                const pX = state.pX.value, pY = state.pY.value, p11 = state.p11.value; if (pX === null || pY === null || p11 === null) return;
                const pX_var = pX * (1 - pX);
                if (Math.abs(pX_var) > 1e-9) {
                    const cov = p11 - pX * pY, slope = cov / pX_var, intercept = pY - slope * pX;
                    svg.append("line").attr("x1", x(x.domain()[0])).attr("y1", y(intercept + slope * x.domain()[0])).attr("x2", x(x.domain()[1])).attr("y2", y(intercept + slope * x.domain()[1])).attr("stroke", "#d9534f").attr("stroke-width", 2);
                }
            }
        }

        function setupListeners() {
            INPUT_IDS.forEach(id => {
                const el = document.getElementById(id);
                el.addEventListener('input', handleInput);
                el.addEventListener('blur', () => calculateAll());
            });
            document.getElementById('reset-button').addEventListener('click', resetState);
            const nameChangeHandler = () => { updateAndRenderMath(); render(); updateURL(); };
            document.getElementById('x-name').addEventListener('input', nameChangeHandler);
            document.getElementById('y-name').addEventListener('input', nameChangeHandler);
        }

        return {
            init: () => {
                state = createState();
                setupListeners();
                updateAndRenderMath();
                render();
            },
            updateFromURL: (params) => {
                state = createState();
                let inputCount = 0;
                for (const [key, value] of params.entries()) {
                    if (key === 'x-name') { document.getElementById('x-name').value = value; continue; }
                    if (key === 'y-name') { document.getElementById('y-name').value = value; continue; }
                    if (state[key]) {
                        const parsedValue = parseFloat(value);
                        if (!isNaN(parsedValue)) {
                            state[key].value = parsedValue;
                            state[key].isUserInput = true;
                            inputCount++;
                        }
                    }
                }
                updateAndRenderMath();
                if (inputCount > 0) calculateAll(); else render();
            }
        };
    })();

    const discreteInv = (prob, cdf, params) => {
        if (prob <= 0) return params.min !== undefined ? params.min : 0;
        const maxK = params.n !== undefined ? params.n : (params.max !== undefined ? params.max : Math.max(40, params.lambda * 4));
        if (prob >= 1) return maxK;
        let k = params.min !== undefined ? params.min : 0;
        while (cdf(k) < prob) { k++; if (k > maxK * 2) return Infinity; }
        return k;
    };

    const DISTRIBUTIONS = {
        normal: { name: 'Normal', type: 'continuous', params: [{ id: 'mu', name: 'μ (Mean)', default: 0, step: 0.1 }, { id: 'sigma', name: 'σ (Std. Dev)', default: 1, min: 0.1, step: 0.01 }], jStat: p => jStat.normal(p.mu, p.sigma), domain: p => [p.mu - 4 * p.sigma, p.mu + 4 * p.sigma], formula: 'f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}', mean: p => p.mu, variance: p => p.sigma**2, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.normal.sample(p.mu, p.sigma) },
        lognormal: { name: 'Lognormal', type: 'continuous', params: [{ id: 'mu', name: 'μ (log-scale)', default: 0, step: 0.1 }, { id: 'sigma', name: 'σ (shape)', default: 1, min: 0.01, step: 0.01 }], jStat: p => jStat.lognormal(p.mu, p.sigma), domain: (p, j) => [0.001, j.inv(0.995)], formula: 'f(x) = \\frac{1}{x\\sigma\\sqrt{2\\pi}} e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}', mean: p => Math.exp(p.mu + p.sigma**2 / 2), variance: p => (Math.exp(p.sigma**2) - 1) * Math.exp(2 * p.mu + p.sigma**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.lognormal.sample(p.mu, p.sigma) },
        exponential: { name: 'Exponential', type: 'continuous', params: [ { id: 'lambda', name: 'λ (Rate)', default: 1, min: 0.0001, step: 0.0001 } ], jStat: p => jStat.exponential(p.lambda), domain: (p, j) => [0, j.inv(0.999)], formula: 'f(x; \\lambda) = \\lambda e^{-\\lambda x}', mean: p => 1 / p.lambda, variance: p => 1 / (p.lambda**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.exponential.sample(p.lambda) },
        gamma: { name: 'Gamma', type: 'continuous', params: [{ id: 'alpha', name: 'α (Shape)', default: 2, min: 0.001, step: 0.001 }, { id: 'beta', name: 'β (Rate)', default: 1, min: 0.001, step: 0.001 }], jStat: p => jStat.gamma(p.alpha, p.beta), domain: (p, j) => [0.001, j.inv(0.999)], formula: 'f(x; \\alpha,\\beta) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} x^{\\alpha-1}e^{-\\beta x}', mean: p => p.alpha / p.beta, variance: p => p.alpha / (p.beta**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.gamma.sample(p.alpha, p.beta) },
        beta: { name: 'Beta', type: 'continuous', params: [{ id: 'alpha', name: 'α (Shape)', default: 2, min: 0.01, step: 0.01 }, { id: 'beta', name: 'β (Shape)', default: 3, min: 0.01, step: 0.01 }], jStat: p => jStat.beta(p.alpha, p.beta), domain: p => [0, 1], formula: 'f(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{\\mathrm{B}(\\alpha, \\beta)}', mean: p => p.alpha / (p.alpha + p.beta), variance: p => (p.alpha * p.beta) / ((p.alpha + p.beta)**2 * (p.alpha + p.beta + 1)), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.beta.sample(p.alpha, p.beta) },
        pareto: { name: 'Pareto', type: 'continuous', params: [{ id: 'xm', name: 'xₘ (scale)', default: 1, min: 0.01, step: 0.01 }, { id: 'alpha', name: 'α (shape)', default: 2, min: 0.01, step: 0.01 }], jStat: p => jStat.pareto(p.xm, p.alpha), domain: (p, j) => [p.xm, j.inv(0.98)], formula: 'f(x) = \\frac{\\alpha x_m^\\alpha}{x^{\\alpha+1}}', mean: p => p.alpha > 1 ? (p.alpha * p.xm) / (p.alpha - 1) : Infinity, variance: p => p.alpha > 2 ? ((p.xm**2 * p.alpha) / ((p.alpha - 1)**2 * (p.alpha - 2))) : Infinity, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: null },
        weibull: { name: 'Weibull', type: 'continuous', params: [{ id: 'scale', name: 'λ (Scale)', default: 1, min: 0.001, step: 0.001 }, { id: 'shape', name: 'k (Shape)', default: 2, min: 0.001, step: 0.001 }], jStat: p => jStat.weibull(p.scale, p.shape), domain: (p, j) => [0.001, j.inv(0.999)], formula: 'f(x; k, \\lambda) = \\frac{k}{\\lambda}(\\frac{x}{\\lambda})^{k-1}e^{-(x/\\lambda)^k}', mean: p => p.scale * jStat.gammafn(1 + 1 / p.shape), variance: p => p.scale**2 * (jStat.gammafn(1 + 2 / p.shape) - (jStat.gammafn(1 + 1 / p.shape))**2), pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.weibull.sample(p.scale, p.shape) },
        uniform: { name: 'Uniform (continuous)', type: 'continuous', params: [{ id: 'a', name: 'a (Min)', default: 0, step: 1 }, { id: 'b', name: 'b (Max)', default: 1, step: 1 }], jStat: p => jStat.uniform(p.a, p.b), domain: p => [p.a - (p.b-p.a)*0.1, p.b + (p.b-p.a)*0.1], formula: 'f(x) = \\frac{1}{b-a}', mean: p => (p.a + p.b) / 2, variance: p => (p.b - p.a)**2 / 12, pdfpmf: (x, j) => j.pdf(x), cdf: (x, j) => j.cdf(x), inv: (prob, j) => j.inv(prob), sampler: p => jStat.uniform.sample(p.a, p.b) },
        discreteUniform: { name: 'Uniform (discrete)', type: 'discrete', params: [{ id: 'min', name: 'Min', default: 0, step: 1 }, { id: 'max', name: 'Max', default: 9, step: 1 }], jStat: p => ({}), domain: p => [p.min - 1, p.max + 1], formula: 'P(X=k) = \\frac{1}{n}', mean: p => (p.min + p.max) / 2, variance: p => ((p.max - p.min + 1)**2 - 1) / 12, pdfpmf: (x, j, p) => { const k = Math.round(x); return k >= p.min && k <= p.max ? 1 / (p.max - p.min + 1) : 0; }, cdf: (x, j, p) => { const k = Math.floor(x); if (k < p.min) return 0; if (k >= p.max) return 1; return (k - p.min + 1) / (p.max - p.min + 1); }, inv: (prob, j, p) => discreteInv(prob, (k) => DISTRIBUTIONS.discreteUniform.cdf(k, j, p), p), sampler: p => Math.floor(jStat.uniform.sample(p.min, p.max + 1)) },
        binomial: { name: 'Binomial', type: 'discrete', params: [{ id: 'n', name: 'n (Trials)', default: 20, min: 1, step: 1 }, { id: 'p', name: 'p (Probability)', default: 0.5, min: 0, max: 1, step: 0.01 }], jStat: p => ({}), domain: p => [-0.5, p.n + 0.5], formula: 'P(k; n,p) = \\binom{n}{k} p^k(1-p)^{n-k}', mean: p => p.n * p.p, variance: p => p.n * p.p * (1 - p.p), pdfpmf: (x, j, p) => jStat.binomial.pdf(Math.round(x), p.n, p.p), cdf: (x, j, p) => jStat.binomial.cdf(Math.round(x), p.n, p.p), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.binomial.cdf(k, p.n, p.p), p), sampler: null },
        negativeBinomial: { name: 'Negative Binomial', type: 'discrete', params: [{ id: 'r', name: 'r (Successes)', default: 10, min: 1, step: 1 }, { id: 'p', name: 'p (Probability)', default: 0.5, min: 0.01, max: 1, step: 0.01 }], jStat: p => ({}), domain: (p, j) => [-0.5, discreteInv(0.9999, (k) => jStat.negbin.cdf(k, p.r, p.p), { ...p, min: 0 })], formula: 'P(k; r,p) = \\binom{k+r-1}{k} p^r(1-p)^{k}', mean: p => p.r * (1 - p.p) / p.p, variance: p => p.r * (1 - p.p) / (p.p**2), pdfpmf: (x, j, p) => jStat.negbin.pdf(Math.round(x), p.r, p.p), cdf: (x, j, p) => jStat.negbin.cdf(Math.round(x), p.r, p.p), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.negbin.cdf(k, p.r, p.p), { ...p, min: 0 }), sampler: null },
        hypergeometric: { name: 'Hypergeometric', type: 'discrete', params: [{ id: 'N', name: 'N (Population)', default: 50, min: 1, step: 1 }, { id: 'K', name: 'K (Successes in Pop.)', default: 10, min: 0, step: 1 }, { id: 'n', name: 'n (Sample Size)', default: 20, min: 1, step: 1 }], jStat: p => ({}), domain: p => [Math.max(0, p.n - p.N + p.K) - 1, Math.min(p.n, p.K) + 1], formula: 'P(X=k) = \\frac{\\binom{K}{k}\\binom{N-K}{n-k}}{\\binom{N}{n}}', mean: p => p.n * p.K / p.N, variance: p => p.n * (p.K / p.N) * (1 - p.K / p.N) * ((p.N - p.n) / (p.N - 1)), pdfpmf: (x, j, p) => jStat.hypgeom.pdf(Math.round(x), p.N, p.K, p.n), cdf: (x, j, p) => jStat.hypgeom.cdf(Math.round(x), p.N, p.K, p.n), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.hypgeom.cdf(k, p.N, p.K, p.n), { ...p, min: Math.max(0, p.n - (p.N - p.K)) }), sampler: null },
        poisson: { name: 'Poisson', type: 'discrete', params: [ { id: 'lambda', name: 'λ (Mean)', default: 5, min: 0.01, step: 0.01 } ], jStat: p => jStat.poisson(p.lambda), domain: (p, j) => [-0.5, Math.max(20, discreteInv(0.9999, (k) => jStat.poisson.cdf(k, p.lambda), p))], formula: 'P(k; \\lambda) = \\frac{\\lambda^k e^{-\\lambda}}{k!}', mean: p => p.lambda, variance: p => p.lambda, pdfpmf: (x, j, p) => jStat.poisson.pdf(Math.round(x), p.lambda), cdf: (x, j, p) => jStat.poisson.cdf(Math.round(x), p.lambda), inv: (prob, j, p) => discreteInv(prob, (k) => jStat.poisson.cdf(k, p.lambda), p), sampler: p => jStat.poisson.sample(p.lambda) }
    };

    const distributionsApp = (() => {

        const distSelect = document.getElementById('dist-select');
        const paramInputs = document.getElementById('param-inputs');
        const paramSliders = document.getElementById('param-sliders');
        const formulaDisplay = document.getElementById('formula-display');
        const intervalSelect = document.getElementById('interval-select');
        const samplesOutput = document.getElementById('samples-output');
        const tooltip = document.getElementById('tooltip');
        const sampleBtn1 = document.getElementById('sample-btn-1');
        const sampleBtn10 = document.getElementById('sample-btn-10');
        let currentState = { distKey: 'normal', params: {}, jstat: null, samples: [] };
        const svg = d3.select("#plot-svg");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        const xScale = d3.scaleLinear(), yScale = d3.scaleLinear();
        const xAxis = svg.append("g").attr("class", "x-axis axis");
        const yAxis = svg.append("g").attr("class", "y-axis axis");
        const plotArea = svg.append("g").attr("class", "plot-area");
        const dragLayer = svg.append("g").attr("class", "drag-layer");

        function updateURL() {
            const params = new URLSearchParams();
            params.set('dist', currentState.distKey);
            for(const p of DISTRIBUTIONS[currentState.distKey].params) {
                params.set(p.id, currentState.params[p.id]);
            }
            history.replaceState(null, '', '#distributions?' + params.toString());
        }

        function handleDistChange(options = {}) {
            currentState.distKey = distSelect.value;
            const config = DISTRIBUTIONS[currentState.distKey];
            paramInputs.innerHTML = ''; paramSliders.innerHTML = '';
            config.params.forEach(p => {
                const group = document.createElement('div'); group.className = 'param-group';
                group.innerHTML = `<label for="param-${p.id}">${p.name}</label><input type="number" id="param-${p.id}" data-param="${p.id}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}">`;
                paramInputs.appendChild(group);
                const sliderGroup = document.createElement('div'); sliderGroup.className = 'param-group';
                sliderGroup.innerHTML = `<label for="slider-${p.id}" style="display: block; margin-bottom: 5px;">${p.name}: <span id="slider-val-${p.id}">${p.default}</span></label><input type="range" id="slider-${p.id}" data-param="${p.id}" value="${p.default}" style="width: 100%;">`;
                paramSliders.appendChild(sliderGroup);
                const numberInput = document.getElementById(`param-${p.id}`); const sliderInput = document.getElementById(`slider-${p.id}`); const sliderValSpan = document.getElementById(`slider-val-${p.id}`);
                const precision = (() => { if (String(p.step).indexOf('.') === -1) return 0; return String(p.step).split('.')[1].length; })();
                const updateSliderBounds = () => {
                    const value = parseFloat(numberInput.value); if (isNaN(value) || !numberInput.checkValidity()) return;
                    let sliderMin, sliderMax;
                    if (value === 0) { sliderMin = -1; sliderMax = 1; } else { const logVal = Math.log10(Math.abs(value)); sliderMin = (value > 0 ? 1 : -1) * 10**(logVal - 1); sliderMax = (value > 0 ? 1 : -1) * 10**(logVal + 1); if (value < 0) [sliderMin, sliderMax] = [sliderMax, sliderMin]; }
                    const finalMin = Math.max(p.min ?? -Infinity, sliderMin); const finalMax = Math.min(p.max ?? Infinity, sliderMax);
                    sliderInput.min = finalMin; sliderInput.max = finalMax;
                    if (p.step % 1 === 0) { sliderInput.step = 1; sliderInput.min = Math.ceil(finalMin); sliderInput.max = Math.floor(finalMax); } else { sliderInput.step = (finalMax - finalMin) / 200; }
                };
                numberInput.addEventListener('input', () => { const val = parseFloat(numberInput.value); if (!isNaN(val)) { sliderInput.value = val; sliderValSpan.textContent = val.toFixed(precision); } });
                numberInput.addEventListener('change', updateSliderBounds);
                sliderInput.addEventListener('input', (e) => { const val = parseFloat(e.target.value); numberInput.value = val.toFixed(precision); sliderValSpan.textContent = val.toFixed(precision); update(); });
                sliderInput.addEventListener('change', updateSliderBounds);
                updateSliderBounds(); sliderInput.value = numberInput.value;
            });
            katex.render(config.formula, formulaDisplay, { throwOnError: false, displayMode: true });
            update(options);
        }

        function generateSamples(count) {
            const sampler = DISTRIBUTIONS[currentState.distKey].sampler;
            if (!sampler) { samplesOutput.innerHTML = 'Sampling not supported.'; return; }
            const newSamples = Array.from({ length: count }, () => sampler(currentState.params));
            currentState.samples.push(...newSamples);
            const formattedSamples = newSamples.map(s => Number.isInteger(s) ? s : s.toFixed(4)).join('\n');
            if (samplesOutput.innerHTML.includes('not supported')) samplesOutput.innerHTML = '';
            samplesOutput.innerHTML += (samplesOutput.innerHTML ? '\n' : '') + formattedSamples;
            samplesOutput.scrollTop = samplesOutput.scrollHeight;
            updatePlot();
        }

        function update(options = {}) {
            const config = DISTRIBUTIONS[currentState.distKey]; const params = {}; let allValid = true;
            config.params.forEach(p => { const input = document.getElementById(`param-${p.id}`); if (input.checkValidity()){ params[p.id] = parseFloat(input.value); } else { allValid = false; } });
            if (!allValid) return;
            currentState.params = params; currentState.jstat = config.jStat(params);
            const sampler = config.sampler; sampleBtn1.disabled = !sampler; sampleBtn10.disabled = !sampler;
            updateStats(); updatePlot();
            if (!options.fromURL) updateURL();
        }

        function updateStats() {
            const config = DISTRIBUTIONS[currentState.distKey]; if (!currentState.jstat) return;
            const quantile = (prob) => config.inv(prob, currentState.jstat, currentState.params);
            const mean = config.mean(currentState.params); const variance = config.variance(currentState.params);
            document.getElementById('stat-mean').textContent = isFinite(mean) ? mean.toFixed(4) : '∞';
            document.getElementById('stat-variance').textContent = isFinite(variance) ? variance.toFixed(4) : '∞';
            document.getElementById('stat-stddev').textContent = isFinite(variance) ? Math.sqrt(variance).toFixed(4) : '∞';
            document.getElementById('stat-q1').textContent = quantile(0.25).toFixed(4);
            document.getElementById('stat-median').textContent = quantile(0.5).toFixed(4);
            document.getElementById('stat-q3').textContent = quantile(0.75).toFixed(4);
            const intervals = { '50': [quantile(0.25), quantile(0.75)], '90': [quantile(0.05), quantile(0.95)], '95': [quantile(0.025), quantile(0.975)], '99': [quantile(0.005), quantile(0.995)] };
            Object.entries(intervals).forEach(([key, val]) => { document.getElementById(`stat-int${key}`).textContent = `[${val[0].toFixed(2)}, ${val[1].toFixed(2)}]`; });
        }

        function updatePlot() {
            const config = DISTRIBUTIONS[currentState.distKey]; const j = currentState.jstat; if (!j) return;
            document.getElementById('shading-controls').style.display = config.type === 'discrete' ? 'none' : 'flex';
            const svgRect = svg.node().getBoundingClientRect(); width = svgRect.width - margin.left - margin.right; height = svgRect.height - margin.top - margin.bottom;
            plotArea.attr("transform", `translate(${margin.left},${margin.top})`); dragLayer.attr("transform", `translate(${margin.left},${margin.top})`);
            const xDomain = config.domain(currentState.params, j); xScale.domain(xDomain).range([0, width]);
            xAxis.attr("transform", `translate(${margin.left}, ${height + margin.top})`).call(d3.axisBottom(xScale));
            let plotData, yMax;
            if (config.type === 'continuous') { plotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 500).map(x => ({ x: x, y: config.pdfpmf(x, j, currentState.params) })); yMax = d3.max(plotData, d => d.y); }
            else { plotData = d3.range(Math.floor(xDomain[0]), Math.ceil(xDomain[1])).map(x => ({ x: x, y: config.pdfpmf(x, j, currentState.params) })); yMax = d3.max(plotData, d => d.y); }
            yScale.domain([0, yMax * 1.1]).range([height, 0]); yAxis.attr("transform", `translate(${margin.left}, ${margin.top})`).call(d3.axisLeft(yScale).ticks(5));
            plotArea.selectAll("*").remove(); dragLayer.selectAll("*").remove();
            const intervalValue = intervalSelect.value;
            if (config.type === 'continuous' && intervalValue !== '0') {
                const quantile = (prob) => config.inv(prob, j, currentState.params); let lower, upper;
                if (intervalValue.startsWith('p')) { const p = parseFloat(intervalValue.substring(1)) / 100; lower = quantile((1 - p) / 2); upper = quantile(1 - (1 - p) / 2); }
                else { const numSigmas = parseInt(intervalValue.substring(1)); const mean = config.mean(currentState.params); const stddev = Math.sqrt(config.variance(currentState.params)); if(isFinite(stddev)) { lower = mean - numSigmas * stddev; upper = mean + numSigmas * stddev; } }
                if (lower !== undefined) { const area = d3.area().x(d => xScale(d.x)).y0(height).y1(d => yScale(d.y)); plotArea.append("path").datum(plotData.filter(d => d.x >= lower && d.x <= upper)).attr("class", "area-path").attr("d", area); }
            }
            if (config.type === 'continuous') { plotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y))); }
            else { plotArea.selectAll(".bar-main").data(plotData.filter(d => d.y > 0)).enter().append("rect").attr("class", "bar").attr("x", d => xScale(d.x - 0.4)).attr("y", d => yScale(d.y)).attr("width", Math.max(1, xScale(0.8) - xScale(0))).attr("height", d => height - yScale(d.y)); }
            plotArea.selectAll(".sample-dot").data(currentState.samples).enter().append("circle").attr("class", "sample-dot").attr("cx", d => xScale(d)).attr("cy", height).attr("r", 3).attr("fill", "black");
            setupInteractionLayer();
        }

        function setupInteractionLayer() {
            const config = DISTRIBUTIONS[currentState.distKey]; const focus = plotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            let dragState = { startX: null, isDragging: false }; let touchDragState = {};
            const interactionRect = svg.append("rect").attr("transform", `translate(${margin.left},${margin.top})`).style("fill", "none").style("pointer-events", "all").style("touch-action", "none").attr("width", width).attr("height", height);
            function calculateAndDisplayArea(pixel1, pixel2) {
                if (Math.abs(pixel1 - pixel2) < 5) { dragLayer.selectAll("*").remove(); return; }
                const x0 = xScale.invert(pixel1), x1 = xScale.invert(pixel2); const lower = Math.min(x0, x1), upper = Math.max(x0, x1); let area, text;
                if (config.type === 'discrete') { const lowerBound = Math.ceil(lower), upperBound = Math.floor(upper); area = (upperBound < lowerBound) ? 0 : config.cdf(upperBound, currentState.jstat, currentState.params) - config.cdf(lowerBound - 1, currentState.jstat, currentState.params); text = `P(${lowerBound} ≤ X ≤ ${upperBound}) = ${area.toFixed(4)}`; }
                else { area = config.cdf(upper, currentState.jstat, currentState.params) - config.cdf(lower, currentState.jstat, currentState.params); text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`; }
                dragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
            }
            const drag = d3.drag().filter(event => !event.touches).on("start", (event) => { const [x_coord] = d3.pointer(event, interactionRect.node()); dragState.isDragging = true; dragState.startX = x_coord; dragLayer.selectAll("*").remove(); dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; }).on("drag", (event) => { const [currentX] = d3.pointer(event, interactionRect.node()); const x = Math.min(dragState.startX, currentX), w = Math.abs(currentX - dragState.startX); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }).on("end", (event) => { dragState.isDragging = false; const [endX, endY] = d3.pointer(event, interactionRect.node()); if (endX >= 0 && endX <= width && endY >= 0 && endY <= height) { tooltip.style.opacity = 1; } calculateAndDisplayArea(dragState.startX, endX); });
            interactionRect.call(drag);
            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, document.getElementById('plot-container')); tooltip.style.left = tipX + "px"; tooltip.style.top = tipY + "px";
                const [x_coord] = d3.pointer(event, interactionRect.node()); const x_val = xScale.invert(x_coord); let y_val, display_x = x_val;
                if (config.type === 'continuous') { y_val = config.pdfpmf(x_val, currentState.jstat, currentState.params); } else { display_x = Math.round(x_val); y_val = config.pdfpmf(display_x, currentState.jstat, currentState.params); }
                focus.attr("cx", xScale(display_x)).attr("cy", yScale(y_val)); tooltip.innerHTML = `x: ${display_x.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }
            interactionRect.on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); tooltip.style.opacity = 1; }}).on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); tooltip.style.opacity = 0; }}).on("mousemove", (event) => { if (dragState.isDragging) return; updateTooltip(event); });
            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 2) { event.preventDefault(); touchDragState.isDragging = true; const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; dragLayer.selectAll("*").remove(); dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; focus.style.opacity = 0; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1) { event.preventDefault(); dragLayer.selectAll("*").remove(); updateTooltip(event.touches[0]); focus.style.opacity = 1; tooltip.style.opacity = 1; }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2 && touchDragState.isDragging) { event.preventDefault(); const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1 && !touchDragState.isDragging) { event.preventDefault(); updateTooltip(event.touches[0]); }
            });
            node.addEventListener('touchend', (event) => {
                if (touchDragState.isDragging) { event.preventDefault(); calculateAndDisplayArea(touchDragState.x1, touchDragState.x2); touchDragState = {}; }
                if (event.touches.length === 0) { focus.style.opacity = 0; tooltip.style.opacity = 0; }
            });
        }

        return {
            init: () => {
                Object.keys(DISTRIBUTIONS).forEach(key => distSelect.appendChild(new Option(DISTRIBUTIONS[key].name, key)));
                distSelect.addEventListener('change', () => handleDistChange());
                paramInputs.addEventListener('input', () => update());
                intervalSelect.addEventListener('change', () => update());
                sampleBtn1.addEventListener('click', () => generateSamples(1));
                sampleBtn10.addEventListener('click', () => generateSamples(10));
                document.getElementById('sample-clear-btn').addEventListener('click', () => { samplesOutput.innerHTML = ''; currentState.samples = []; if (currentState.jstat) updatePlot(); });
                window.addEventListener('resize', () => { if (currentState.jstat) updatePlot(); });
                const resizeObserver = new ResizeObserver(() => {
                    if (currentState.jstat) setTimeout(updatePlot, 0);
                });
                resizeObserver.observe(document.querySelector('#distributions-app .plot-svg-wrapper'));
                handleDistChange();
            },
            updateFromURL: (params) => {
                const dist = params.get('dist');
                if (dist && DISTRIBUTIONS[dist]) {
                    distSelect.value = dist;
                    handleDistChange({ fromURL: true });
                    const config = DISTRIBUTIONS[dist];
                    config.params.forEach(p => {
                        if (params.has(p.id)) {
                            const val = params.get(p.id);
                            const inputEl = document.getElementById(`param-${p.id}`);
                            if (inputEl) {
                                inputEl.value = val;
                                inputEl.dispatchEvent(new Event('change'));
                                inputEl.dispatchEvent(new Event('input'));
                            }
                        }
                    });
                    update({ fromURL: true });
                } else {
                    handleDistChange();
                }
            }
        };
    })();

    const CONTINUOUS_DISTRIBUTIONS = {
        uniform: DISTRIBUTIONS.uniform,
        normal: DISTRIBUTIONS.normal,
        exponential: DISTRIBUTIONS.exponential,
        gamma: DISTRIBUTIONS.gamma,
        beta: DISTRIBUTIONS.beta,
        pareto: DISTRIBUTIONS.pareto,
        lognormal: DISTRIBUTIONS.lognormal,
        weibull: DISTRIBUTIONS.weibull,
    };

    const orderStatisticsApp = (() => {
        const distSelect = document.getElementById('os-dist-select');
        const paramInputs = document.getElementById('os-param-inputs');
        const intervalSelect = document.getElementById('os-interval-select');
        const nInput = document.getElementById('os-n');
        const kInput = document.getElementById('os-k');

        let currentState = { distKey: 'uniform', params: {}, n: 10, k: 5, jstat: null, mean: null, variance: null };
        const svg = d3.select("#os-plot-svg");
        const margin = { top: 20, right: 30, bottom: 40, left: 50 };
        let width, height;
        const xScale = d3.scaleLinear(), yScale = d3.scaleLinear();
        const xAxis = svg.append("g").attr("class", "x-axis axis");
        const yAxis = svg.append("g").attr("class", "y-axis axis");
        const plotArea = svg.append("g").attr("class", "plot-area");
        const dragLayer = svg.append("g").attr("class", "drag-layer");
        const tooltip = document.getElementById('os-tooltip');

        function orderStatPDF(x, distConfig, params, n, k, j) {
            if (k > n || k < 1 || !isFinite(x)) return 0;
            const fx = distConfig.pdfpmf(x, j, params);
            const Fx = distConfig.cdf(x, j, params);
            if (fx <= 0 || Fx <= 0 || Fx >= 1) return 0;
            const logTerm = (k - 1) * Math.log(Fx) + (n - k) * Math.log(1 - Fx);
            const logBeta = jStat.gammaln(k) + jStat.gammaln(n - k + 1) - jStat.gammaln(n + 1);
            const logPDF = -logBeta + Math.log(fx) + logTerm;
            return Math.exp(logPDF);
        }

        function orderStatInv(p, distConfig, params, n, k, j) {
            const u = jStat.beta.inv(p, k, n - k + 1);
            return distConfig.inv(u, j, params);
        }

        function integrate(f, a, b, n_steps) {
            if (a >= b) return 0;
            n_steps = n_steps % 2 === 0 ? n_steps : n_steps + 1;
            let h = (b - a) / n_steps;
            let sum = f(a) + f(b);
            for (let i = 1; i < n_steps; i += 2) {
                sum += 4 * f(a + i * h);
            }
            for (let i = 2; i < n_steps - 1; i += 2) {
                sum += 2 * f(a + i * h);
            }
            return sum * h / 3;
        }

        function update() {
            const distKey = distSelect.value;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            const params = {};
            let allValid = true;
            config.params.forEach(p => {
                const input = document.getElementById(`os-param-${p.id}`);
                if (input.checkValidity()) {
                    params[p.id] = parseFloat(input.value);
                } else {
                    allValid = false;
                }
            });
            const n = parseInt(nInput.value);
            const k = parseInt(kInput.value);
            if (!allValid || isNaN(n) || isNaN(k) || k > n || k < 1) return;

            currentState = { distKey, params, n, k, jstat: config.jStat(params) };
            updateStats();
            updatePlot();
            updateURL();
        }

        function handleDistChange() {
            currentState.distKey = distSelect.value;
            const config = CONTINUOUS_DISTRIBUTIONS[currentState.distKey];
            paramInputs.innerHTML = '';
            config.params.forEach(p => {
                const group = document.createElement('div');
                group.className = 'param-group';
                group.innerHTML = `<label for="os-param-${p.id}">${p.name}</label><input type="number" id="os-param-${p.id}" data-param="${p.id}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}">`;
                paramInputs.appendChild(group);
            });
            update();
        }

        function updateStats() {
            const { distKey, params, n, k, jstat } = currentState;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];

            const quantile = (p) => orderStatInv(p, config, params, n, k, jstat);

            document.getElementById('os-stat-q1').textContent = quantile(0.25).toFixed(4);
            document.getElementById('os-stat-median').textContent = quantile(0.5).toFixed(4);
            document.getElementById('os-stat-q3').textContent = quantile(0.75).toFixed(4);
            const intervals = { '50': [quantile(0.25), quantile(0.75)], '90': [quantile(0.05), quantile(0.95)], '95': [quantile(0.025), quantile(0.975)], '99': [quantile(0.005), quantile(0.995)] };
            Object.entries(intervals).forEach(([key, val]) => {
                document.getElementById(`os-stat-int${key}`).textContent = `[${val[0].toFixed(2)}, ${val[1].toFixed(2)}]`;
            });

            const meanIntegrand = u => config.inv(u, jstat, params) * jStat.beta.pdf(u, k, n - k + 1);
            const mean = integrate(meanIntegrand, 1e-6, 1-1e-6, 1000);
            currentState.mean = mean;
            document.getElementById('os-stat-mean').textContent = isFinite(mean) ? mean.toFixed(4) : 'N/A';

            if (isFinite(mean)) {
                const varianceIntegrand = u => Math.pow(config.inv(u, jstat, params) - mean, 2) * jStat.beta.pdf(u, k, n - k + 1);
                const variance = integrate(varianceIntegrand, 1e-6, 1 - 1e-6, 1000);
                currentState.variance = variance;
                document.getElementById('os-stat-variance').textContent = isFinite(variance) ? variance.toFixed(4) : 'N/A';
                document.getElementById('os-stat-stddev').textContent = isFinite(variance) ? Math.sqrt(variance).toFixed(4) : 'N/A';
            } else {
                 currentState.variance = null;
                 document.getElementById('os-stat-variance').textContent = 'N/A';
                 document.getElementById('os-stat-stddev').textContent = 'N/A';
            }
        }

        function updatePlot() {
            const { distKey, params, n, k, jstat } = currentState;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            if (!jstat) return;

            const svgRect = svg.node().getBoundingClientRect();
            width = svgRect.width - margin.left - margin.right;
            height = svgRect.height - margin.top - margin.bottom;
            plotArea.attr("transform", `translate(${margin.left},${margin.top})`);
            dragLayer.attr("transform", `translate(${margin.left},${margin.top})`);

            const lowerBound = orderStatInv(0.001, config, params, n, k, jstat);
            const upperBound = orderStatInv(0.999, config, params, n, k, jstat);

            if (!isFinite(lowerBound) || !isFinite(upperBound) || lowerBound >= upperBound) {
                plotArea.selectAll("*").remove();
                return;
            }

            const xDomain = [lowerBound, upperBound];
            xScale.domain(xDomain).range([0, width]);
            xAxis.attr("transform", `translate(${margin.left}, ${height + margin.top})`).call(d3.axisBottom(xScale));

            const plotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 500).map(x => ({ x: x, y: orderStatPDF(x, config, params, n, k, jstat) }));
            const yMax = d3.max(plotData, d => d.y);
            yScale.domain([0, (isFinite(yMax) ? yMax : 1) * 1.1]).range([height, 0]);
            yAxis.attr("transform", `translate(${margin.left}, ${margin.top})`).call(d3.axisLeft(yScale).ticks(5));

            plotArea.selectAll("*").remove();
            dragLayer.selectAll("*").remove();

            const intervalValue = intervalSelect.value;
            if (intervalValue !== '0') {
                const quantile = (p) => orderStatInv(p, config, params, n, k, jstat);
                let lower, upper;
                if (intervalValue.startsWith('p')) {
                    const p = parseFloat(intervalValue.substring(1)) / 100;
                    lower = quantile((1 - p) / 2);
                    upper = quantile(1 - (1 - p) / 2);
                } else {
                    const numSigmas = parseInt(intervalValue.substring(1));
                    const mean = currentState.mean;
                    const stddev = Math.sqrt(currentState.variance);
                    if(isFinite(stddev)) {
                        lower = mean - numSigmas * stddev;
                        upper = mean + numSigmas * stddev;
                    }
                }
                if (lower !== undefined) {
                    const area = d3.area()
                        .x(d => xScale(d.x))
                        .y0(height)
                        .y1(d => yScale(d.y));
                    plotArea.append("path")
                        .datum(plotData.filter(d => d.x >= lower && d.x <= upper))
                        .attr("class", "area-path")
                        .attr("d", area);
                }
            }

            plotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)));

            setupInteractionLayer();
        }

        function setupInteractionLayer() {
            const focus = plotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            let dragState = { startX: null, isDragging: false }; let touchDragState = {};
            const interactionRect = svg.append("rect").attr("transform", `translate(${margin.left},${margin.top})`).style("fill", "none").style("pointer-events", "all").style("touch-action", "none").attr("width", width).attr("height", height);

            function getOrderStatCDF(x) {
                const { distKey, params, n, k, jstat } = currentState;
                const config = CONTINUOUS_DISTRIBUTIONS[distKey];
                const Fx = config.cdf(x, jstat, params);
                return jStat.beta.cdf(Fx, k, n - k + 1);
            }

            function calculateAndDisplayArea(pixel1, pixel2) {
                if (Math.abs(pixel1 - pixel2) < 5) { dragLayer.selectAll("*").remove(); return; }
                const x0 = xScale.invert(pixel1), x1 = xScale.invert(pixel2);
                const lower = Math.min(x0, x1), upper = Math.max(x0, x1);
                const area = getOrderStatCDF(upper) - getOrderStatCDF(lower);
                const text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`;
                dragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
            }

            const drag = d3.drag().filter(event => !event.touches).on("start", (event) => { const [x_coord] = d3.pointer(event, interactionRect.node()); dragState.isDragging = true; dragState.startX = x_coord; dragLayer.selectAll("*").remove(); dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; }).on("drag", (event) => { const [currentX] = d3.pointer(event, interactionRect.node()); const x = Math.min(dragState.startX, currentX), w = Math.abs(currentX - dragState.startX); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }).on("end", (event) => { dragState.isDragging = false; const [endX, endY] = d3.pointer(event, interactionRect.node()); if (endX >= 0 && endX <= width && endY >= 0 && endY <= height) { tooltip.style.opacity = 1; } calculateAndDisplayArea(dragState.startX, endX); });
            interactionRect.call(drag);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, document.getElementById('os-plot-container'));
                tooltip.style.left = tipX + "px";
                tooltip.style.top = tipY + "px";
                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                const y_val = orderStatPDF(x_val, CONTINUOUS_DISTRIBUTIONS[currentState.distKey], currentState.params, currentState.n, currentState.k, currentState.jstat);
                focus.attr("cx", xScale(x_val)).attr("cy", yScale(y_val));
                tooltip.innerHTML = `x: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }

            interactionRect.on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); tooltip.style.opacity = 1; }}).on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); tooltip.style.opacity = 0; }}).on("mousemove", (event) => { if (dragState.isDragging) return; updateTooltip(event); });
            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 2) { event.preventDefault(); touchDragState.isDragging = true; const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; dragLayer.selectAll("*").remove(); dragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", height); tooltip.style.opacity = 0; focus.style.opacity = 0; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1) { event.preventDefault(); dragLayer.selectAll("*").remove(); updateTooltip(event.touches[0]); focus.style.opacity = 1; tooltip.style.opacity = 1; }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2 && touchDragState.isDragging) { event.preventDefault(); const pointers = d3.pointers(event, node); touchDragState.x1 = pointers[0][0]; touchDragState.x2 = pointers[1][0]; const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2); dragLayer.select(".drag-selection").attr("x", x).attr("width", w); }
                else if (event.touches.length === 1 && !touchDragState.isDragging) { event.preventDefault(); updateTooltip(event.touches[0]); }
            });
            node.addEventListener('touchend', (event) => {
                if (touchDragState.isDragging) { event.preventDefault(); calculateAndDisplayArea(touchDragState.x1, touchDragState.x2); touchDragState = {}; }
                if (event.touches.length === 0) { focus.style.opacity = 0; tooltip.style.opacity = 0; }
            });
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('dist', currentState.distKey);
            for(const p of CONTINUOUS_DISTRIBUTIONS[currentState.distKey].params) {
                params.set(p.id, currentState.params[p.id]);
            }
            params.set('n', currentState.n);
            params.set('k', currentState.k);
            history.replaceState(null, '', '#order-statistics?' + params.toString());
        }

        return {
            init: () => {
                Object.keys(CONTINUOUS_DISTRIBUTIONS).forEach(key => distSelect.appendChild(new Option(CONTINUOUS_DISTRIBUTIONS[key].name, key)));
                distSelect.addEventListener('change', handleDistChange);
                intervalSelect.addEventListener('change', update);
                paramInputs.addEventListener('input', update);
                nInput.addEventListener('input', () => {
                    const old_n = currentState.n;
                    const old_k = currentState.k;
                    const new_n = parseInt(nInput.value);
                    if (old_k === old_n && new_n > old_n) {
                        kInput.value = new_n;
                    }
                    update();
                });
                kInput.addEventListener('input', update);
                window.addEventListener('resize', () => { if (currentState.jstat) updatePlot(); });
                const resizeObserver = new ResizeObserver(() => {
                    if (currentState.jstat) setTimeout(updatePlot, 0);
                });
                resizeObserver.observe(document.querySelector('#order-statistics-app .plot-svg-wrapper'));
                handleDistChange();
                renderMathInElement(document.getElementById('order-statistics-app'), {
                    delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                });
            },
            updateFromURL: (params) => {
                const dist = params.get('dist');
                if (dist && CONTINUOUS_DISTRIBUTIONS[dist]) {
                    distSelect.value = dist;
                    const config = CONTINUOUS_DISTRIBUTIONS[dist];
                    paramInputs.innerHTML = '';
                    config.params.forEach(p => {
                        const group = document.createElement('div');
                        group.className = 'param-group';
                        const value = params.has(p.id) ? params.get(p.id) : p.default;
                        group.innerHTML = `<label for="os-param-${p.id}">${p.name}</label><input type="number" id="os-param-${p.id}" data-param="${p.id}" value="${value}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}">`;
                        paramInputs.appendChild(group);
                    });
                    if (params.has('n')) nInput.value = params.get('n');
                    if (params.has('k')) kInput.value = params.get('k');
                    update();
                } else {
                    handleDistChange();
                }
            }
        };
    })();

    const bivariateNormalCDF = (x, y, rho) => {
        // Based on the `mnormt` R package, which uses numerical integration.
        if (x === Infinity) return jStat.normal.cdf(y, 0, 1);
        if (y === Infinity) return jStat.normal.cdf(x, 0, 1);
        if (x === -Infinity || y === -Infinity) return 0;
        if (rho === 0) return jStat.normal.cdf(x, 0, 1) * jStat.normal.cdf(y, 0, 1);
        if (rho === 1) return jStat.normal.cdf(Math.min(x, y), 0, 1);
        if (rho === -1) return Math.max(0, jStat.normal.cdf(x, 0, 1) + jStat.normal.cdf(y, 0, 1) - 1);
        if (Math.abs(rho) > 1) rho = Math.sign(rho);

        // Quadrant reduction logic to ensure x > 0, y > 0
        if (x < 0) {
            if (y < 0) {
                return bivariateNormalCDF(-x, -y, rho) - jStat.normal.cdf(-x, 0, 1) - jStat.normal.cdf(-y, 0, 1) + 1;
            } else { // y >= 0
                return jStat.normal.cdf(y, 0, 1) - bivariateNormalCDF(-x, y, -rho);
            }
        } else { // x >= 0
            if (y < 0) {
                return jStat.normal.cdf(x, 0, 1) - bivariateNormalCDF(x, -y, -rho);
            }
            // Now x,y >= 0. If rho < 0, one more reduction.
            if (rho < 0) {
                return jStat.normal.cdf(x, 0, 1) + jStat.normal.cdf(y, 0, 1) - 1 + bivariateNormalCDF(x, y, -rho);
            }
        }
        
        // At this point, x>=0, y>=0, rho>=0
        const h = x, k = y;
        const hk = h * k;
        const b = (h + k) * (h + k) / 2;
        const rho1 = (rho * hk - b) / (1 - rho * rho);
        const rho2 = (rho * hk + b) / (1 - rho * rho);
        let t = 0;
        if (rho1 > -100) t = Math.exp(rho1) * (1 - rho*rho * (1 + rho1));
        if (rho2 > -100) t -= Math.exp(rho2) * (1 - rho*rho * (1 + rho2));
        t /= (2 * Math.PI * Math.sqrt(1-rho*rho));

        return -t + jStat.normal.cdf(x, 0, 1) * jStat.normal.cdf(y, 0, 1);
    };

    function setupMoveControls(containerSelector) {
        const container = document.querySelector(containerSelector);
        if (!container) return;

        container.addEventListener('click', e => {
            const moveBtn = e.target.closest('.move-btn');
            if (!moveBtn) return;
            
            const panel = moveBtn.closest('.panel');
            if (!panel || panel.parentElement !== container) return;

            if (moveBtn.classList.contains('move-up')) {
                const prev = panel.previousElementSibling;
                if (prev) {
                    container.insertBefore(panel, prev);
                }
            } else if (moveBtn.classList.contains('move-down')) {
                const next = panel.nextElementSibling;
                if (next) {
                    container.insertBefore(panel, next.nextElementSibling);
                }
            }
        });
    }

    const gaussianCopulaApp = (() => {
        let currentState = {
            distKeyX: 'normal', paramsX: {}, jstatX: null,
            distKeyY: 'normal', paramsY: {}, jstatY: null,
            rho: 0.5, samples: [], conditional: null,
        };

        function integrate(f, a, b, n_steps = 200) {
            if (a >= b) return 0;
            n_steps = n_steps % 2 === 0 ? n_steps : n_steps + 1;
            let h = (b - a) / n_steps;
            let sum = f(a) + f(b);
            for (let i = 1; i < n_steps; i += 2) {
                sum += 4 * f(a + i * h);
            }
            for (let i = 2; i < n_steps - 1; i += 2) {
                sum += 2 * f(a + i * h);
            }
            return sum * h / 3;
        }

        const margin = { joint: { top: 10, right: 10, bottom: 40, left: 50 }, marginalX: { top: 10, right: 10, bottom: 5, left: 50 }, marginalY: { top: 10, right: 30, bottom: 40, left: 5 }, density: { top: 20, right: 30, bottom: 40, left: 50 } };

        // Scatter plot elements
        const jointSvg = d3.select("#gc-joint-plot-svg");
        const marginalXSvg = d3.select("#gc-marginal-x-svg");
        const marginalYSvg = d3.select("#gc-marginal-y-svg");
        
        const jointXScale = d3.scaleLinear(), jointYScale = d3.scaleLinear();
        const jointXAxis = jointSvg.append("g").attr("class", "x-axis axis");
        const jointYAxis = jointSvg.append("g").attr("class", "y-axis axis");
        const jointPlotArea = jointSvg.append("g").attr("class", "plot-area");
        
        const marginalXYScale = d3.scaleLinear();
        const marginalXPlotArea = marginalXSvg.append("g").attr("class", "plot-area");
        
        const marginalYXScale = d3.scaleLinear();
        const marginalYPlotArea = marginalYSvg.append("g").attr("class", "plot-area");

        // Density plot elements
        const densitySvg = d3.select("#gc-density-plot-svg");
        const densityTooltip = d3.select("#gc-density-tooltip");
        let densityWidth, densityHeight;
        const densityXScale = d3.scaleLinear(), densityYScale = d3.scaleLinear();
        const densityXAxis = densitySvg.append("g").attr("class", "x-axis axis");
        const densityYAxis = densitySvg.append("g").attr("class", "y-axis axis");
        const densityPlotArea = densitySvg.append("g").attr("class", "plot-area");
        const densityDragLayer = densitySvg.append("g").attr("class", "drag-layer");

        let condVarSelect, condValueInput;

        const updateCondValueToMean = () => {
            const condVar = condVarSelect.value;
            const distKey = (condVar === 'X') ? currentState.distKeyX : currentState.distKeyY;
            const params = (condVar === 'X') ? currentState.paramsX : currentState.paramsY;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            const mean = config.mean(params);
            if (isFinite(mean)) {
                condValueInput.value = mean.toFixed(4);
            }
        };

        function handleDistChange(varName) {
            const distSelect = document.getElementById(`gc-dist-select-${varName}`);
            const paramInputs = document.getElementById(`gc-param-inputs-${varName}`);
            const distKey = distSelect.value;
            currentState[`distKey${varName.toUpperCase()}`] = distKey;
            const config = CONTINUOUS_DISTRIBUTIONS[distKey];
            paramInputs.innerHTML = '';
            config.params.forEach(p => {
                const group = document.createElement('div');
                group.className = 'param-group';
                group.innerHTML = `<label for="gc-param-${p.id}-${varName}">${p.name}</label><input type="number" id="gc-param-${p.id}-${varName}" value="${p.default}" ${p.min === undefined ? '' : `min="${p.min}"`} ${p.max === undefined ? '' : `max="${p.max}"`} step="${p.step}">`;
                paramInputs.appendChild(group);
            });
            update({ distChangedFor: varName });
        }

        function update(options = {}) {
            let allValid = true;
            const readParams = (varName) => {
                const distKey = currentState[`distKey${varName.toUpperCase()}`];
                const config = CONTINUOUS_DISTRIBUTIONS[distKey];
                const params = {};
                config.params.forEach(p => {
                    const input = document.getElementById(`gc-param-${p.id}-${varName}`);
                    if (input && input.checkValidity()) {
                        params[p.id] = parseFloat(input.value);
                    } else {
                        allValid = false;
                    }
                });
                return params;
            };

            currentState.paramsX = readParams('x');
            currentState.paramsY = readParams('y');
            
            if (options.distChangedFor && condVarSelect) {
                const currentCondVar = condVarSelect.value.toLowerCase();
                if (options.distChangedFor === currentCondVar) {
                    updateCondValueToMean();
                }
            }
            
            currentState.rho = parseFloat(document.getElementById('gc-rho-input').value);
            document.getElementById('gc-rho-value').textContent = currentState.rho.toFixed(2);
            if (!allValid) return;

            currentState.jstatX = CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].jStat(currentState.paramsX);
            currentState.jstatY = CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].jStat(currentState.paramsY);
            
            updateJointAndMarginalPlots();
            plotConditional();
            if (!options.fromURL) updateURL();
        }

        function generateSamples(count) {
            const { distKeyX, paramsX, jstatX, distKeyY, paramsY, jstatY, rho } = currentState;
            const configX = CONTINUOUS_DISTRIBUTIONS[distKeyX];
            const configY = CONTINUOUS_DISTRIBUTIONS[distKeyY];

            for (let i = 0; i < count; i++) {
                const z1 = jStat.normal.sample(0, 1);
                const z2 = jStat.normal.sample(0, 1);
                const x_prime = z1;
                const y_prime = rho * z1 + Math.sqrt(1 - rho * rho) * z2;
                const u = jStat.normal.cdf(x_prime, 0, 1);
                const v = jStat.normal.cdf(y_prime, 0, 1);
                const x = configX.inv(u, jstatX, paramsX);
                const y = configY.inv(v, jstatY, paramsY);
                if (isFinite(x) && isFinite(y)) {
                    currentState.samples.push([x, y]);
                }
            }
            updateJointAndMarginalPlots();
        }
        
        function plotConditional() {
            const condVar = document.getElementById('gc-cond-var').value;
            const condType = document.getElementById('gc-cond-type').value;
            const condValue = parseFloat(document.getElementById('gc-cond-value').value);

            let config1, params1, jstat1, config2, params2, jstat2;
            if (condVar === 'X') {
                [config1, params1, jstat1] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX], currentState.paramsX, currentState.jstatX];
                [config2, params2, jstat2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY], currentState.paramsY, currentState.jstatY];
            } else {
                [config1, params1, jstat1] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY], currentState.paramsY, currentState.jstatY];
                [config2, params2, jstat2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX], currentState.paramsX, currentState.jstatX];
            }

            const rho = (condVar === 'X') ? currentState.rho : currentState.rho;
            const u = config1.cdf(condValue, jstat1, params1);
            const x_prime = jStat.normal.inv(u, 0, 1);

            let condPdf;
            if (condType === 'eq') {
                condPdf = y => {
                    const v = config2.cdf(y, jstat2, params2);
                    const y_prime = jStat.normal.inv(v, 0, 1);
                    if (!isFinite(y_prime)) return 0;
                    const f_y = config2.pdfpmf(y, jstat2, params2);
                    const phi_y_prime = jStat.normal.pdf(y_prime, 0, 1);
                    if (phi_y_prime < 1e-9) return 0;
                    const term = (y_prime - rho * x_prime) / Math.sqrt(1 - rho * rho);
                    return (f_y / phi_y_prime) * (1 / Math.sqrt(1 - rho * rho)) * jStat.normal.pdf(term, 0, 1);
                };
            } else if (condType === 'ge') {
                if (1 - u < 1e-9) {
                    condPdf = y => 0;
                } else {
                    condPdf = y => {
                        const v = config2.cdf(y, jstat2, params2);
                        const y_prime = jStat.normal.inv(v, 0, 1);
                        if (!isFinite(y_prime)) return 0;
                        const f_y = config2.pdfpmf(y, jstat2, params2);
                        const term = (x_prime - rho * y_prime) / Math.sqrt(1 - rho*rho);
                        return (f_y / (1 - u)) * (1 - jStat.normal.cdf(term, 0, 1));
                    };
                }
            } else { // le
                if (u < 1e-9) {
                    condPdf = y => 0;
                } else {
                    condPdf = y => {
                        const v = config2.cdf(y, jstat2, params2);
                        const y_prime = jStat.normal.inv(v, 0, 1);
                        if (!isFinite(y_prime)) return 0;
                        const f_y = config2.pdfpmf(y, jstat2, params2);
                        const term = (x_prime - rho * y_prime) / Math.sqrt(1 - rho*rho);
                        return (f_y / u) * jStat.normal.cdf(term, 0, 1);
                    };
                }
            }

            currentState.conditional = { condPdf, condVar, condType, condValue };
            updateDensityPlot();
        }


        function inverseConditionalCdf(p, condInfo, domain) {
            if (p <= 0) return domain[0];
            if (p >= 1) return domain[1];

            if (condInfo.condType === 'eq') {
                let config2, jstat2, params2;
                if (condInfo.condVar === 'X') {
                    [config2, jstat2, params2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY], currentState.jstatY, currentState.paramsY];
                } else {
                    [config2, jstat2, params2] = [CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX], currentState.jstatX, currentState.paramsX];
                }
                const rho = currentState.rho;
                const u = CONTINUOUS_DISTRIBUTIONS[condInfo.condVar === 'X' ? currentState.distKeyX : currentState.distKeyY].cdf(condInfo.condValue, condInfo.condVar === 'X' ? currentState.jstatX : currentState.jstatY, condInfo.condVar === 'X' ? currentState.paramsX : currentState.paramsY);
                const x_prime = jStat.normal.inv(u, 0, 1);
                const val = jStat.normal.inv(p, 0, 1) * Math.sqrt(1 - rho*rho) + rho * x_prime;
                return config2.inv(jStat.normal.cdf(val, 0, 1), jstat2, params2);
            }

            // For ge and le conditions, use numerical inversion (binary search) on integrated PDF
            let low = domain[0], high = domain[1];
            // Normalize total integral to 1 for robustness
            const total_integral = integrate(condInfo.condPdf, domain[0], domain[1], 400);

            for (let i = 0; i < 50; i++) { // 50 iterations for precision
                const mid = (low + high) / 2;
                const candidate = integrate(condInfo.condPdf, domain[0], mid, 200) / total_integral;
                if (candidate < p) {
                    low = mid;
                } else {
                    high = mid;
                }
            }
            return (low + high) / 2;
        }

        function updateJointAndMarginalPlots() {
            const jointRect = jointSvg.node().getBoundingClientRect();
            const marginalXRect = marginalXSvg.node().getBoundingClientRect();
            const marginalYRect = marginalYSvg.node().getBoundingClientRect();
            if (jointRect.width <= 0) return;

            const jointWidth = jointRect.width - margin.joint.left - margin.joint.right;
            const jointHeight = jointRect.height - margin.joint.top - margin.joint.bottom;
            const marginalXHeight = marginalXRect.height - margin.marginalX.top - margin.marginalX.bottom;
            const marginalYWidth = marginalYRect.width - margin.marginalY.left - margin.marginalY.right;

            jointPlotArea.attr("transform", `translate(${margin.joint.left},${margin.joint.top})`);
            marginalXPlotArea.attr("transform", `translate(${margin.marginalX.left},${margin.marginalX.top})`);
            marginalYPlotArea.attr("transform", `translate(${margin.marginalY.left},${margin.marginalY.top})`);

            const { distKeyX, paramsX, jstatX, distKeyY, paramsY, jstatY, samples } = currentState;
            if (!jstatX || !jstatY) return;
            const configX = CONTINUOUS_DISTRIBUTIONS[distKeyX];
            const configY = CONTINUOUS_DISTRIBUTIONS[distKeyY];
            
            const xDomain = configX.domain(paramsX, jstatX);
            const yDomain = configY.domain(paramsY, jstatY);
            
            jointXScale.domain(xDomain).range([0, jointWidth]);
            jointYScale.domain(yDomain).range([jointHeight, 0]);

            jointXAxis.attr("transform", `translate(${margin.joint.left}, ${jointHeight + margin.joint.top})`).call(d3.axisBottom(jointXScale));
            jointYAxis.attr("transform", `translate(${margin.joint.left}, ${margin.joint.top})`).call(d3.axisLeft(jointYScale));

            jointSvg.selectAll(".plot-label").remove();
            jointSvg.append("text").attr("class", "plot-label").attr("x", margin.joint.left + jointWidth / 2).attr("y", jointHeight + margin.joint.top + 35).style("text-anchor", "middle").text("X");
            jointSvg.append("text").attr("class", "plot-label").attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(margin.joint.top + jointHeight / 2)).attr("dy", "1em").style("text-anchor", "middle").text("Y");

            jointPlotArea.selectAll(".scatter-dot").remove();
            jointPlotArea.selectAll(".scatter-dot").data(samples).enter().append("circle").attr("class", "scatter-dot").attr("cx", d => jointXScale(d[0])).attr("cy", d => jointYScale(d[1])).attr("r", 3);
            
            marginalXPlotArea.selectAll("*").remove();
            marginalYPlotArea.selectAll("*").remove();

            // Marginal X plot (top)
            const xPlotData = d3.range(xDomain[0], xDomain[1], (xDomain[1] - xDomain[0]) / 200).map(x => ({ x: x, y: configX.pdfpmf(x, jstatX, paramsX) }));
            const yMaxX = d3.max(xPlotData, d => d.y);
            marginalXYScale.domain([0, yMaxX * 1.1]).range([marginalXHeight, 0]);
            
            // Marginal Y plot (right)
            const yPlotData = d3.range(yDomain[0], yDomain[1], (yDomain[1] - yDomain[0]) / 200).map(y => ({ x: y, y: configY.pdfpmf(y, jstatY, paramsY) }));
            const yMaxY = d3.max(yPlotData, d => d.y);
            marginalYXScale.domain([0, yMaxY * 1.1]).range([0, marginalYWidth]);
            
            if (samples.length > 0) {
                // X histogram
                const xSamples = samples.map(d => d[0]);
                const xHistogram = d3.histogram().domain(jointXScale.domain()).thresholds(jointXScale.ticks(20))(xSamples);
                const xHistMax = d3.max(xHistogram, d => d.length) || 1;
                marginalXPlotArea.selectAll(".histogram-bar").data(xHistogram).enter().append("rect").attr("class", "histogram-bar")
                    .attr("x", d => jointXScale(d.x0) + 1).attr("width", d => Math.max(0, jointXScale(d.x1) - jointXScale(d.x0) - 1))
                    .attr("y", d => marginalXYScale(d.length * yMaxX / xHistMax)).attr("height", d => marginalXHeight - marginalXYScale(d.length * yMaxX / xHistMax));

                // Y histogram
                const ySamples = samples.map(d => d[1]);
                const yHistogram = d3.histogram().domain(jointYScale.domain()).thresholds(jointYScale.ticks(20))(ySamples);
                const yHistMax = d3.max(yHistogram, d => d.length) || 1;
                marginalYPlotArea.selectAll(".histogram-bar").data(yHistogram).enter().append("rect").attr("class", "histogram-bar")
                    .attr("y", d => jointYScale(d.x1) + 1).attr("height", d => Math.max(0, jointYScale(d.x0) - jointYScale(d.x1) - 1))
                    .attr("x", 0).attr("width", d => marginalYXScale(d.length * yMaxY / yHistMax));
            }
            
            marginalXPlotArea.append("path").datum(xPlotData).attr("class", "line-path").attr("d", d3.line().x(d => jointXScale(d.x)).y(d => marginalXYScale(d.y)));
            marginalYPlotArea.append("path").datum(yPlotData).attr("class", "line-path").attr("d", d3.line().x(d => marginalYXScale(d.y)).y(d => jointYScale(d.x)));
        }

        function updateDensityPlot() {
            const titleEl = document.getElementById('gc-density-plot-title');
            const controlsEl = document.getElementById('gc-density-controls');
            const meanEl = document.getElementById('gc-conditional-mean-display');

            if (!currentState.conditional) {
                densitySvg.style("display", "none");
                titleEl.style.display = 'none';
                controlsEl.style.display = 'none';
                meanEl.style.display = 'none';
                return;
            }
            densitySvg.style("display", "block");
            titleEl.style.display = 'block';
            controlsEl.style.display = 'flex';
            meanEl.style.display = 'block';

            const { condPdf, condVar, condType, condValue } = currentState.conditional;
            const otherVar = condVar === 'X' ? 'Y' : 'X';
            const typeSymbol = { eq: '=', ge: '≥', le: '≤' }[condType];
            titleEl.textContent = `Density of ${otherVar} | ${condVar} ${typeSymbol} ${condValue}`;
            
            const svgRect = densitySvg.node().getBoundingClientRect();
             if (svgRect.width <= 0) return;
            densityWidth = svgRect.width - margin.density.left - margin.density.right;
            densityHeight = svgRect.height - margin.density.top - margin.density.bottom;
            densityPlotArea.attr("transform", `translate(${margin.density.left},${margin.density.top})`);
            densityDragLayer.attr("transform", `translate(${margin.density.left},${margin.density.top})`);
            
            const { distKeyX, paramsX, jstatX, distKeyY, paramsY, jstatY } = currentState;
            
            const [domainConfig, domainParams, domainJstat] = (condVar === 'X') ?
                [CONTINUOUS_DISTRIBUTIONS[distKeyY], paramsY, jstatY] :
                [CONTINUOUS_DISTRIBUTIONS[distKeyX], paramsX, jstatX];

            const marginalDomain = domainConfig.domain(domainParams, domainJstat);
            const lowerBound = inverseConditionalCdf(0.001, currentState.conditional, marginalDomain);
            const upperBound = inverseConditionalCdf(0.999, currentState.conditional, marginalDomain);

            let plotDomain = [lowerBound, upperBound];
            if (!isFinite(plotDomain[0]) || !isFinite(plotDomain[1]) || plotDomain[0] >= plotDomain[1]) {
                plotDomain = marginalDomain;
            }
            const plotData = d3.range(plotDomain[0], plotDomain[1], (plotDomain[1] - plotDomain[0]) / 200).map(v => ({x: v, y: condPdf(v)})).filter(d => isFinite(d.y));
            
            const totalIntegral = integrate(condPdf, plotDomain[0], plotDomain[1], 400);
            const meanIntegrand = x => x * condPdf(x);
            const mean = integrate(meanIntegrand, plotDomain[0], plotDomain[1], 400) / totalIntegral;
            if (isFinite(mean)) {
                meanEl.textContent = `Mean: ${mean.toFixed(4)}`;
            } else {
                meanEl.textContent = 'Mean: N/A';
            }
            
            const yMax = d3.max(plotData, d => d.y);

            densityXScale.domain(plotDomain).range([0, densityWidth]);
            densityYScale.domain([0, (isFinite(yMax) ? yMax : 1) * 1.1]).range([densityHeight, 0]);

            densityXAxis.attr("transform", `translate(${margin.density.left}, ${densityHeight + margin.density.top})`).call(d3.axisBottom(densityXScale));
            densityYAxis.attr("transform", `translate(${margin.density.left}, ${margin.density.top})`).call(d3.axisLeft(densityYScale));
            
            densityPlotArea.selectAll("*").remove();
            densityDragLayer.selectAll("*").remove();

            const intervalValue = document.getElementById('gc-interval-select').value;
            if (intervalValue !== '0') {
                const p = parseFloat(intervalValue.substring(1)) / 100;
                const lower = inverseConditionalCdf((1 - p) / 2, currentState.conditional, plotDomain);
                const upper = inverseConditionalCdf(1 - (1 - p) / 2, currentState.conditional, plotDomain);
                if (lower !== undefined) {
                    const area = d3.area().x(d => densityXScale(d.x)).y0(densityHeight).y1(d => densityYScale(d.y));
                    densityPlotArea.append("path").datum(plotData.filter(d => d.x >= lower && d.x <= upper)).attr("class", "area-path").attr("d", area);
                }
            }
            
            densityPlotArea.append("path").datum(plotData).attr("class", "line-path").attr("d", d3.line().x(d => densityXScale(d.x)).y(d => densityYScale(d.y)));
            
            setupDensityInteractionLayer();
        }

        function setupDensityInteractionLayer() {
            const focus = densityPlotArea.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            let dragState = { startX: null, isDragging: false }; let touchDragState = {};
            const interactionRect = densitySvg.append("rect").attr("transform", `translate(${margin.density.left},${margin.density.top})`).style("fill", "none").style("pointer-events", "all").style("touch-action", "none").attr("width", densityWidth).attr("height", densityHeight);

            function calculateAndDisplayArea(pixel1, pixel2) {
                if (Math.abs(pixel1 - pixel2) < 5) { densityDragLayer.selectAll("*").remove(); return; }
                const x0 = densityXScale.invert(pixel1), x1 = densityXScale.invert(pixel2);
                const lower = Math.min(x0, x1), upper = Math.max(x0, x1);
                const area = integrate(currentState.conditional.condPdf, lower, upper);
                const text = `P(${lower.toFixed(2)} < X < ${upper.toFixed(2)}) = ${area.toFixed(4)}`;
                densityDragLayer.append("text").attr("class", "drag-text").attr("x", (pixel1 + pixel2) / 2).attr("y", -5).text(text);
            }

            const drag = d3.drag().filter(event => !event.touches).on("start", (event) => {
                const [x_coord] = d3.pointer(event, interactionRect.node());
                dragState = { isDragging: true, startX: x_coord };
                densityDragLayer.selectAll("*").remove();
                densityDragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", densityHeight);
                densityTooltip.style("opacity", 0);
            }).on("drag", (event) => {
                const [currentX] = d3.pointer(event, interactionRect.node());
                const x = Math.min(dragState.startX, currentX), w = Math.abs(currentX - dragState.startX);
                densityDragLayer.select(".drag-selection").attr("x", x).attr("width", w);
            }).on("end", (event) => {
                dragState.isDragging = false;
                const [endX] = d3.pointer(event, interactionRect.node());
                calculateAndDisplayArea(dragState.startX, endX);
            });

            interactionRect.call(drag);
            
            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, document.getElementById('gc-density-plot-container'));
                densityTooltip.style("left", tipX + "px").style("top", tipY + "px");
                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = densityXScale.invert(x_coord);
                const y_val = currentState.conditional.condPdf(x_val);
                focus.attr("cx", densityXScale(x_val)).attr("cy", densityYScale(y_val));
                densityTooltip.html(`x: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`);
            }

            interactionRect.on("mouseover", () => { if (!dragState.isDragging) { focus.style("opacity", 1); densityTooltip.style("opacity", 1); }})
                         .on("mouseout", () => { if (!dragState.isDragging) { focus.style("opacity", 0); densityTooltip.style("opacity", 0); }})
                         .on("mousemove", (event) => { if (!dragState.isDragging) { updateTooltip(event); }});

            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 2) {
                    event.preventDefault();
                    touchDragState.isDragging = true;
                    const pointers = d3.pointers(event, node);
                    touchDragState.x1 = pointers[0][0];
                    touchDragState.x2 = pointers[1][0];
                    densityDragLayer.selectAll("*").remove();
                    densityDragLayer.append("rect").attr("class", "drag-selection").attr("y", 0).attr("height", densityHeight);
                    densityTooltip.style("opacity", 0);
                    focus.style("opacity", 0);
                    const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2);
                    densityDragLayer.select(".drag-selection").attr("x", x).attr("width", w);
                } else if (event.touches.length === 1) {
                    event.preventDefault();
                    densityDragLayer.selectAll("*").remove();
                    updateTooltip(event.touches[0]);
                    focus.style("opacity", 1);
                    densityTooltip.style("opacity", 1);
                }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2 && touchDragState.isDragging) {
                    event.preventDefault();
                    const pointers = d3.pointers(event, node);
                    touchDragState.x1 = pointers[0][0];
                    touchDragState.x2 = pointers[1][0];
                    const x = Math.min(touchDragState.x1, touchDragState.x2), w = Math.abs(touchDragState.x1 - touchDragState.x2);
                    densityDragLayer.select(".drag-selection").attr("x", x).attr("width", w);
                } else if (event.touches.length === 1 && !touchDragState.isDragging) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                }
            });
            node.addEventListener('touchend', (event) => {
                if (touchDragState.isDragging) {
                    event.preventDefault();
                    calculateAndDisplayArea(touchDragState.x1, touchDragState.x2);
                    touchDragState = {};
                }
                if (event.touches.length === 0) {
                    focus.style("opacity", 0);
                    densityTooltip.style("opacity", 0);
                }
            });
        }
        
        function updateURL() {
            const params = new URLSearchParams();
            params.set('distX', currentState.distKeyX);
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyX].params.forEach(p => params.set(`${p.id}X`, currentState.paramsX[p.id]));
            params.set('distY', currentState.distKeyY);
            CONTINUOUS_DISTRIBUTIONS[currentState.distKeyY].params.forEach(p => params.set(`${p.id}Y`, currentState.paramsY[p.id]));
            params.set('rho', currentState.rho);
            history.replaceState(null, '', '#gaussian-copula?' + params.toString());
        }

        return {
            init: () => {
                const distSelectX = document.getElementById('gc-dist-select-x');
                const distSelectY = document.getElementById('gc-dist-select-y');
                Object.keys(CONTINUOUS_DISTRIBUTIONS).forEach(key => {
                    distSelectX.appendChild(new Option(CONTINUOUS_DISTRIBUTIONS[key].name, key));
                    distSelectY.appendChild(new Option(CONTINUOUS_DISTRIBUTIONS[key].name, key));
                });
                distSelectX.value = 'normal';
                distSelectY.value = 'normal';

                distSelectX.addEventListener('change', () => handleDistChange('x'));
                distSelectY.addEventListener('change', () => handleDistChange('y'));
                document.getElementById('gc-param-inputs-x').addEventListener('input', update);
                document.getElementById('gc-param-inputs-y').addEventListener('input', update);
                const rhoSlider = document.getElementById('gc-rho-slider');
                const rhoInput = document.getElementById('gc-rho-input');
                rhoSlider.addEventListener('input', () => {
                    rhoInput.value = rhoSlider.value;
                    update();
                });
                rhoInput.addEventListener('input', () => {
                    if (rhoInput.checkValidity()) {
                        rhoSlider.value = rhoInput.value;
                        update();
                    }
                });
                
                document.getElementById('gc-sample-btn-1').addEventListener('click', () => generateSamples(1));
                document.getElementById('gc-sample-btn-10').addEventListener('click', () => generateSamples(10));
                document.getElementById('gc-sample-btn-100').addEventListener('click', () => generateSamples(100));
                document.getElementById('gc-sample-btn-1000').addEventListener('click', () => generateSamples(1000));
                document.getElementById('gc-sample-clear-btn').addEventListener('click', () => {
                    currentState.samples = [];
                    updateJointAndMarginalPlots();
                });
                
                condVarSelect = document.getElementById('gc-cond-var');
                const condTypeSelect = document.getElementById('gc-cond-type');
                condValueInput = document.getElementById('gc-cond-value');
                
                condVarSelect.addEventListener('input', () => {
                    updateCondValueToMean();
                    plotConditional();
                });
                condTypeSelect.addEventListener('input', plotConditional);
                condValueInput.addEventListener('input', plotConditional);
                document.getElementById('gc-interval-select').addEventListener('change', updateDensityPlot);

                window.addEventListener('resize', () => { updateJointAndMarginalPlots(); updateDensityPlot(); });
                
                const scatterResizeObserver = new ResizeObserver(() => setTimeout(updateJointAndMarginalPlots, 0));
                scatterResizeObserver.observe(document.getElementById('gc-joint-plot-grid'));

                const densityResizeObserver = new ResizeObserver(() => setTimeout(updateDensityPlot, 0));
                densityResizeObserver.observe(document.querySelector('#gc-density-plot-container .plot-svg-wrapper'));

                setupMoveControls('#gc-plots-panel');

                handleDistChange('x');
                handleDistChange('y');
                renderMathInElement(document.getElementById('gaussian-copula-app'), {
                    delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
                });
            },
            updateFromURL: (params) => {
                const dists = { X: params.get('distX'), Y: params.get('distY') };
                ['X', 'Y'].forEach(v => {
                    if (dists[v] && CONTINUOUS_DISTRIBUTIONS[dists[v]]) {
                        document.getElementById(`gc-dist-select-${v.toLowerCase()}`).value = dists[v];
                        handleDistChange(v.toLowerCase());
                        const config = CONTINUOUS_DISTRIBUTIONS[dists[v]];
                        config.params.forEach(p => {
                            if (params.has(`${p.id}${v}`)) {
                                document.getElementById(`gc-param-${p.id}-${v.toLowerCase()}`).value = params.get(`${p.id}${v}`);
                            }
                        });
                    }
                });
                if (params.has('rho')) {
                    const rhoVal = params.get('rho');
                    document.getElementById('gc-rho-slider').value = rhoVal;
                    document.getElementById('gc-rho-input').value = rhoVal;
                }
                update({ fromURL: true });
            }
        };
    })();

    const wienerProcessApp = (() => {
        let state = {
            x0: 0, m: 0, sigma: 1, T: 1,
            barrier: 2,
            paths: []
        };
        const pathsSvg = d3.select("#wp-paths-svg");
        const marginalSvg = d3.select("#wp-marginal-svg");
        const htDensitySvg = d3.select("#wp-ht-density-svg");
        const htProbSvg = d3.select("#wp-ht-prob-svg");
        const hpByBarrierSvg = d3.select("#wp-hp-by-barrier-svg");
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };

        function init() {
            document.getElementById('wp-x0').addEventListener('input', update);
            document.getElementById('wp-drift').addEventListener('input', update);
            document.getElementById('wp-volatility').addEventListener('input', update);
            document.getElementById('wp-terminal-time').addEventListener('input', update);
            document.getElementById('wp-barrier').addEventListener('input', update);
            document.getElementById('wp-cone-select').addEventListener('change', update);

            document.getElementById('wp-clear-paths-btn').addEventListener('click', () => {
                state.paths = [];
                updatePathsPlot();
            });
            document.getElementById('wp-draw1-btn').addEventListener('click', () => drawSamplePaths(1));
            document.getElementById('wp-draw10-btn').addEventListener('click', () => drawSamplePaths(10));
            document.getElementById('wp-draw100-btn').addEventListener('click', () => drawSamplePaths(100));
            
            const resizeObserver = new ResizeObserver(() => {
                setTimeout(update, 0);
            });
            document.querySelectorAll('#wiener-process-app .wp-plot-container').forEach(el => resizeObserver.observe(el));

            setupMoveControls('#wp-plots-wrapper');

            update();
            renderMathInElement(document.getElementById('wiener-process-app'), {
                delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}],
            });
        }

        function updateURL() {
            const params = new URLSearchParams();
            params.set('x0', state.x0);
            params.set('m', state.m);
            params.set('sigma', state.sigma);
            params.set('T', state.T);
            params.set('barrier', state.barrier);
            history.replaceState(null, '', '#wiener-process?' + params.toString());
        }

        function update(options = {}) {
            state.x0 = parseFloat(document.getElementById('wp-x0').value);
            state.m = parseFloat(document.getElementById('wp-drift').value);
            state.sigma = parseFloat(document.getElementById('wp-volatility').value);
            state.T = parseFloat(document.getElementById('wp-terminal-time').value);
            state.barrier = parseFloat(document.getElementById('wp-barrier').value);
            
            if (isNaN(state.x0) || isNaN(state.m) || isNaN(state.sigma) || isNaN(state.T) || state.sigma <= 0 || state.T <= 0) {
                return;
            }

            updatePathsPlot();
            updateHittingTimePlots();
            updateHittingProbByBarrierPlot();
            if (!options.fromURL) {
                updateURL();
            }
        }
        
        function drawSamplePaths(count) {
            const dt = state.T / 100;
            const drift_term = state.m * dt;
            const vol_term = state.sigma * Math.sqrt(dt);

            for (let i = 0; i < count; i++) {
                const path = [{t: 0, x: state.x0}];
                let current_x = state.x0;
                for (let j = 1; j <= 100; j++) {
                    const Z = jStat.normal.sample(0, 1);
                    current_x += drift_term + vol_term * Z;
                    path.push({ t: j * dt, x: current_x });
                }
                state.paths.push(path);
            }
            updatePathsPlot();
        }

        function updatePathsPlot() {
            const { x0, m, sigma, T } = state;
            const rect = pathsSvg.node().getBoundingClientRect();
            const marginalRect = marginalSvg.node().getBoundingClientRect();
            
            if (rect.width <= 0 || marginalRect.width <= 0) return;

            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            const marginalWidth = marginalRect.width - margin.right;

            if (width <= 0 || height <= 0) return;

            pathsSvg.selectAll("*").remove();
            marginalSvg.selectAll("*").remove();
            const g = pathsSvg.append("g")
                               .attr("transform", `translate(${margin.left},${margin.top})`);

            const timePoints = d3.range(0, T, T/100).concat(T);
            const meanPath = timePoints.map(t => x0 + m * t);
            const stdDevs = timePoints.map(t => sigma * Math.sqrt(t));
            
            const coneValue = document.getElementById('wp-cone-select').value;
            let z_score = 0;
            if (coneValue !== '0') {
                const p = parseFloat(coneValue.substring(1)) / 100;
                z_score = jStat.normal.inv(1 - (1-p)/2, 0, 1);
            }
            
            const lowerBound = meanPath.map((mean, i) => mean - z_score * stdDevs[i]);
            const upperBound = meanPath.map((mean, i) => mean + z_score * stdDevs[i]);

            const yDomain = d3.extent([
                ...lowerBound, ...upperBound,
                ...(state.paths.length > 0 ? state.paths.flatMap(path => path.map(p => p.x)) : [x0])
            ]);
            
            if (yDomain[0] === yDomain[1]) {
                 yDomain[0] -= 1; yDomain[1] += 1;
            }

            const xScale = d3.scaleLinear().domain([0, T]).range([0, width]);
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale));

            if (z_score > 0) {
                const coneData = timePoints.map((t, i) => ({ t, lower: lowerBound[i], upper: upperBound[i] }));
                const area = d3.area()
                    .x(d => xScale(d.t))
                    .y0(d => yScale(d.lower))
                    .y1(d => yScale(d.upper));
                g.append("path").datum(coneData).attr("class", "cone-area").attr("d", area);
            }
            
            g.append("path").datum(timePoints.map((t, i) => ({t, x: meanPath[i]})))
             .attr("class", "line-path").style("stroke", "black").style("stroke-dasharray", "4")
             .attr("d", d3.line().x(d => xScale(d.t)).y(d => yScale(d.x)));

            const line = d3.line().x(d => xScale(d.t)).y(d => yScale(d.x));
            g.selectAll(".sample-path").data(state.paths).enter()
             .append("path").attr("class", "sample-path").attr("d", line);
            
            const marginalG = marginalSvg.append("g")
                .attr("transform", `translate(0,${margin.top})`);
            
            const mu_T = x0 + m * T;
            const sigma_T = sigma * Math.sqrt(T);
            const terminalDist = jStat.normal(mu_T, sigma_T);

            const yValuesForDensity = d3.range(yDomain[0], yDomain[1], (yDomain[1] - yDomain[0]) / 100);
            const densityData = yValuesForDensity.map(y => ({ y: y, p: terminalDist.pdf(y) }));

            const maxDensity = d3.max(densityData, d => d.p) || 1;
            const marginalXScale = d3.scaleLinear().domain([0, maxDensity * 1.1]).range([0, marginalWidth]);
            
            if (state.paths.length > 0) {
                const terminalValues = state.paths.map(path => path[path.length - 1].x);
                const histogram = d3.histogram()
                    .domain(yScale.domain())
                    .thresholds(yScale.ticks(20))
                    (terminalValues);
                
                const histMax = d3.max(histogram, d => d.length) || 1;

                marginalG.selectAll(".histogram-bar")
                    .data(histogram)
                    .enter().append("rect")
                    .attr("class", "histogram-bar")
                    .attr("y", d => yScale(d.x1) + 1)
                    .attr("height", d => Math.max(0, yScale(d.x0) - yScale(d.x1) - 1))
                    .attr("x", 0)
                    .attr("width", d => marginalXScale(d.length * maxDensity / histMax));
            }
            
            marginalG.append("path")
                .datum(densityData)
                .attr("class", "line-path")
                .style("stroke", "#d9534f")
                .attr("d", d3.line()
                    .x(d => marginalXScale(d.p))
                    .y(d => yScale(d.y))
                );
        }

        function updateHittingTimePlots() {
            const { x0, m, sigma, T, barrier } = state;
            
            const a = barrier - x0;

            if (Math.abs(a) < 1e-9) { 
                htDensitySvg.selectAll("*").remove();
                htProbSvg.selectAll("*").remove();
                return;
            }

            const htDensityPdf = t => {
                if (t <= 0) return 0;
                return (Math.abs(a) / (sigma * Math.sqrt(2 * Math.PI * t * t * t))) * Math.exp(-Math.pow(a - m * t, 2) / (2 * sigma * sigma * t));
            };
            
            const htProbCdf = t => {
                if (t <= 0) return 0;
                let eff_m = m, eff_a = a;
                if (eff_a < 0) {
                    eff_m = -m;
                    eff_a = -a;
                }
                const term1 = jStat.normal.cdf((eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                const expTerm = Math.exp(2 * eff_m * eff_a / (sigma * sigma));
                if (!isFinite(expTerm)) return term1;
                const term2 = expTerm * jStat.normal.cdf((-eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                return term1 + term2;
            };

            const plotTimePoints = d3.range(T/200, T, T/200);

            const densityData = plotTimePoints.map(t => ({t, p: htDensityPdf(t)}));
            plotOnSvg(htDensitySvg, densityData, [0, T], "Time (t)", "Density", null, document.getElementById('wp-ht-density-tooltip'), htDensityPdf);
            
            const probData = plotTimePoints.map(t => ({t, p: htProbCdf(t)}));
            plotOnSvg(htProbSvg, probData, [0, T], "Time (t)", "Probability", [0, 1], document.getElementById('wp-ht-prob-tooltip'), htProbCdf);
        }

        function updateHittingProbByBarrierPlot() {
            const { x0, m, sigma, T } = state;
            
            if (sigma <= 0 || T <= 0) {
                hpByBarrierSvg.selectAll("*").remove();
                return;
            }

            const hittingProbByBarrier = b => {
                const a = b - x0;
                if (Math.abs(a) < 1e-9) return 1.0;
                const t = T;
                
                let eff_m = m, eff_a = a;
                if (eff_a < 0) {
                    eff_m = -m;
                    eff_a = -a;
                }
                const term1 = jStat.normal.cdf((eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                const expTerm = Math.exp(2 * eff_m * eff_a / (sigma * sigma));
                if (!isFinite(expTerm)) return term1;
                const term2 = expTerm * jStat.normal.cdf((-eff_m * t - eff_a) / (sigma * Math.sqrt(t)), 0, 1);
                return term1 + term2;
            };

            const range_dev = 4 * sigma * Math.sqrt(T);
            const barrierDomain = [x0 - range_dev, x0 + range_dev];
            
            const plotBarrierPoints = d3.range(barrierDomain[0], barrierDomain[1], (barrierDomain[1] - barrierDomain[0])/200);

            const plotData = plotBarrierPoints.map(b => ({b, p: hittingProbByBarrier(b)}));
            
            plotBarrierProbOnSvg(hpByBarrierSvg, plotData, barrierDomain, "Barrier (b)", "Hitting Probability", [0, 1], document.getElementById('wp-hp-by-barrier-tooltip'), hittingProbByBarrier);
        }
        
        function plotOnSvg(svg, data, xDomain, xLabel, yLabel, yDomain = null, tooltipEl = null, yFunc = null) {
            const rect = svg.node().getBoundingClientRect();
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            if (width <= 0 || height <= 0) return;

            svg.selectAll("*").remove();
            const g = svg.append("g")
                         .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);
            
            if (!yDomain) {
                const yMax = d3.max(data, d => d.p);
                yDomain = [0, isFinite(yMax) && yMax > 0 ? yMax * 1.1 : 1];
            }
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale).ticks(5));
            
            g.append("text").attr("x", width/2).attr("y", height + 35).style("text-anchor", "middle").text(xLabel);
            g.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left+15).attr("x", -height/2).style("text-anchor", "middle").text(yLabel);

            g.append("path").datum(data)
             .attr("class", "line-path").style("stroke", "steelblue")
             .attr("d", d3.line().x(d => xScale(d.t)).y(d => yScale(d.p)));

            if (!tooltipEl || !yFunc) return;

            const focus = g.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            
            const interactionRect = svg.append("rect")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .style("fill", "none")
                .style("pointer-events", "all")
                .style("touch-action", "none")
                .attr("width", width)
                .attr("height", height);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, svg.node().parentNode);
                tooltipEl.style.left = tipX + "px";
                tooltipEl.style.top = tipY + "px";
                
                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                if (x_val < xDomain[0] || x_val > xDomain[1]) return;
                const y_val = yFunc(x_val);
                
                focus.attr("cx", xScale(x_val)).attr("cy", yScale(y_val));
                tooltipEl.innerHTML = `t: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }
            
            interactionRect.on("mouseover", () => {
                focus.style("opacity", 1);
                tooltipEl.style.opacity = 1;
            }).on("mouseout", () => {
                focus.style("opacity", 0);
                tooltipEl.style.opacity = 0;
            }).on("mousemove", updateTooltip);

            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                    focus.style("opacity", 1);
                    tooltipEl.style.opacity = 1;
                }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                }
            });
            node.addEventListener('touchend', (event) => {
                if (event.touches.length === 0) {
                    focus.style("opacity", 0);
                    tooltipEl.style.opacity = 0;
                }
            });
        }
        
        function plotBarrierProbOnSvg(svg, data, xDomain, xLabel, yLabel, yDomain = null, tooltipEl = null, yFunc = null) {
            const rect = svg.node().getBoundingClientRect();
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            if (width <= 0 || height <= 0) return;

            svg.selectAll("*").remove();
            const g = svg.append("g")
                            .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);
            
            if (!yDomain) {
                const yMax = d3.max(data, d => d.p);
                yDomain = [0, isFinite(yMax) && yMax > 0 ? yMax * 1.1 : 1];
            }
            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

            g.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${height})`).call(d3.axisBottom(xScale));
            g.append("g").attr("class", "y-axis axis").call(d3.axisLeft(yScale).ticks(5));
            
            g.append("text").attr("x", width/2).attr("y", height + 35).style("text-anchor", "middle").text(xLabel);
            g.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left+15).attr("x", -height/2).style("text-anchor", "middle").text(yLabel);

            g.append("path").datum(data)
             .attr("class", "line-path").style("stroke", "steelblue")
             .attr("d", d3.line().x(d => xScale(d.b)).y(d => yScale(d.p)));

            if (!tooltipEl || !yFunc) return;

            const focus = g.append("circle").style("fill", "none").attr("stroke", "black").attr("r", 4).style("opacity", 0);
            
            const interactionRect = svg.append("rect")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .style("fill", "none")
                .style("pointer-events", "all")
                .style("touch-action", "none")
                .attr("width", width)
                .attr("height", height);

            function updateTooltip(event) {
                const [tipX, tipY] = d3.pointer(event, svg.node().parentNode);
                tooltipEl.style.left = tipX + "px";
                tooltipEl.style.top = tipY + "px";
                
                const [x_coord] = d3.pointer(event, interactionRect.node());
                const x_val = xScale.invert(x_coord);
                if (x_val < xDomain[0] || x_val > xDomain[1]) return;
                const y_val = yFunc(x_val);
                
                focus.attr("cx", xScale(x_val)).attr("cy", yScale(y_val));
                tooltipEl.innerHTML = `b: ${x_val.toFixed(3)}<br>y: ${y_val.toFixed(5)}`;
            }
            
            interactionRect.on("mouseover", () => {
                focus.style("opacity", 1);
                tooltipEl.style.opacity = 1;
            }).on("mouseout", () => {
                focus.style("opacity", 0);
                tooltipEl.style.opacity = 0;
            }).on("mousemove", updateTooltip);

            const node = interactionRect.node();
            node.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                    focus.style("opacity", 1);
                    tooltipEl.style.opacity = 1;
                }
            });
            node.addEventListener('touchmove', (event) => {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    updateTooltip(event.touches[0]);
                }
            });
            node.addEventListener('touchend', (event) => {
                if (event.touches.length === 0) {
                    focus.style("opacity", 0);
                    tooltipEl.style.opacity = 0;
                }
            });
        }

        return {
            init: init,
            updateFromURL: (params) => {
                const paramMap = {
                    'x0': 'wp-x0',
                    'm': 'wp-drift',
                    'sigma': 'wp-volatility',
                    'T': 'wp-terminal-time',
                    'barrier': 'wp-barrier'
                };
                let needsUpdate = false;
                for (const [key, id] of Object.entries(paramMap)) {
                    if (params.has(key)) {
                        const input = document.getElementById(id);
                        if (input) {
                            input.value = params.get(key);
                            needsUpdate = true;
                        }
                    }
                }
                if (needsUpdate) {
                    update({ fromURL: true });
                }
            }
        };
    })();

    let deferredPrompt;
    const installButton = document.getElementById('install-button');

    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
        if (installButton) {
            installButton.style.display = 'inline-flex';
            installButton.disabled = true;
        }
    }

    window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent Chrome 67 and earlier from automatically showing the prompt
        e.preventDefault();
        // Stash the event so it can be triggered later.
        deferredPrompt = e;
        // Update UI to notify the user they can add to home screen
        if (installButton) {
            installButton.style.display = 'inline-flex';
            installButton.disabled = false;
        }
    });

    if (installButton) {
        installButton.addEventListener('click', async () => {
            if (deferredPrompt) {
                // Show the prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                // We've used the prompt, and can't use it again, throw it away
                deferredPrompt = null;
                if (outcome === 'accepted') {
                    installButton.disabled = true;
                } else {
                    installButton.style.display = 'none';
                }
            }
        });
    }

    // Main App Router and Controls
    const menuBtn = document.getElementById('menu-btn');
    const menu = document.getElementById('menu');
    const appContainers = {
        distributions: document.getElementById('distributions-app'),
        'order-statistics': document.getElementById('order-statistics-app'),
        'gaussian-copula': document.getElementById('gaussian-copula-app'),
        'wiener-process': document.getElementById('wiener-process-app'),
        bernoulli: document.getElementById('bernoulli-app'),
        about: document.getElementById('about-app'),
        install: document.getElementById('install-app')
    };
    const appModules = {
        distributions: distributionsApp,
        'order-statistics': orderStatisticsApp,
        'gaussian-copula': gaussianCopulaApp,
        'wiener-process': wienerProcessApp,
        bernoulli: bernoulliApp
    };
    const initializedApps = { distributions: false, 'order-statistics': false, 'gaussian-copula': false, 'wiener-process': false, bernoulli: false };
    const appTitles = {
        distributions: 'Distributions',
        'order-statistics': 'Order Statistics',
        'gaussian-copula': 'Gaussian Copula',
        'wiener-process': 'Wiener Process',
        bernoulli: 'Correlated Bernoulli',
        about: 'About',
        install: 'Install on device'
    };

    menuBtn.addEventListener('click', () => {
        menu.classList.toggle('visible');
    });

    document.body.addEventListener('click', (e) => {
        if (!menu.contains(e.target) && !menuBtn.contains(e.target) && menu.classList.contains('visible')) {
            menu.classList.remove('visible');
        }
    });

    menu.addEventListener('click', () => menu.classList.remove('visible'));

    function router() {
        const hash = window.location.hash || '#distributions';
        const [appNameWithHash, queryString] = hash.split('?');
        const appName = appNameWithHash.substring(1);
        const params = new URLSearchParams(queryString);

        Object.values(appContainers).forEach(c => c.classList.remove('active'));

        if (appContainers[appName]) {
            const title = `Probly: ${appTitles[appName]}`;
            document.title = title;
            document.getElementById('app-title-bar').textContent = title;
            appContainers[appName].classList.add('active');
            if (appModules[appName] && !initializedApps[appName]) {
                appModules[appName].init();
                initializedApps[appName] = true;
            }
            if (appModules[appName]) {
                appModules[appName].updateFromURL(params);
            }
        } else {
            const title = `Probly: ${appTitles.bernoulli}`;
            document.title = title;
            document.getElementById('app-title-bar').textContent = title;
            appContainers.bernoulli.classList.add('active');
            if (!initializedApps.bernoulli) {
                appModules.bernoulli.init();
                initializedApps.bernoulli = true;
            }
        }
    }

    window.addEventListener('hashchange', router);
    router();
});
</script>

</body>
</html>
